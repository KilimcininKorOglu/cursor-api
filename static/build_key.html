<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/x-icon" href="data:image/x-icon;," />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Build Key</title>
  <!-- Include shared styles -->
  <link rel="stylesheet" href="/static/shared-styles.css" />
  <script src="/static/shared.js"></script>
  <style>
    /* Form section styles */
    .form-section {
      margin-bottom: 30px;
      padding: 20px;
      background: var(--card-background);
      border-radius: var(--border-radius);
      border: 1px solid var(--border-color);
    }

    .form-section h3 {
      margin: 0 0 15px 0;
      color: var(--text-primary);
      font-size: 16px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .form-section-description {
      margin-bottom: 15px;
      color: var(--text-secondary);
      font-size: 14px;
    }

    /* Required field marker */
    .required-mark {
      color: var(--error-color);
      margin-left: 4px;
    }

    /* Input hint styles */
    .input-hint {
      font-size: 12px;
      color: var(--text-secondary);
      margin-top: 4px;
    }

    /* Key result display styles */
    .key-result {
      background: var(--card-background);
      border-radius: var(--border-radius);
      border: 1px solid var(--border-color);
      margin-top: var(--spacing);
      overflow: hidden;
    }

    .key-result-header {
      padding: 15px 20px;
      background: var(--primary-color-alpha);
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .key-result-header h3 {
      margin: 0;
      color: var(--primary-color);
      font-size: 16px;
    }

    .key-result-content {
      padding: 20px;
    }

    .key-item {
      margin-bottom: 15px;
      padding: 15px;
      background: var(--background-color);
      border-radius: 4px;
      position: relative;
    }

    .key-item:last-child {
      margin-bottom: 0;
    }

    .key-label {
      font-size: 12px;
      color: var(--text-secondary);
      margin-bottom: 5px;
      font-weight: 500;
    }

    .key-value {
      font-family: monospace;
      font-size: 14px;
      word-break: break-all;
      color: var(--text-primary);
      padding-right: 80px;
    }

    .copy-button {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      padding: 6px 12px;
      font-size: 12px;
      background: var(--primary-color-alpha);
      color: var(--primary-color);
      border: 1px solid var(--primary-color);
      border-radius: 4px;
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .copy-button:hover {
      background: var(--primary-color);
      color: white;
      transform: translateY(calc(-50% + 1px));
    }

    .copy-button.copied {
      background: var(--success-color);
      color: white;
      border-color: var(--success-color);
    }

    /* Model selector styles */
    .model-list {
      max-height: 200px;
      overflow-y: auto;
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      margin-top: 8px;
      background: var(--background-color);
    }

    .model-item {
      display: flex;
      align-items: center;
      padding: 6px 0;
      transition: background var(--transition-fast);
    }

    .model-item:hover {
      background: var(--primary-color-alpha);
      margin: 0 -10px;
      padding-left: 10px;
      padding-right: 10px;
    }

    .model-item input[type="checkbox"] {
      margin-right: 8px;
      flex-shrink: 0;
    }

    .model-item label {
      margin: 0;
      cursor: pointer;
      flex: 1;
      user-select: none;
    }

    /* Collapsible panel styles */
    .collapsible {
      cursor: pointer;
      user-select: none;
    }

    .collapsible::before {
      content: "▼";
      display: inline-block;
      margin-right: 8px;
      transition: transform var(--transition-fast);
      font-size: 12px;
    }

    .collapsible.collapsed::before {
      transform: rotate(-90deg);
    }

    .collapsible-content {
      margin-top: 15px;
      transition: all var(--transition-fast);
    }

    .collapsible-content.collapsed {
      display: none;
    }

    /* Input validation styles */
    input.invalid {
      border-color: var(--error-color);
    }

    input.valid {
      border-color: var(--success-color);
    }

    /* Quick action buttons */
    .quick-actions {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }

    .quick-action-button {
      padding: 6px 12px;
      font-size: 12px;
      background: var(--background-color);
      color: var(--text-primary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .quick-action-button:hover {
      background: var(--primary-color-alpha);
      border-color: var(--primary-color);
      color: var(--primary-color);
    }

    /* Timezone selector styles */
    .timezone-selector {
      position: relative;
    }

    .timezone-search {
      width: 100%;
      box-sizing: border-box;
    }

    .timezone-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      max-height: 300px;
      overflow-y: auto;
      background: var(--card-background);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      margin-top: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      display: none;
    }

    .timezone-dropdown.show {
      display: block;
    }

    .timezone-item {
      padding: 10px 15px;
      cursor: pointer;
      transition: background var(--transition-fast);
      border-bottom: 1px solid var(--border-color);
    }

    .timezone-item:last-child {
      border-bottom: none;
    }

    .timezone-item:hover {
      background: var(--primary-color-alpha);
    }

    .timezone-item.selected {
      background: var(--primary-color-alpha);
      color: var(--primary-color);
    }

    .timezone-name {
      font-weight: 500;
      margin-bottom: 2px;
    }

    .timezone-offset {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .timezone-no-results {
      padding: 20px;
      text-align: center;
      color: var(--text-secondary);
    }

    /* Responsive layout optimization */
    @media (max-width: 768px) {
      .form-section {
        padding: 15px;
      }

      .key-value {
        padding-right: 0;
        margin-bottom: 10px;
      }

      .copy-button {
        position: static;
        transform: none;
        width: 100%;
        margin-top: 10px;
      }

      .quick-actions {
        flex-wrap: wrap;
      }

      .timezone-dropdown {
        max-height: 250px;
      }
    }
  </style>
</head>

<body>
  <h1>Key Builder</h1>

  <div class="container">
    <!-- Quick actions -->
    <div class="quick-actions">
      <button class="quick-action-button" onclick="loadFromCache()">
        Restore Last Data
      </button>
      <button class="quick-action-button" onclick="clearForm()">
        Clear Form
      </button>
    </div>

    <!-- APIAuthentication Key -->
    <div class="form-section">
      <h3>API Authentication</h3>
      <p class="form-section-description">
        Enter the authentication key for calling the Build Key service
      </p>
      <div class="form-group">
        <label>
          Authentication Key (AUTH_TOKEN)
        </label>
        <input type="password" id="authToken" placeholder="Key for authenticating API calls (optional)" autocomplete="off" />
        <div class="input-hint">This key is used to authenticate access to the Build Key service (optional field)</div>
      </div>
    </div>

    <!-- Authentication Info -->
    <div class="form-section">
      <h3 class="collapsible" onclick="toggleSection(this)">Authentication Info</h3>
      <div class="collapsible-content">
        <p class="form-section-description">Enter the token and checksum information required for authentication</p>

        <div class="form-group">
          <label>
            Token (Token)
            <span class="required-mark">*</span>
          </label>
          <input type="text" id="token" placeholder="Enter JWT format token" autocomplete="off" />
          <div class="input-hint">JWT format authentication token</div>
        </div>

        <div class="form-group">
          <label>
            Checksum - First
            <span class="required-mark">*</span>
          </label>
          <input type="text" id="checksumFirst" placeholder="64-bit Hex encoded string" pattern="^[0-9a-fA-F]{64}$" maxlength="64"
            autocomplete="off" />
          <div class="input-hint">64 hexadecimal characters (0-9, a-f, A-F)</div>
        </div>

        <div class="form-group">
          <label>
            Checksum - Second
            <span class="required-mark">*</span>
          </label>
          <input type="text" id="checksumSecond" placeholder="64-bit Hex encoded string" pattern="^[0-9a-fA-F]{64}$" maxlength="64"
            autocomplete="off" />
          <div class="input-hint">64 hexadecimal characters (0-9, a-f, A-F)</div>
        </div>

        <div class="form-group">
          <label>
            Client Key (Client Key)
            <span class="required-mark">*</span>
          </label>
          <input type="text" id="clientKey" placeholder="64-bit Hex encoded string" pattern="^[0-9a-fA-F]{64}$" maxlength="64"
            autocomplete="off" />
          <div class="input-hint">64 hexadecimal characters (0-9, a-f, A-F)</div>
        </div>
      </div>
    </div>

    <!-- Configuration Info -->
    <div class="form-section">
      <h3 class="collapsible" onclick="toggleSection(this)">Configuration Info</h3>
      <div class="collapsible-content">
        <p class="form-section-description">Set configuration version and session ID</p>

        <div class="form-group">
          <label>
            Config Version (Config Version)
            <span class="required-mark">*</span>
          </label>
          <div style="display: flex; gap: 10px; align-items: flex-start;">
            <input type="text" id="configVersion" placeholder="UUID format, e.g.: 550e8400-e29b-41d4-a716-446655440000"
              pattern="^[0-9a-fA-F]{8}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{12}$"
              style="flex: 1;" />
            <button type="button" id="fetchConfigVersionButton" onclick="fetchConfigVersion()"
              style="padding: 8px 16px; font-size: 14px; white-space: nowrap;">
              Get
            </button>
          </div>
          <div class="input-hint">Standard UUID format, fill in other fields first then click "Get" button</div>
        </div>

        <div class="form-group">
          <label>
            Session ID (Session ID)
            <span class="required-mark">*</span>
          </label>
          <input type="text" id="sessionId" placeholder="UUID format, e.g.: 550e8400-e29b-41d4-a716-446655440000"
            pattern="^[0-9a-fA-F]{8}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{12}$" />
          <div class="input-hint">Standard UUID format</div>
        </div>

        <div class="form-group">
          <label>Secret (Secret)</label>
          <input type="text" id="secret" placeholder="Optional field" />
          <div class="input-hint">Optional, usually not required</div>
        </div>
      </div>
    </div>

    <!-- Proxy and Region Settings -->
    <div class="form-section">
      <h3 class="collapsible collapsed" onclick="toggleSection(this)">
        Proxy and Region Settings
      </h3>
      <div class="collapsible-content collapsed">
        <p class="form-section-description">Configure proxy, timezone and code completion region</p>

        <div class="form-group">
          <label>Proxy Name (Proxy Name)</label>
          <input type="text" id="proxyName" placeholder="Enter proxy name (optional)" />
          <div class="input-hint">Specify the proxy to use</div>
        </div>

        <div class="form-group">
          <label>Timezone (Timezone)</label>
          <div class="timezone-selector">
            <input type="text" id="timezone" class="timezone-search" placeholder="Search timezone, e.g.: Shanghai, Beijing, Tokyo (optional)"
              autocomplete="off" onkeyup="filterTimezones(this.value)" onfocus="showTimezoneDropdown()"
              onblur="hideTimezoneDropdown(event)" />
            <div id="timezoneDropdown" class="timezone-dropdown">
              <!-- Dynamically generated timezone list -->
            </div>
          </div>
          <div class="input-hint">
            Enter city name or timezone name to search, or select from list
          </div>
        </div>

        <div class="form-group">
          <label>Code Completion Region (GCPP Host)</label>
          <select id="gcppHost">
            <option value="">Follow Global Settings</option>
            <option value="Asia">Asia (Asia)</option>
            <option value="EU">Europe (EU)</option>
            <option value="US">US (US)</option>
          </select>
          <div class="input-hint">Select the nearest server region for better latency</div>
        </div>
      </div>
    </div>

    <!-- Feature Toggles -->
    <div class="form-section">
      <h3 class="collapsible collapsed" onclick="toggleSection(this)">
        Feature Toggles
      </h3>
      <div class="collapsible-content collapsed">
        <p class="form-section-description">Control the enable status of various features</p>

        <div class="form-group">
          <label>Vision Capability (Vision)</label>
          <select id="disableVision">
            <option value="">Follow Global Settings</option>
            <option value="false">Enable</option>
            <option value="true">Disable</option>
          </select>
          <div class="input-hint">Control whether to enable image recognition</div>
        </div>

        <div class="form-group">
          <label>Slow Pool (Slow Pool)</label>
          <select id="enableSlowPool">
            <option value="">Follow Global Settings</option>
            <option value="true">Enable</option>
            <option value="false">Disable</option>
          </select>
          <div class="input-hint">May get more stable but slower service when enabled</div>
        </div>

        <div class="form-group">
          <label>Web References (Web References)</label>
          <select id="includeWebReferences">
            <option value="">Follow Global Settings</option>
            <option value="true">Include</option>
            <option value="false">Exclude</option>
          </select>
          <div class="input-hint">Whether to include web reference information in response</div>
        </div>
      </div>
    </div>

    <!-- Usage Check Configuration -->
    <div class="form-section">
      <h3 class="collapsible collapsed" onclick="toggleSection(this)">
        Usage Check Configuration
      </h3>
      <div class="collapsible-content collapsed">
        <p class="form-section-description">Configure model usage check rules</p>

        <div class="form-group">
          <label>Check Rules</label>
          <select id="usageCheckType" onchange="toggleModelList()">
            <option value="">Follow Global Settings</option>
            <option value="default">Use Default Rules</option>
            <option value="disabled">Disable check</option>
            <option value="all">Check All Models</option>
            <option value="custom">Custom Model List</option>
          </select>
          <div class="input-hint">Select how to check model usage</div>
        </div>

        <div id="modelListContainer" class="model-list" style="display: none">
          <div style="
              padding: 10px;
              text-align: center;
              color: var(--text-secondary);
            ">
            Loading model list...
          </div>
        </div>
      </div>
    </div>

    <!-- Action buttons -->
    <div class="button-group">
      <button onclick="buildKey()" id="buildButton">Build Key</button>
      <button onclick="clearForm()" class="secondary">Clear Form</button>
    </div>
  </div>

  <!-- Key result display -->
  <div id="keyResult" class="key-result" style="display: none">
    <div class="key-result-header">
      <h3>Generated Key</h3>
      <button class="secondary" onclick="hideKeyResult()">Close</button>
    </div>
    <div class="key-result-content" id="keyContent">
      <!-- Dynamically generated content -->
    </div>
  </div>

  <script>
    // Configuration constants
    const CONFIG = {
      HEX_PATTERN: /^[0-9a-fA-F]{64}$/,
      UUID_PATTERN:
        /^[0-9a-fA-F]{8}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{4}-?[0-9a-fA-F]{12}$/,
      CACHE_KEY: "buildKeyFormData",
      CACHE_EXPIRY: 7 * 24 * 60 * 60 * 1000, // 7 days
    };

    // Available model list
    let availableModels = [];

    // Timezone data
    const TIMEZONES = [
      // Major Asian cities
      {
        name: "Asia/Shanghai",
        display: "Shanghai",
        offset: "+08:00",
        keywords: ["shanghai", "Shanghai", "china", "China"],
      },
      {
        name: "Asia/Beijing",
        display: "Beijing",
        offset: "+08:00",
        keywords: ["beijing", "Beijing", "peking"],
      },
      {
        name: "Asia/Hong_Kong",
        display: "Hong Kong",
        offset: "+08:00",
        keywords: ["hongkong", "hong kong", "Hong Kong", "hk"],
      },
      {
        name: "Asia/Taipei",
        display: "Taipei",
        offset: "+08:00",
        keywords: ["taipei", "Taipei", "taiwan", "Taiwan"],
      },
      {
        name: "Asia/Singapore",
        display: "Singapore",
        offset: "+08:00",
        keywords: ["singapore", "Singapore", "sg"],
      },
      {
        name: "Asia/Tokyo",
        display: "Tokyo",
        offset: "+09:00",
        keywords: ["tokyo", "Tokyo", "japan", "Japan"],
      },
      {
        name: "Asia/Seoul",
        display: "Seoul",
        offset: "+09:00",
        keywords: ["seoul", "Seoul", "korea", "Korea"],
      },
      {
        name: "Asia/Bangkok",
        display: "Bangkok",
        offset: "+07:00",
        keywords: ["bangkok", "Bangkok", "thailand", "Thailand"],
      },
      {
        name: "Asia/Jakarta",
        display: "Jakarta",
        offset: "+07:00",
        keywords: ["jakarta", "Jakarta", "indonesia", "Indonesia"],
      },
      {
        name: "Asia/Kolkata",
        display: "Kolkata",
        offset: "+05:30",
        keywords: ["kolkata", "calcutta", "Kolkata", "india", "India"],
      },
      {
        name: "Asia/Dubai",
        display: "Dubai",
        offset: "+04:00",
        keywords: ["dubai", "Dubai", "uae", "UAE"],
      },

      // Major European cities
      {
        name: "Europe/London",
        display: "London",
        offset: "+00:00",
        keywords: ["london", "London", "uk", "UK", "britain"],
      },
      {
        name: "Europe/Paris",
        display: "Paris",
        offset: "+01:00",
        keywords: ["paris", "Paris", "france", "France"],
      },
      {
        name: "Europe/Berlin",
        display: "Berlin",
        offset: "+01:00",
        keywords: ["berlin", "Berlin", "germany", "Germany"],
      },
      {
        name: "Europe/Madrid",
        display: "Madrid",
        offset: "+01:00",
        keywords: ["madrid", "Madrid", "spain", "Spain"],
      },
      {
        name: "Europe/Rome",
        display: "Rome",
        offset: "+01:00",
        keywords: ["rome", "Rome", "italy", "Italy"],
      },
      {
        name: "Europe/Moscow",
        display: "Moscow",
        offset: "+03:00",
        keywords: ["moscow", "Moscow", "russia", "Russia"],
      },
      {
        name: "Europe/Amsterdam",
        display: "Amsterdam",
        offset: "+01:00",
        keywords: ["amsterdam", "Amsterdam", "netherlands", "Netherlands"],
      },
      {
        name: "Europe/Zurich",
        display: "Zurich",
        offset: "+01:00",
        keywords: ["zurich", "Zurich", "switzerland", "Switzerland"],
      },

      // Major American cities
      {
        name: "America/New_York",
        display: "New York",
        offset: "-05:00",
        keywords: ["new york", "newyork", "New York", "ny", "eastern"],
      },
      {
        name: "America/Los_Angeles",
        display: "Los Angeles",
        offset: "-08:00",
        keywords: ["los angeles", "la", "Los Angeles", "pacific"],
      },
      {
        name: "America/Chicago",
        display: "Chicago",
        offset: "-06:00",
        keywords: ["chicago", "Chicago", "central"],
      },
      {
        name: "America/Toronto",
        display: "Toronto",
        offset: "-05:00",
        keywords: ["toronto", "Toronto", "canada", "Canada"],
      },
      {
        name: "America/Vancouver",
        display: "Vancouver",
        offset: "-08:00",
        keywords: ["vancouver", "Vancouver"],
      },
      {
        name: "America/Mexico_City",
        display: "Mexico City",
        offset: "-06:00",
        keywords: ["mexico city", "Mexico City", "mexico", "Mexico"],
      },
      {
        name: "America/Sao_Paulo",
        display: "Sao Paulo",
        offset: "-03:00",
        keywords: ["sao paulo", "Sao Paulo", "brazil", "Brazil"],
      },
      {
        name: "America/Buenos_Aires",
        display: "Buenos Aires",
        offset: "-03:00",
        keywords: ["buenos aires", "Buenos Aires", "argentina", "Argentina"],
      },

      // Oceania
      {
        name: "Australia/Sydney",
        display: "Sydney",
        offset: "+10:00",
        keywords: ["sydney", "Sydney", "australia", "Australia"],
      },
      {
        name: "Australia/Melbourne",
        display: "Melbourne",
        offset: "+10:00",
        keywords: ["melbourne", "Melbourne"],
      },
      {
        name: "Pacific/Auckland",
        display: "Auckland",
        offset: "+12:00",
        keywords: ["auckland", "Auckland", "new zealand", "New Zealand"],
      },

      // Other important timezones
      {
        name: "UTC",
        display: "UTC",
        offset: "+00:00",
        keywords: ["utc", "gmt", "greenwich"],
      },
      {
        name: "Asia/Chongqing",
        display: "Chongqing",
        offset: "+08:00",
        keywords: ["chongqing", "Chongqing"],
      },
      {
        name: "Asia/Shenzhen",
        display: "Shenzhen",
        offset: "+08:00",
        keywords: ["shenzhen", "Shenzhen"],
      },
      {
        name: "Asia/Guangzhou",
        display: "Guangzhou",
        offset: "+08:00",
        keywords: ["guangzhou", "Guangzhou", "canton"],
      },
      {
        name: "Asia/Hangzhou",
        display: "Hangzhou",
        offset: "+08:00",
        keywords: ["hangzhou", "Hangzhou"],
      },
      {
        name: "Asia/Chengdu",
        display: "Chengdu",
        offset: "+08:00",
        keywords: ["chengdu", "Chengdu"],
      },
      {
        name: "Asia/Wuhan",
        display: "Wuhan",
        offset: "+08:00",
        keywords: ["wuhan", "Wuhan"],
      },
      {
        name: "Asia/Harbin",
        display: "Harbin",
        offset: "+08:00",
        keywords: ["harbin", "Harbin"],
      },
      {
        name: "Asia/Urumqi",
        display: "Urumqi",
        offset: "+06:00",
        keywords: ["urumqi", "Urumqi", "xinjiang", "Xinjiang"],
      },
    ];

    // Whether timezone dropdown should stay open
    let keepTimezoneDropdownOpen = false;

    /**
     * Initialize page
     */
    async function initializePage() {
      // Initialize auth token handling
      initializeTokenHandling("authToken");

      // Load model list
      await loadModels();

      // Initialize timezone selector
      initializeTimezoneSelector();

      // Try to restore data from cache
      const cached = getCachedFormData();
      if (cached) {
        showGlobalMessage("Restored last form data", false, 2000);
      }

      // Add input validation
      setupInputValidation();

      // Auto save form data
      setupAutoSave();
    }

    /**
     * Load available model list
     */
    async function loadModels() {
      try {
        const response = await fetch("/v1/models");
        const data = await response.json();
        availableModels = data.data.map((model) => model.id);
        updateModelList();
      } catch (error) {
        console.error("Failed to get model list:", error);
      }
    }

    /**
     * Update model list UI
     */
    function updateModelList() {
      const container = document.getElementById("modelListContainer");
      if (availableModels.length === 0) {
        container.innerHTML =
          '<div style="padding: 10px; text-align: center; color: var(--text-secondary);">No available models</div>';
        return;
      }

      container.innerHTML = availableModels
        .map(
          (model) => `
      <div class="model-item">
        <input type="checkbox" id="model_${model}" value="${model}">
        <label for="model_${model}">${model}</label>
      </div>
    `,
        )
        .join("");
    }

    /**
     * Toggle model list display
     */
    function toggleModelList() {
      const type = document.getElementById("usageCheckType").value;
      const container = document.getElementById("modelListContainer");
      container.style.display = type === "custom" ? "block" : "none";
    }

    /**
     * Toggle collapsible panel
     */
    function toggleSection(element) {
      element.classList.toggle("collapsed");
      const content = element.nextElementSibling;
      content.classList.toggle("collapsed");
    }

    /**
     * Setup input validation
     */
    function setupInputValidation() {
      // Hex field validation
      ["checksumFirst", "checksumSecond", "clientKey"].forEach((id) => {
        const input = document.getElementById(id);
        input.addEventListener("input", function () {
          validateHexInput(this);
        });
      });

      // UUID field validation
      ["configVersion", "sessionId"].forEach((id) => {
        const input = document.getElementById(id);
        input.addEventListener("input", function () {
          validateUUIDInput(this);
        });
      });
    }

    /**
     * Validate Hex input
     */
    function validateHexInput(input) {
      const value = input.value.trim();
      if (value === "") {
        input.classList.remove("valid", "invalid");
        return;
      }

      if (CONFIG.HEX_PATTERN.test(value)) {
        input.classList.remove("invalid");
        input.classList.add("valid");
      } else {
        input.classList.remove("valid");
        input.classList.add("invalid");
      }
    }

    /**
     * Validate UUID input
     */
    function validateUUIDInput(input) {
      const value = input.value.trim();
      if (value === "") {
        input.classList.remove("valid", "invalid");
        return;
      }

      if (CONFIG.UUID_PATTERN.test(value)) {
        input.classList.remove("invalid");
        input.classList.add("valid");
      } else {
        input.classList.remove("valid");
        input.classList.add("invalid");
      }
    }

    /**
     * Setup auto save
     */
    function setupAutoSave() {
      const inputs = document.querySelectorAll("input, select");
      inputs.forEach((input) => {
        input.addEventListener("change", saveFormData);
      });
    }

    /**
     * Save form data to local storage
     */
    function saveFormData() {
      const formData = {
        authToken: document.getElementById("authToken").value,
        token: document.getElementById("token").value,
        checksumFirst: document.getElementById("checksumFirst").value,
        checksumSecond: document.getElementById("checksumSecond").value,
        clientKey: document.getElementById("clientKey").value,
        configVersion: document.getElementById("configVersion").value,
        sessionId: document.getElementById("sessionId").value,
        secret: document.getElementById("secret").value,
        proxyName: document.getElementById("proxyName").value,
        timezone: document.getElementById("timezone").value,
        gcppHost: document.getElementById("gcppHost").value,
        disableVision: document.getElementById("disableVision").value,
        enableSlowPool: document.getElementById("enableSlowPool").value,
        includeWebReferences: document.getElementById("includeWebReferences")
          .value,
        usageCheckType: document.getElementById("usageCheckType").value,
        selectedModels: getSelectedModels(),
      };

      const cacheData = {
        data: formData,
        timestamp: Date.now(),
      };

      localStorage.setItem(CONFIG.CACHE_KEY, JSON.stringify(cacheData));
    }

    /**
     * Restore form data from cache
     */
    function getCachedFormData() {
      try {
        const cached = localStorage.getItem(CONFIG.CACHE_KEY);
        if (!cached) return null;

        const { data, timestamp } = JSON.parse(cached);

        // Check if expired
        if (Date.now() - timestamp > CONFIG.CACHE_EXPIRY) {
          localStorage.removeItem(CONFIG.CACHE_KEY);
          return null;
        }

        // Restore form data
        Object.keys(data).forEach((key) => {
          if (key === "selectedModels") {
            // Restore selected models
            data[key].forEach((modelId) => {
              const checkbox = document.getElementById(`model_${modelId}`);
              if (checkbox) checkbox.checked = true;
            });
          } else {
            const element = document.getElementById(key);
            if (element) element.value = data[key] || "";
          }
        });

        return data;
      } catch (error) {
        console.error("Failed to restore cached data:", error);
        return null;
      }
    }

    /**
     * Load data from cache
     */
    function loadFromCache() {
      const cached = getCachedFormData();
      if (cached) {
        showGlobalMessage("Restored form data");
      } else {
        showGlobalMessage("No cached data found", true);
      }
    }

    /**
     * Get selected models
     */
    function getSelectedModels() {
      return Array.from(
        document.querySelectorAll("#modelListContainer input:checked"),
      ).map((input) => input.value);
    }

    /**
     * Generic API request function, choose to use makeAuthenticatedRequest or fetch
     */
    async function makeApiRequest(url, requestData) {
      const authToken = document.getElementById("authToken").value.trim();

      if (authToken) {
        // If hasAuthentication Key，use makeAuthenticatedRequest function
        const result = await makeAuthenticatedRequest(url, {
          body: JSON.stringify(requestData),
        });

        if (!result) {
          // makeAuthenticatedRequest already showed error message
          return null;
        }

        return result;
      } else {
        // If no authentication key, directly use fetch
        const response = await fetch(url, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(requestData),
        });

        if (!response.ok) {
          const errorText = await response.text();
          showGlobalMessage(`Request failed: ${response.status} ${errorText}`, true);
          return null;
        }

        return await response.json();
      }
    }

    /**
     * GetConfig Version
     */
    async function fetchConfigVersion() {
      // Validate required fields
      const requiredFields = {
        token: "Token",
        checksumFirst: "Checksum First",
        checksumSecond: "Checksum Second",
        clientKey: "Client Key",
        sessionId: "Session ID",
      };

      for (const [field, name] of Object.entries(requiredFields)) {
        const value = document.getElementById(field).value.trim();
        if (!value) {
          showGlobalMessage(`Please fill in${name}`, true);
          document.getElementById(field).focus();
          return;
        }
      }

      // Validate format
      if (
        !CONFIG.HEX_PATTERN.test(
          document.getElementById("checksumFirst").value,
        )
      ) {
        showGlobalMessage("Checksum First Format incorrect", true);
        return;
      }

      if (
        !CONFIG.HEX_PATTERN.test(
          document.getElementById("checksumSecond").value,
        )
      ) {
        showGlobalMessage("Checksum Second Format incorrect", true);
        return;
      }

      if (
        !CONFIG.HEX_PATTERN.test(document.getElementById("clientKey").value)
      ) {
        showGlobalMessage("Client KeyFormat incorrect", true);
        return;
      }

      if (
        !CONFIG.UUID_PATTERN.test(document.getElementById("sessionId").value)
      ) {
        showGlobalMessage("Session ID Format incorrect", true);
        return;
      }

      // Build request data
      const requestData = {
        token: document.getElementById("token").value,
        checksum: {
          first: document.getElementById("checksumFirst").value,
          second: document.getElementById("checksumSecond").value,
        },
        client_key: document.getElementById("clientKey").value,
        session_id: document.getElementById("sessionId").value,
        proxy_name: document.getElementById("proxyName").value || undefined,
        timezone: document.getElementById("timezone").value || undefined,
        gcpp_host: document.getElementById("gcppHost").value || undefined,
      };

      // Remove undefined values
      Object.keys(requestData).forEach((key) => {
        if (requestData[key] === undefined) {
          delete requestData[key];
        }
      });

      // Disablebutton
      const fetchButton = document.getElementById("fetchConfigVersionButton");
      fetchButton.disabled = true;
      fetchButton.textContent = "GetChinese...";

      try {
        const result = await makeApiRequest("/config-version", requestData);

        if (result && result.config_version) {
          document.getElementById("configVersion").value = result.config_version;
          showGlobalMessage("Config version retrieved successfully");

          // Disable button after successful retrieval
          fetchButton.disabled = true;
          fetchButton.textContent = "Retrieved";

          // Save form data
          saveFormData();
        } else if (result && result.error) {
          showGlobalMessage("Get failed: " + result.error, true);
          fetchButton.disabled = false;
          fetchButton.textContent = "Get";
        } else {
          showGlobalMessage("Unknown error", true);
          fetchButton.disabled = false;
          fetchButton.textContent = "Get";
        }
      } catch (error) {
        showGlobalMessage("Request failed: " + error.message, true);
        fetchButton.disabled = false;
        fetchButton.textContent = "Get";
      }
    }

    /**
     * Build Key
     */
    async function buildKey() {
      // Validate required fields
      const requiredFields = {
        token: "Token",
        checksumFirst: "Checksum First",
        checksumSecond: "Checksum Second",
        clientKey: "Client Key",
        configVersion: "Config Version",
        sessionId: "Session ID",
      };

      for (const [field, name] of Object.entries(requiredFields)) {
        const value = document.getElementById(field).value.trim();
        if (!value) {
          showGlobalMessage(`Please fill in${name}`, true);
          document.getElementById(field).focus();
          return;
        }
      }

      // Validate format
      if (
        !CONFIG.HEX_PATTERN.test(
          document.getElementById("checksumFirst").value,
        )
      ) {
        showGlobalMessage("Checksum First Format incorrect", true);
        return;
      }

      if (
        !CONFIG.HEX_PATTERN.test(
          document.getElementById("checksumSecond").value,
        )
      ) {
        showGlobalMessage("Checksum Second Format incorrect", true);
        return;
      }

      if (
        !CONFIG.HEX_PATTERN.test(document.getElementById("clientKey").value)
      ) {
        showGlobalMessage("Client KeyFormat incorrect", true);
        return;
      }

      if (
        !CONFIG.UUID_PATTERN.test(
          document.getElementById("configVersion").value,
        )
      ) {
        showGlobalMessage("Config VersionFormat incorrect", true);
        return;
      }

      if (
        !CONFIG.UUID_PATTERN.test(document.getElementById("sessionId").value)
      ) {
        showGlobalMessage("Session ID Format incorrect", true);
        return;
      }

      // Build request data
      const usageCheckType = document.getElementById("usageCheckType").value;
      let usageCheckModels = undefined;

      if (usageCheckType) {
        usageCheckModels = { type: usageCheckType };
        if (usageCheckType === "custom") {
          const modelIds = getSelectedModels().join(",");
          if (!modelIds) {
            showGlobalMessage("Please select at least one model", true);
            return;
          }
          usageCheckModels.model_ids = modelIds;
        }
      }

      const requestData = {
        token: document.getElementById("token").value,
        checksum: {
          first: document.getElementById("checksumFirst").value,
          second: document.getElementById("checksumSecond").value,
        },
        client_key: document.getElementById("clientKey").value,
        config_version: document.getElementById("configVersion").value,
        session_id: document.getElementById("sessionId").value,
        secret: document.getElementById("secret").value || undefined,
        proxy_name: document.getElementById("proxyName").value || undefined,
        timezone: document.getElementById("timezone").value || undefined,
        gcpp_host: document.getElementById("gcppHost").value || undefined,
        disable_vision: parseBooleanFromString(
          document.getElementById("disableVision").value,
          undefined,
        ),
        enable_slow_pool: parseBooleanFromString(
          document.getElementById("enableSlowPool").value,
          undefined,
        ),
        include_web_references: parseBooleanFromString(
          document.getElementById("includeWebReferences").value,
          undefined,
        ),
        usage_check_models: usageCheckModels,
      };

      // Remove undefined values
      Object.keys(requestData).forEach((key) => {
        if (requestData[key] === undefined) {
          delete requestData[key];
        }
      });

      // Disablebutton
      const buildButton = document.getElementById("buildButton");
      buildButton.disabled = true;
      buildButton.textContent = "Building...";

      try {
        const result = await makeApiRequest("/build-key", requestData);

        if (result && result.keys && result.keys.length > 0) {
          displayKeys(result.keys);
          showGlobalMessage("Key built successfully");

          // Save form data
          saveFormData();
        } else if (result && result.error) {
          showGlobalMessage("Build failed: " + result.error, true);
        } else {
          showGlobalMessage("Unknown error", true);
        }
      } catch (error) {
        showGlobalMessage("Request failed: " + error.message, true);
      } finally {
        buildButton.disabled = false;
        buildButton.textContent = "Build Key";
      }
    }

    /**
     * displayGenerated Keys
     */
    function displayKeys(keys) {
      const keyResult = document.getElementById("keyResult");
      const keyContent = document.getElementById("keyContent");

      const keyLabels = ["Full Key", "Base64 Encoded Key", "Numeric Key"];

      keyContent.innerHTML = keys
        .map(
          (key, index) => `
      <div class="key-item">
        <div class="key-label">${keyLabels[index] || `Key ${index + 1}`}</div>
        <div class="key-value" id="key-${index}">${key}</div>
        <button class="copy-button" onclick="copyKey('key-${index}', this)">Copy</button>
      </div>
    `,
        )
        .join("");

      keyResult.style.display = "block";

      // Scroll to result area
      keyResult.scrollIntoView({ behavior: "smooth", block: "nearest" });
    }

    /**
     * Copy Key
     */
    async function copyKey(keyId, button) {
      const keyElement = document.getElementById(keyId);
      const keyText = keyElement.textContent;

      // Use shared copy method
      await copyToClipboard(keyText, {
        successMessage: "Key copied to clipboard",
        errorMessage: "Copyfailed，please manuallyCopy",
        sourceElement: button,
        onSuccess: () => {
          // Button state handled by copyToClipboard
        },
      });
    }

    /**
     * Hide key result
     */
    function hideKeyResult() {
      document.getElementById("keyResult").style.display = "none";
    }

    /**
     * Clear Form
     */
    function clearForm() {
      // Clear all input fields
      const inputs = document.querySelectorAll("input, select");
      inputs.forEach((input) => {
        if (input.type === "checkbox") {
          input.checked = false;
        } else {
          input.value = "";
        }
        // Remove validation styles
        input.classList.remove("valid", "invalid");
      });

      // Reset get config version button state
      const fetchButton = document.getElementById("fetchConfigVersionButton");
      if (fetchButton) {
        fetchButton.disabled = false;
        fetchButton.textContent = "Get";
      }

      // Hide result area
      hideKeyResult();

      // Clear cache
      localStorage.removeItem(CONFIG.CACHE_KEY);

      showGlobalMessage("Form cleared");
    }

    /**
     * Initialize timezone selector
     */
    function initializeTimezoneSelector() {
      // Render all timezones on init
      renderTimezones();

      // Add global click event listener
      document.addEventListener("click", function (e) {
        const dropdown = document.getElementById("timezoneDropdown");
        const input = document.getElementById("timezone");

        if (!dropdown.contains(e.target) && e.target !== input) {
          dropdown.classList.remove("show");
        }
      });
    }

    /**
     * Render timezone list
     */
    function renderTimezones(filter = "") {
      const dropdown = document.getElementById("timezoneDropdown");
      const normalizedFilter = filter.toLowerCase();

      // Filter timezones
      const filteredTimezones = TIMEZONES.filter((tz) => {
        if (!filter) return true;

        // Check timezone name
        if (tz.name.toLowerCase().includes(normalizedFilter)) return true;

        // Check display name
        if (tz.display.toLowerCase().includes(normalizedFilter)) return true;

        // Check keywords
        return tz.keywords.some((keyword) =>
          keyword.toLowerCase().includes(normalizedFilter),
        );
      });

      // If no matches
      if (filteredTimezones.length === 0) {
        dropdown.innerHTML =
          '<div class="timezone-no-results">No matchingTimezone</div>';
        return;
      }

      // Render timezone list
      dropdown.innerHTML = filteredTimezones
        .map((tz) => {
          const currentValue = document.getElementById("timezone").value;
          const isSelected = currentValue === tz.name;

          return `
        <div class="timezone-item ${isSelected ? "selected" : ""}" 
              data-timezone="${tz.name}"
              onmousedown="selectTimezone('${tz.name}')">
          <div class="timezone-name">${tz.display} - ${tz.name}</div>
          <div class="timezone-offset">UTC${tz.offset}</div>
        </div>
      `;
        })
        .join("");
    }

    /**
     * Show timezone dropdown
     */
    function showTimezoneDropdown() {
      const dropdown = document.getElementById("timezoneDropdown");
      dropdown.classList.add("show");

      // If input is empty, show all timezones
      const input = document.getElementById("timezone");
      if (!input.value) {
        renderTimezones();
      }
    }

    /**
     * Hide timezone dropdown
     */
    function hideTimezoneDropdown(event) {
      // Use setTimeout to ensure execution after click event
      setTimeout(() => {
        if (!keepTimezoneDropdownOpen) {
          const dropdown = document.getElementById("timezoneDropdown");
          dropdown.classList.remove("show");
        }
        keepTimezoneDropdownOpen = false;
      }, 200);
    }

    /**
     * Filter timezones
     */
    function filterTimezones(value) {
      renderTimezones(value);
    }

    /**
     * Select timezone
     */
    function selectTimezone(timezone) {
      keepTimezoneDropdownOpen = true;
      const input = document.getElementById("timezone");
      input.value = timezone;

      // Trigger change event to save data
      input.dispatchEvent(new Event("change"));

      // Hide dropdown
      setTimeout(() => {
        const dropdown = document.getElementById("timezoneDropdown");
        dropdown.classList.remove("show");
      }, 100);

      // showGlobalMessage(`AlreadySelect timezone: ${timezone}`);
    }

    /**
     * Auto detect timezone (deprecated, kept for compatibility)
     */
    function detectTimezone() {
      try {
        // Try to get timezone using Intl API
        if (
          Intl &&
          Intl.DateTimeFormat &&
          Intl.DateTimeFormat().resolvedOptions
        ) {
          const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
          if (timezone) {
            // Find matching timezone
            const matchedTimezone = TIMEZONES.find(
              (tz) => tz.name === timezone,
            );
            if (matchedTimezone) {
              selectTimezone(timezone);
            } else {
              // If not in list, set directly
              document.getElementById("timezone").value = timezone;
              showGlobalMessage(`Timezone detected: ${timezone}`);
              saveFormData();
            }
            return;
          }
        }
      } catch (error) {
        console.error("Timezone detection failed:", error);
      }

      // If Intl API unavailable or failed, prompt user to input manually
      showGlobalMessage("Cannot auto detect timezone, please select from list", true);
      document.getElementById("timezone").focus();
    }

    // Initialize on page load
    document.addEventListener("DOMContentLoaded", () => {
      initializePage();
    });
  </script>
</body>

</html>