<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/x-icon" href="data:image/x-icon;," />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Token ä¿¡æ¯Management</title>
  <!-- Include shared styles -->
  <link rel="stylesheet" href="/static/shared-styles.css" />
  <script src="/static/shared.js"></script>
  <style>
    /* æ–‡ä»¶Systemå¸ƒå±€æ ·å¼ */
    .file-system {
      background: var(--card-background);
      border-radius: var(--border-radius);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      margin-top: var(--spacing);
      overflow: hidden;
      height: calc(100vh - 250px);
      display: flex;
      flex-direction: column;
    }

    .toolbar {
      display: flex;
      align-items: center;
      padding: 8px;
      border-bottom: 1px solid var(--border-color);
      background: var(--card-background);
    }

    .toolbar .search-box {
      flex: 1;
      margin-right: 8px;
      position: relative;
    }

    .toolbar .search-box input {
      width: 100%;
      padding-left: 32px;
    }

    .toolbar .search-box::before {
      content: "ğŸ”";
      position: absolute;
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--text-secondary);
    }

    .toolbar .view-toggles button {
      height: 36px;
      min-width: 36px;
    }

    .token-files {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      position: relative;
      user-select: none;
      padding: 0 12px 12px 12px;
    }

    .file-list {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0;
    }

    .file-list th {
      position: sticky;
      top: 0;
      z-index: 10;
      background: var(--card-background);
      padding: 10px;
      text-align: left;
      font-weight: 500;
      border-bottom: 1px solid var(--border-color);
      color: var(--text-primary);
    }

    .file-list th:hover {
      background: var(--disabled-bg);
    }

    .file-list td {
      padding: 8px 10px;
      border-bottom: 1px solid var(--border-color);
      color: var(--text-primary);
    }

    .file-list tr {
      cursor: pointer;
    }

    .file-list tr:hover {
      background: var(--primary-color-alpha);
    }

    .file-list tr.selected {
      background: var(--primary-color-alpha);
    }

    .file-list tr.focused {
      background: var(--primary-color);
      color: white;
    }

    .file-list tr.focused td {
      color: white;
    }

    .file-icon {
      display: inline-block;
      width: 20px;
      height: 20px;
      margin-right: 8px;
      vertical-align: middle;
    }

    .status-bar {
      padding: 8px;
      background: var(--card-background);
      border-top: 1px solid var(--border-color);
      color: var(--text-secondary);
      font-size: 14px;
      display: flex;
      justify-content: space-between;
    }

    /* å³é”®èœå• */
    .context-menu {
      position: fixed;
      background: var(--card-background);
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      padding: 4px 0;
      z-index: 1000;
      min-width: 180px;
      display: none;
    }

    .context-menu-item {
      padding: 8px 16px;
      cursor: pointer;
      transition: all var(--transition-fast);
      display: flex;
      align-items: center;
      position: relative;
    }

    .context-menu-item:hover {
      background: var(--primary-color-alpha);
    }

    .context-menu-divider {
      height: 1px;
      background: var(--border-color);
      margin: 4px 0;
    }

    .context-menu-shortcut {
      margin-left: auto;
      color: var(--text-secondary);
      font-size: 12px;
    }

    /* Selectæ¡† */
    .selection-box {
      position: absolute;
      border: 1px dashed var(--primary-color);
      background: rgba(33, 150, 243, 0.1);
      z-index: 5;
      pointer-events: none;
    }

    /* Detailsé¢æ¿ */
    .details-panel {
      position: fixed;
      right: 0;
      top: 0;
      bottom: 0;
      width: 500px;
      background: var(--card-background);
      border-left: 1px solid var(--border-color);
      box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
      padding: 16px;
      overflow-y: auto;
      z-index: 100;
      transform: translateX(100%);
      transition: transform 0.3s ease;
    }

    .details-panel.open {
      transform: translateX(0);
    }

    .details-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border-color);
    }

    .details-header h3 {
      margin: 0;
    }

    .details-header button {
      background: transparent;
      border: none;
      cursor: pointer;
      font-size: 20px;
      color: var(--text-secondary);
    }

    .details-content {
      margin-bottom: 16px;
    }

    .details-property {
      margin-bottom: 12px;
    }

    .details-property-name {
      font-weight: 500;
      color: var(--text-secondary);
      margin-bottom: 4px;
    }

    .details-property-value {
      color: var(--text-primary);
      word-break: break-all;
    }

    .details-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .details-actions button {
      flex: 1;
      min-width: 120px;
    }

    /* å¼¹å‡ºå¯¹è¯æ¡†æ ·å¼ */
    .modal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--card-background);
      padding: 20px;
      border-radius: var(--border-radius);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      z-index: 1000;
      width: 90%;
      max-width: 500px;
      color: var(--text-primary);
      height: 80vh;
      overflow-y: auto;
    }

    .modal-backdrop {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 999;
    }

    .modal-header {
      margin-bottom: 15px;
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-header h3 {
      margin: 0;
      color: var(--text-primary);
    }

    .modal-close {
      background: transparent;
      border: none;
      color: var(--text-secondary);
      font-size: 20px;
      cursor: pointer;
    }

    .modal-body {
      margin-bottom: 15px;
    }

    .modal-footer {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--border-color);
      text-align: right;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    /* Filteré¢æ¿ */
    .filter-panel {
      padding: 16px;
      background: var(--card-background);
      border-radius: var(--border-radius);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      margin-top: var(--spacing);
    }

    .filter-row {
      display: flex;
      gap: 12px;
      margin-bottom: 14px;
      flex-wrap: wrap;
    }

    .filter-group {
      flex: 1;
      min-width: 220px;
      position: relative;
    }

    .filter-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .filter-group select {
      width: 100%;
      min-height: 38px;
    }

    .filter-input-group {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .filter-input-group input {
      flex: 1;
      min-width: 0;
      min-height: 38px;
    }

    .filter-input-group span {
      color: var(--text-secondary);
      font-size: 14px;
    }

    .filter-actions {
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 16px;
      align-items: flex-end;
    }

    .filter-actions-left {
      flex: 1;
      min-width: 220px;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .filter-actions-right {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      min-height: 40px;
    }

    /* Responseå¼è°ƒæ•´ */
    @media (max-width: 1200px) {
      .filter-actions {
        flex-direction: column;
        align-items: stretch;
      }

      .filter-actions-left {
        margin-bottom: 12px;
      }

      .filter-actions-right {
        justify-content: flex-end;
      }
    }

    @media (max-width: 768px) {
      .filter-actions-right {
        justify-content: flex-start;
      }

      .button-group button {
        flex: 1;
        min-width: 0;
      }

      #detailsPanel {
        width: 100%;
      }
    }

    /* æ‰˜ç›˜æ¶ˆæ¯ */
    .toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 1000;
      max-width: 350px;
      max-height: 80vh;
      overflow-y: hidden;
      padding-top: 10px;
      padding-bottom: 10px;
      padding-right: 5px;
    }

    .toast {
      background: var(--card-background);
      color: var(--text-primary);
      padding: 10px 16px;
      border-radius: var(--border-radius);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      opacity: 0;
      transform: translateY(20px);
      transition:
        opacity 0.4s cubic-bezier(0.25, 0.8, 0.25, 1),
        transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
      position: relative;
      min-width: 200px;
      margin-left: auto;
      will-change: transform, opacity;
      pointer-events: auto;
    }

    .toast.info {
      border-left: 4px solid #2196f3;
    }

    .toast.error {
      background: #f44336;
      color: white;
    }

    .toast.success {
      background: #4caf50;
      color: white;
    }

    .toast.warning {
      background: #ff9800;
      color: white;
    }

    .toast.show {
      opacity: 1;
      transform: translateY(0);
    }

    /* å¤„ç†çºµå‘æ»šåŠ¨ */
    @media (max-height: 600px) {
      .file-system {
        height: 400px;
      }
    }

    .key-result {
      background: var(--card-background);
      padding: var(--spacing);
      border-radius: var(--border-radius);
      border: 1px solid var(--border-color);
      margin-top: var(--spacing);
      position: relative;
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .key-result:hover {
      background: var(--primary-color-alpha);
      border-color: var(--primary-color);
    }

    .key-result:active {
      transform: translateY(1px);
    }

    .key-content {
      overflow-x: auto;
      white-space: nowrap;
      scrollbar-width: thin;
      -ms-overflow-style: none;
    }

    /* æ‰¹é‡ActionsåŒºåŸŸ */
    .batch-operations {
      background: var(--card-background);
      border-radius: var(--border-radius);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      margin-top: var(--spacing);
      padding: var(--spacing);
      display: none;
    }

    .batch-operations .form-group {
      margin-bottom: 12px;
    }

    .button-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
      align-items: flex-end;
      margin: 0;
    }

    .button-group button {
      height: 38px;
      min-width: 100px;
      white-space: nowrap;
    }

    .button-group button .context-menu-shortcut {
      margin-left: 5px;
      opacity: 0.7;
      font-size: 12px;
    }

    /* Proxyå­èœå•æ ·å¼ */
    .proxy-menu {
      position: relative;
    }

    .proxy-submenu {
      position: absolute;
      left: 100%;
      top: 0;
      background: var(--card-background);
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      padding: 4px 0;
      min-width: 180px;
      z-index: 1001;
      opacity: 0;
      visibility: hidden;
      transition:
        opacity 0.2s,
        visibility 0.2s;
    }

    .proxy-menu:hover>.proxy-submenu {
      opacity: 1;
      visibility: visible;
    }

    .context-menu-item.has-submenu::after {
      content: "â€º";
      position: absolute;
      right: 8px;
      font-size: 18px;
    }

    .check-mark {
      margin-left: auto;
      visibility: hidden;
    }

    .check-mark::after {
      content: "âœ“";
    }

    .context-menu-item.active .check-mark {
      visibility: visible;
    }

    .context-menu-item.active span:first-child {
      font-weight: bold;
    }

    .proxy-count {
      color: var(--text-secondary);
      font-size: 12px;
      margin-left: 8px;
    }

    /* å‘ä¸ŠExpandçš„å­èœå•æ ·å¼ */
    .proxy-menu.open-upward .proxy-submenu {
      top: auto;
      bottom: 0;
    }

    /* å‘å·¦Expandçš„å­èœå•æ ·å¼ */
    .proxy-menu.open-leftward .proxy-submenu {
      right: 100%;
      left: auto;
    }

    /* TimezoneNameå’ŒProxyNameTotaläº«æ ·å¼ */
    .timezone-name,
    .proxy-name {
      cursor: pointer;
      padding: 3px 8px;
      border-radius: 4px;
      transition: all 0.2s ease;
      display: inline-flex;
      align-items: center;
      border: 1px solid transparent;
      background-color: var(--disabled-bg);
      font-size: 0.9em;
      position: relative;
    }

    .timezone-name:hover,
    .proxy-name:hover {
      background-color: var(--primary-color-alpha);
      color: var(--primary-color);
      border-color: var(--primary-color);
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .timezone-name:active,
    .proxy-name:active {
      transform: translateY(0px);
      box-shadow: none;
    }

    .timezone-name:hover::after,
    .proxy-name:hover::after {
      opacity: 1;
    }

    /* StatusæŒ‡ç¤ºæ ‡æ ·å¼ */
    .status-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 5px;
    }

    .status-enabled {
      background-color: #4caf50;
      /* ç»¿è‰² */
    }

    .status-disabled {
      background-color: #f44336;
      /* çº¢è‰² */
    }

    .status-other {
      background-color: #ffc107;
      /* é»„è‰² */
    }

    /* Statuså­èœå•æ ·å¼ */
    .status-menu {
      position: relative;
    }

    .status-submenu {
      position: absolute;
      left: 100%;
      top: 0;
      background: var(--card-background);
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      padding: 4px 0;
      min-width: 150px;
      z-index: 1001;
      opacity: 0;
      visibility: hidden;
      transition:
        opacity 0.2s,
        visibility 0.2s;
    }

    .status-menu:hover .status-submenu {
      opacity: 1;
      visibility: visible;
    }

    /* Addå‘ä¸Šå’Œå‘å·¦æ‰“å¼€çš„æ ·å¼ */
    .status-menu.open-upward .status-submenu {
      top: auto;
      bottom: 0;
    }

    .status-menu.open-leftward .status-submenu {
      left: auto;
      right: 100%;
    }

    /* AddStatusè®¡æ•°æ ·å¼ */
    .status-count {
      color: var(--text-secondary);
      font-size: 12px;
      margin-left: 8px;
    }

    /* CopySuccessæ—¶çš„è§†è§‰åé¦ˆ */
    .copied {
      position: relative;
      animation: copySuccess 0.3s ease-in-out;
    }

    @keyframes copySuccess {
      0% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.05);
        background-color: var(--primary-color-alpha);
      }

      100% {
        transform: scale(1);
      }
    }

    /* å†…è”Editè¾“å…¥æ¡†æ ·å¼ */
    .inline-edit {
      background: transparent;
      border: 1px solid var(--primary-color);
      border-radius: 3px;
      padding: 2px 6px;
      font-size: inherit;
      font-family: inherit;
      color: inherit;
      width: 100%;
      min-width: 150px;
      outline: none;
    }

    .inline-edit:focus {
      background: var(--card-background);
      box-shadow: 0 0 0 2px var(--primary-color-alpha);
    }
  </style>
</head>

<body>
  <h1>Token ä¿¡æ¯Management</h1>

  <div class="container">
    <div class="form-group">
      <label>Authentication Token:</label>
      <input type="password" id="authToken" placeholder="Enter AUTH_TOKEN" />
    </div>
  </div>

  <!-- Filteré¢æ¿ -->
  <div class="filter-panel">
    <div class="filter-row">
      <div class="filter-group">
        <label>è´¦æˆ·Type:</label>
        <select id="membershipFilter">
          <option value="all">AllType</option>
          <option value="free">Free</option>
          <option value="free_trial">Trial</option>
          <option value="pro">Pro</option>
          <option value="pro_plus">Pro Plus</option>
          <option value="ultra">Ultra</option>
          <option value="enterprise">Enterprise</option>
        </select>
      </div>
      <div class="filter-group">
        <label>TimezoneFilter:</label>
        <select id="timezoneFilter">
          <option value="all">AllTimezone</option>
          <option value="none">Unspecified Timezone</option>
          <!-- Timezoneåˆ—è¡¨å°†åœ¨JavaScriptä¸­åŠ¨æ€å¡«å…… -->
        </select>
      </div>
      <div class="filter-group">
        <label>UsageStatus:</label>
        <div class="filter-input-group">
          <input type="number" id="usageMin" placeholder="Minå€¼" />
          <span>è‡³</span>
          <input type="number" id="usageMax" placeholder="Maxå€¼" />
        </div>
      </div>
      <div class="filter-group">
        <label>Trial Remaining:</label>
        <div class="filter-input-group">
          <input type="number" id="trialMin" placeholder="Mindaysæ•°" />
          <span>è‡³</span>
          <input type="number" id="trialMax" placeholder="Maxdaysæ•°" />
        </div>
      </div>
    </div>

    <div class="filter-actions">
      <div class="filter-actions-left">
        <div class="filter-group">
          <label>ProfileStatus:</label>
          <select id="profileFilter">
            <option value="all">AllStatus</option>
            <option value="has_profile">Has Profile</option>
            <option value="no_profile">NoneProfile</option>
          </select>
        </div>
        <div class="filter-group">
          <label>ProxyFilter:</label>
          <select id="proxyFilter">
            <option value="all">AllProxy</option>
            <option value="none">Unspecified Proxy</option>
            <!-- Proxyåˆ—è¡¨å°†åœ¨JavaScriptä¸­åŠ¨æ€å¡«å…… -->
          </select>
        </div>
      </div>
      <div class="filter-actions-right">
        <button id="refreshBtn" onclick="getTokenInfo()" class="primary">
          <span>Refresh List</span>
          <span class="context-menu-shortcut">F5</span>
        </button>
        <button id="addTokenBtn" onclick="addTokens()" class="secondary">
          AddToken
        </button>
        <button id="exportBtn" onclick="exportTokens()" class="secondary">
          Exportåˆ—è¡¨
        </button>
        <button id="importBtn" onclick="importTokens()" class="secondary">
          Importåˆ—è¡¨
        </button>
      </div>
    </div>
  </div>

  <!-- æ–‡ä»¶SystemåŒºåŸŸ -->
  <div class="file-system">
    <div class="toolbar">
      <div class="search-box">
        <input type="text" id="searchInput" placeholder="SearchTokenæˆ–è´¦æˆ·..." />
      </div>
    </div>

    <div class="token-files">
      <table class="file-list">
        <thead>
          <tr>
            <th>Token</th>
            <th style="width: 15%">ä¼šå‘˜Type</th>
            <th style="width: 15%">Usage</th>
            <th style="width: 10%">Trial Remaining</th>
            <th style="width: 10%">Timezone</th>
            <th style="width: 10%">Proxy</th>
          </tr>
        </thead>
        <tbody id="fileListBody">
          <!-- åŠ¨æ€ç”Ÿæˆçš„æ–‡ä»¶åˆ—è¡¨ -->
        </tbody>
      </table>
      <div id="emptyState" style="
          display: none;
          padding: 40px;
          text-align: center;
          color: var(--text-secondary);
        ">
        <div style="font-size: 48px; margin-bottom: 16px">ğŸ“</div>
        <h3>No Token Found</h3>
        <p>è¯·AddTokenæˆ–æ›´æ”¹Filterrecordsä»¶</p>
        <button onclick="addTokens()" class="primary">AddToken</button>
      </div>
      <!-- Selectæ¡† -->
      <div id="selectionBox" class="selection-box"></div>
    </div>

    <div class="status-bar">
      <div id="selectionStatus">å·²Select: 0 itemsç›®</div>
      <div id="totalCount">Total 0 Token</div>
    </div>
  </div>

  <!-- å³é”®èœå• -->
  <div id="contextMenu" class="context-menu">
    <div class="context-menu-item status-menu">
      <span>åˆ‡æ¢Status</span>
      <div class="status-submenu" id="statusSubmenu">
        <div class="context-menu-item" onclick="setTokenStatus('enabled')">
          <span>Enable</span>
          <span class="status-count">0</span>
          <span class="check-mark"></span>
        </div>
        <div class="context-menu-item" onclick="setTokenStatus('disabled')">
          <span>Disable</span>
          <span class="status-count">0</span>
          <span class="check-mark"></span>
        </div>
      </div>
    </div>
    <div class="context-menu-item" onclick="viewDetails()">
      <span>ViewDetails</span>
      <span class="context-menu-shortcut">Enter</span>
    </div>
    <div class="context-menu-item" onclick="renameToken()">
      <span>Rename</span>
      <span class="context-menu-shortcut">F2</span>
    </div>
    <div class="context-menu-item" onclick="refreshSelectedProfiles()">
      <span>RefreshProfile</span>
      <span class="context-menu-shortcut">F5</span>
    </div>
    <div class="context-menu-item" onclick="upgradeSelectedTokens()">
      <span>RefreshToken</span>
      <span class="context-menu-shortcut">Ctrl+U</span>
    </div>
    <div class="context-menu-item" onclick="refreshSelectedConfigVersions()">
      <span>RefreshConfig Version</span>
      <span class="context-menu-shortcut">F6</span>
    </div>
    <div class="context-menu-item" onclick="generateKey()">
      <span>Generate Key</span>
      <span class="context-menu-shortcut">Ctrl+G</span>
    </div>
    <div class="context-menu-item" onclick="copyTokenToClipboard()">
      <span>CopyToken</span>
      <span class="context-menu-shortcut">Ctrl+C</span>
    </div>
    <div class="context-menu-item" onclick="openTimezoneSelector()">
      <span>SettingsTimezone</span>
    </div>
    <div class="context-menu-item proxy-menu">
      <span>SettingsProxy</span>
      <div class="proxy-submenu" id="proxySubmenu">
        <div class="context-menu-item" onclick="setProxy('')">
          <span>Unspecified</span>
          <span class="proxy-count">0</span>
          <span class="check-mark"></span>
        </div>
        <div class="context-menu-divider"></div>
        <!-- Proxyåˆ—è¡¨å°†åŠ¨æ€Addåœ¨è¿™é‡Œ -->
      </div>
    </div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" onclick="deleteSelectedTokens()">
      <span>Delete</span>
      <span class="context-menu-shortcut">Delete</span>
    </div>
  </div>

  <!-- Detailsé¢æ¿ -->
  <div id="detailsPanel" class="details-panel">
    <div class="details-header">
      <h3 id="detailsTitle">TokenDetails</h3>
      <button onclick="toggleDetailsPanel(false)" style="width: unset">
        Ã—
      </button>
    </div>
    <div id="detailsContent" class="details-content">
      <!-- Detailså†…å®¹å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
    </div>
    <div class="details-actions">
      <button onclick="refreshSelectedProfiles()" class="secondary">
        RefreshProfile
      </button>
      <button onclick="refreshSelectedConfigVersions()" class="secondary">
        RefreshConfig Version
      </button>
      <button onclick="generateKey()" class="secondary">Generate Key</button>
      <button onclick="deleteSelectedTokens()" class="danger">Delete</button>
    </div>
  </div>

  <!-- Generate Keyå¯¹è¯æ¡† -->
  <div class="modal-backdrop" id="keyModal-backdrop"></div>
  <div class="modal" id="keyModal">
    <div class="modal-header">
      <h3>Generate Dynamic Key</h3>
      <button class="modal-close" onclick="closeModal('keyModal')">Ã—</button>
    </div>
    <div class="modal-body">
      <div class="form-group">
        <label>Token:</label>
        <div id="keyToken" style="
            word-break: break-all;
            background: var(--disabled-bg);
            padding: 8px;
            border-radius: var(--border-radius);
            margin-bottom: 10px;
          "></div>
      </div>
      <div class="form-group">
        <label>Vision Capability:</label>
        <select id="disableVision">
          <option value="">Follow Global</option>
          <option value="true">Disable</option>
          <option value="false">Enable</option>
        </select>
      </div>
      <div class="form-group">
        <label>Slow Pool:</label>
        <select id="enableSlowPool">
          <option value="">Follow Global</option>
          <option value="true">Enable</option>
          <option value="false">Disable</option>
        </select>
      </div>
      <div class="form-group">
        <label>ä½¿Usageæ£€æŸ¥æ¨¡å‹è§„åˆ™:</label>
        <select id="usageCheckType" onchange="toggleModelList()">
          <option value="">Follow Global</option>
          <option value="default">Default</option>
          <option value="disabled">Disable</option>
          <option value="all">æ‰€æœ‰</option>
          <option value="custom">Custom</option>
        </select>
        <div id="modelListContainer" class="model-list" style="
            display: none;
            max-height: 150px;
            overflow-y: auto;
            margin-top: 8px;
          ">
          <!-- åŠ¨æ€å¡«å……æ¨¡å‹åˆ—è¡¨ -->
        </div>
      </div>
      <div class="form-group">
        <label>ProxyServiceå™¨:</label>
        <select id="proxySelect">
          <option value="">è·ŸéšTokenSettings</option>
          <!-- Proxyé€‰itemså°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
        </select>
      </div>
      <div class="form-group">
        <label>Include Web References:</label>
        <select id="includeWebReferences">
          <option value="">Follow Global</option>
          <option value="true">Enable</option>
          <option value="false">Disable</option>
        </select>
      </div>
      <div class="key-result" id="keyResult" style="display: none" onclick="copyGeneratedKey()">
        <div class="key-content" id="keyContent"></div>
      </div>
    </div>
    <div class="modal-footer">
      <button onclick="closeModal('keyModal')" class="secondary">Cancel</button>
      <button onclick="generateKeySubmit()" class="primary">ç”Ÿæˆ</button>
    </div>
  </div>

  <!-- ConfirmDeleteå¯¹è¯æ¡† -->
  <div class="modal-backdrop" id="confirmModal-backdrop"></div>
  <div class="modal" id="confirmModal">
    <div class="modal-header">
      <h3>ConfirmDelete</h3>
      <button class="modal-close" onclick="closeModal('confirmModal')">
        Ã—
      </button>
    </div>
    <div class="modal-body">
      <p id="confirmMessage">OKè¦Deleteé€‰ä¸­çš„Tokenå—ï¼Ÿ</p>
    </div>
    <div class="modal-footer">
      <button onclick="closeModal('confirmModal')" class="secondary">
        Cancel
      </button>
      <button onclick="confirmDeleteTokens()" class="danger">Delete</button>
    </div>
  </div>

  <!-- æ‰¹é‡Addå¯¹è¯æ¡† -->
  <div class="modal-backdrop" id="addTokensModal-backdrop"></div>
  <div class="modal" id="addTokensModal">
    <div class="modal-header">
      <h3>æ‰¹é‡AddToken</h3>
      <button class="modal-close" onclick="closeModal('addTokensModal')">
        Ã—
      </button>
    </div>
    <div class="modal-body">
      <div class="form-group">
        <label>AddToken:</label>
        <textarea id="addTokensInput" placeholder="æ¯è¡Œè¾“å…¥ä¸€tokenï¼Œæ ¼å¼ä¸ºtokenæˆ–token,checksum" rows="8"></textarea>
      </div>
      <div class="form-group">
        <label>TokenStatus:</label>
        <select id="addTokensStatus">
          <option value="enabled">Enable</option>
          <option value="disabled">Disable</option>
        </select>
      </div>
    </div>
    <div class="modal-footer">
      <button onclick="closeModal('addTokensModal')" class="secondary">
        Cancel
      </button>
      <button onclick="confirmAddTokens()" class="primary">Add</button>
    </div>
  </div>

  <!-- ImportExportå¯¹è¯æ¡† -->
  <div class="modal-backdrop" id="importModal-backdrop"></div>
  <div class="modal" id="importModal">
    <div class="modal-header">
      <h3>ImportTokenåˆ—è¡¨</h3>
      <button class="modal-close" onclick="closeModal('importModal')">
        Ã—
      </button>
    </div>
    <div class="modal-body">
      <div class="form-group">
        <label>SelectJSONæ–‡ä»¶:</label>
        <input type="file" id="importFile" accept=".json" />
      </div>
    </div>
    <div class="modal-footer">
      <button onclick="closeModal('importModal')" class="secondary">
        Cancel
      </button>
      <button onclick="confirmImport()" class="primary">Import</button>
    </div>
  </div>

  <!-- ProxySelectå¯¹è¯æ¡† -->
  <div class="modal-backdrop" id="proxySelectModal-backdrop"></div>
  <div class="modal" id="proxySelectModal">
    <div class="modal-header">
      <h3>SelectProxy</h3>
      <button class="modal-close" onclick="closeModal('proxySelectModal')">
        Ã—
      </button>
    </div>
    <div class="modal-body">
      <div class="form-group">
        <label>Token:</label>
        <div id="currentTokenDisplay" style="
            word-break: break-all;
            background: var(--disabled-bg);
            padding: 8px;
            border-radius: var(--border-radius);
            margin-bottom: 10px;
          "></div>
      </div>
      <div class="form-group">
        <label>Proxyåˆ—è¡¨:</label>
        <select id="proxySelectDropdown" style="width: 100%">
          <option value="">Unspecified</option>
          <!-- Proxyåˆ—è¡¨å°†åŠ¨æ€Add -->
        </select>
      </div>
    </div>
    <div class="modal-footer">
      <button onclick="closeModal('proxySelectModal')" class="secondary">
        Cancel
      </button>
      <button onclick="saveProxySelection()" class="primary">Save</button>
    </div>
  </div>

  <!-- å…¨å±€é€šçŸ¥åŒºåŸŸ -->
  <div id="toast-container" class="toast-container"></div>

  <!-- TimezoneSelectå¯¹è¯æ¡† -->
  <div class="modal-backdrop" id="timezoneModal-backdrop"></div>
  <div class="modal" id="timezoneModal">
    <div class="modal-header">
      <h3>SettingsTimezone</h3>
      <button class="modal-close" onclick="closeModal('timezoneModal')">
        Ã—
      </button>
    </div>
    <div class="modal-body">
      <div class="form-group">
        <label>Token:</label>
        <div id="timezoneTokenDisplay" style="
            word-break: break-all;
            background: var(--disabled-bg);
            padding: 8px;
            border-radius: var(--border-radius);
            margin-bottom: 10px;
          "></div>
      </div>
      <div class="form-group">
        <label>SearchTimezone:</label>
        <input type="text" id="timezoneSearchInput" placeholder="è¾“å…¥å…³é”®è¯SearchTimezone..." style="width: 100%" />
      </div>
      <div class="form-group">
        <label>Timezoneåˆ—è¡¨:</label>
        <div id="timezoneListContainer" style="
            max-height: 300px;
            overflow-y: auto;
            margin-top: 8px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
          ">
          <!-- Timezoneåˆ—è¡¨å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
        </div>
      </div>
    </div>
    <div class="modal-footer">
      <button onclick="closeModal('timezoneModal')" class="secondary">
        Cancel
      </button>
      <button onclick="saveTimezoneSelection()" class="primary">Save</button>
    </div>
  </div>

  <script>
    // å…¨å±€å˜é‡
    let allTokens = [];
    let globalTags = [];
    let selectedTag = "all";
    let currentToken = "";
    let currentChecksum = "";
    let tokenToDelete = null;
    let tokenToEditTags = null;
    let availableModels = [];
    let selectedTokens = new Set(); // å­˜å‚¨é€‰ä¸­çš„Token
    let lastSelectedIndex = -1;
    let isMouseDown = false;
    let startPoint = { x: 0, y: 0 };
    let selectionBox = document.getElementById("selectionBox");
    let detailsPanelOpen = false;
    let tokensToDelete = [];
    // Proxyç›¸å…³å…¨å±€å˜é‡
    let proxyList = []; // ç¼“å­˜Proxyåˆ—è¡¨
    let currentProxy = ""; // å½“å‰ä½¿ç”¨çš„é€šç”¨Proxy
    // å½“å‰æ­£åœ¨EditProxyçš„token
    let currentEditingToken = "";

    // åˆå§‹åŒ–TokenHandling
    initializeTokenHandling("authToken");

    // æ£€æµ‹YesMacè¿˜Yeså…¶ä»–Systemï¼ŒMacä½¿ç”¨metaKey(Commandé”®)ï¼Œå…¶ä»–Systemä½¿ç”¨ctrlKey
    function isModifierKey(e) {
      const isMac = navigator.platform.toUpperCase().indexOf("MAC") >= 0;
      return isMac ? e.metaKey : e.ctrlKey;
    }

    // åˆå§‹åŒ–
    document.addEventListener("DOMContentLoaded", async () => {
      // è·å–æ¨¡å‹å’ŒTokenä¿¡æ¯
      getModels();
      // è·å–Proxyåˆ—è¡¨
      await getProxies();
      getTokenInfo();

      // ç›‘å¬Searchè¾“å…¥
      document
        .getElementById("searchInput")
        .addEventListener("input", filterTokens);

      // ç›‘å¬Filterä¸‹æ‹‰æ¡†
      document
        .getElementById("membershipFilter")
        .addEventListener("change", filterTokens);
      document
        .getElementById("usageMin")
        .addEventListener("change", filterTokens);
      document
        .getElementById("usageMax")
        .addEventListener("change", filterTokens);
      document
        .getElementById("trialMin")
        .addEventListener("change", filterTokens);
      document
        .getElementById("trialMax")
        .addEventListener("change", filterTokens);
      document
        .getElementById("profileFilter")
        .addEventListener("change", filterTokens);
      document
        .getElementById("proxyFilter")
        .addEventListener("change", filterTokens);
      document
        .getElementById("timezoneFilter")
        .addEventListener("change", filterTokens); // TimezoneFilterç›‘å¬

      // Settingsé”®ç›˜å¿«æ·é”®
      setupKeyboardShortcuts();

      // Settingsé¼ æ ‡Select
      setupMouseSelection();

      // Settingsæ–‡ä»¶Systemçš„ä¸Šä¸‹æ–‡èœå•
      setupContextMenu();

      updateStatusBar();

      // å¿«æ·é”®æ”¯æŒ
      document.addEventListener("keydown", function (e) {
        const modifierKey = isModifierKey(e);
        if (modifierKey && e.key === "Enter") {
          e.preventDefault();
          const activeElement = document.activeElement;
          if (
            activeElement.id === "tokenInput" ||
            activeElement.id === "batchTokenInput"
          ) {
            // æ ¹æ®å½“å‰ç„¦ç‚¹OKActions
            const action =
              document.querySelector(".button-group button.active") ||
              document.querySelector(".batch-actions button");
            if (action) {
              action.click();
            }
          }
        } else if (modifierKey && e.key === "a") {
          if (
            document.activeElement.tagName !== "INPUT" &&
            document.activeElement.tagName !== "TEXTAREA"
          ) {
            e.preventDefault();
            selectAllTokens();
          }
        }
      });
    });

    // Settingsé”®ç›˜å¿«æ·é”®
    function setupKeyboardShortcuts() {
      document.addEventListener("keydown", function (e) {
        const modifierKey = isModifierKey(e);

        if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") {
          // ä½†å…è®¸Ctrl/Command+Enteræ‰§è¡Œæäº¤Actions
          if (
            modifierKey &&
            e.key === "Enter" &&
            e.target.id === "tokenInput"
          ) {
            addTokens();
          }
          return;
        }

        // æ–‡ä»¶SystemActionså¿«æ·é”®
        switch (e.key) {
          case "a":
            if (modifierKey) {
              e.preventDefault();
              selectAllTokens();
            }
            break;
          case "c":
            if (modifierKey && !detailsPanelOpen) {
              e.preventDefault();
              copyTokenToClipboard();
            }
            break;
          case "Delete":
            e.preventDefault();
            deleteSelectedTokens();
            break;
          case "Enter":
            e.preventDefault();
            viewDetails();
            break;
          case "F5":
            e.preventDefault();
            if (selectedTokens.size > 0) {
              refreshSelectedProfiles();
            } else {
              getTokenInfo();
            }
            break;
          case "F6":
            e.preventDefault();
            if (selectedTokens.size > 0) {
              refreshSelectedConfigVersions();
            }
            break;
          case "u":
            if (modifierKey) {
              e.preventDefault();
              upgradeSelectedTokens();
            }
            break;
          case "g":
            if (modifierKey) {
              e.preventDefault();
              generateKey();
            }
            break;
          case "f":
            if (modifierKey) {
              e.preventDefault();
              document.getElementById("searchInput").focus();
            }
            break;
          case "F2":
            e.preventDefault();
            if (selectedTokens.size === 1) {
              startRenaming([...selectedTokens][0]);
            } else if (selectedTokens.size > 1) {
              showToast("ä¸€æ¬¡åªèƒ½Renameä¸€Token", "info");
            } else {
              showToast("è¯·å…ˆSelectè¦Renameçš„Token", "info");
            }
            break;
          case "Escape":
            closeAllModals();
            if (detailsPanelOpen) {
              toggleDetailsPanel(false);
            }
            break;
        }
      });
    }

    // Settingsé¼ æ ‡Select
    function setupMouseSelection() {
      const tokenFiles = document.querySelector(".token-files");

      // é¼ æ ‡æŒ‰ä¸‹StartSelect
      tokenFiles.addEventListener("mousedown", function (e) {
        // ä»…åœ¨å·¦é”®ç‚¹å‡»ä¸”ä¸Yesç‚¹å‡»åœ¨è¡¨æ ¼è¡Œä¸Šæ—¶Enableæ¡†é€‰
        if (
          e.button !== 0 ||
          e.target.closest("tr") ||
          e.target.closest("button")
        ) {
          return;
        }

        isMouseDown = true;

        const rect = tokenFiles.getBoundingClientRect();
        startPoint = {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top,
        };

        selectionBox.style.left = startPoint.x + "px";
        selectionBox.style.top = startPoint.y + "px";
        selectionBox.style.width = "0px";
        selectionBox.style.height = "0px";
        selectionBox.style.display = "block";

        // æ¸…é™¤ç°æœ‰Selectï¼Œé™¤éæŒ‰ä½Ctrlé”®
        if (!isModifierKey(e)) {
          clearSelection();
        }

        e.preventDefault();
      });

      // é¼ æ ‡ç§»åŠ¨UpdateSelectæ¡†
      document.addEventListener("mousemove", function (e) {
        if (!isMouseDown) return;

        const rect = tokenFiles.getBoundingClientRect();
        const currentPoint = {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top,
        };

        const width = Math.abs(currentPoint.x - startPoint.x);
        const height = Math.abs(currentPoint.y - startPoint.y);

        const left = Math.min(currentPoint.x, startPoint.x);
        const top = Math.min(currentPoint.y, startPoint.y);

        selectionBox.style.left = left + "px";
        selectionBox.style.top = top + "px";
        selectionBox.style.width = width + "px";
        selectionBox.style.height = height + "px";

        // æ£€æµ‹ä¸è¡Œçš„ç›¸äº¤å¹¶UpdateSelect
        const boxRect = selectionBox.getBoundingClientRect();
        const rows = document.querySelectorAll("#fileListBody tr");

        rows.forEach((row) => {
          const rowRect = row.getBoundingClientRect();
          const token = row.dataset.token;

          // æ£€æŸ¥YesNoç›¸äº¤
          if (
            rowRect.top < boxRect.bottom &&
            rowRect.bottom > boxRect.top &&
            rowRect.left < boxRect.right &&
            rowRect.right > boxRect.left
          ) {
            selectToken(token, true);
          } else if (!isModifierKey(e)) {
            deselectToken(token);
          }
        });

        updateSelectionStatus();
      });

      // é¼ æ ‡é‡Šæ”¾EndSelect
      document.addEventListener("mouseup", function () {
        if (isMouseDown) {
          isMouseDown = false;
          selectionBox.style.display = "none";
          updateSelectionStatus();
        }
      });

      // é˜²æ­¢æ‹–åŠ¨Selectæ—¶é€‰ä¸­æ–‡æœ¬
      tokenFiles.addEventListener("selectstart", function (e) {
        if (isMouseDown) {
          e.preventDefault();
        }
      });
    }

    // Settingsä¸Šä¸‹æ–‡èœå•
    function setupContextMenu() {
      const tokenFiles = document.querySelector(".token-files");
      const contextMenu = document.getElementById("contextMenu");

      // å³é”®ç‚¹å‡»Showèœå•
      tokenFiles.addEventListener("contextmenu", function (e) {
        const row = e.target.closest("tr");
        if (!row) return;

        e.preventDefault();

        const token = row.dataset.token;

        // å¦‚æœç‚¹å‡»çš„è¡Œä¸åœ¨é€‰ä¸­itemsä¸­ï¼Œåˆ™æ¸…é™¤Selectå¹¶é€‰ä¸­è¯¥è¡Œ
        if (!selectedTokens.has(token)) {
          clearSelection();
          selectToken(token);
          updateSelectionStatus();
        }

        // Settingså½“å‰å¤„ç†çš„token
        currentToken = token;

        // UpdateProxyå­èœå•
        updateProxySubmenu();

        // UpdateStatuså­èœå•
        updateStatusSubmenu();

        // Updateå¤šé€‰æ—¶çš„èœå•itemsæ–‡æœ¬
        if (selectedTokens.size > 1) {
          document.querySelector(
            '.context-menu-item[onclick="viewDetails()"] span:first-child',
          ).textContent = "ViewDetails(å•)";
          document.querySelector(
            '.context-menu-item[onclick="refreshSelectedProfiles()"] span:first-child',
          ).textContent = `RefreshProfile(å·²é€‰${selectedTokens.size})`;
          document.querySelector(
            '.context-menu-item[onclick="refreshSelectedConfigVersions()"] span:first-child',
          ).textContent = `RefreshConfig Version(å·²é€‰${selectedTokens.size})`;
          document.querySelector(
            '.context-menu-item[onclick="upgradeSelectedTokens()"] span:first-child',
          ).textContent = `RefreshToken(å·²é€‰${selectedTokens.size})`;
          document.querySelector(
            '.context-menu-item[onclick="openTimezoneSelector()"] span:first-child',
          ).textContent = `SettingsTimezone(å·²é€‰${selectedTokens.size})`;
          document.querySelector(
            ".context-menu-item.proxy-menu span:first-child",
          ).textContent = `SettingsProxy(å·²é€‰${selectedTokens.size})`;
          document.querySelector(
            '.context-menu-item[onclick="deleteSelectedTokens()"] span:first-child',
          ).textContent = `Delete(å·²é€‰${selectedTokens.size})`;
        } else {
          document.querySelector(
            '.context-menu-item[onclick="viewDetails()"] span:first-child',
          ).textContent = "ViewDetails";
          document.querySelector(
            '.context-menu-item[onclick="refreshSelectedProfiles()"] span:first-child',
          ).textContent = "RefreshProfile";
          document.querySelector(
            '.context-menu-item[onclick="refreshSelectedConfigVersions()"] span:first-child',
          ).textContent = "RefreshConfig Version";
          document.querySelector(
            '.context-menu-item[onclick="upgradeSelectedTokens()"] span:first-child',
          ).textContent = "RefreshToken";
          document.querySelector(
            '.context-menu-item[onclick="openTimezoneSelector()"] span:first-child',
          ).textContent = "SettingsTimezone";
          document.querySelector(
            ".context-menu-item.proxy-menu span:first-child",
          ).textContent = "SettingsProxy";
          document.querySelector(
            '.context-menu-item[onclick="deleteSelectedTokens()"] span:first-child',
          ).textContent = "Delete";
        }

        // è®¡ç®—èœå•ä½ç½®
        positionContextMenu(contextMenu, e.clientX, e.clientY);
      });

      // ç‚¹å‡»å…¶ä»–åœ°æ–¹Closeèœå•
      document.addEventListener("click", function (e) {
        if (!contextMenu.contains(e.target)) {
          contextMenu.style.display = "none";
        }
      });
    }

    // è®¡ç®—å’ŒSettingsèœå•ä½ç½®
    function positionContextMenu(menu, x, y) {
      // é¦–å…ˆShowèœå•ä½†è®¾ä¸ºä¸å¯è§ï¼Œä»¥ä¾¿è·å–å…¶å°ºå¯¸
      menu.style.display = "block";
      menu.style.visibility = "hidden";

      // è·å–èœå•å°ºå¯¸å’Œçª—å£å°ºå¯¸
      const menuRect = menu.getBoundingClientRect();
      const menuWidth = menuRect.width;
      const menuHeight = menuRect.height;
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;

      // è®¡ç®—æœ€ä½³ä½ç½®
      let posX = x;
      let posY = y;

      // æ°´å¹³æ–¹å‘è°ƒæ•´ - å¦‚æœèœå•ä¼šè¶…å‡ºå³è¾¹ç•Œï¼Œåˆ™å‘å·¦Expand
      if (x + menuWidth > windowWidth) {
        posX = windowWidth - menuWidth - 5; // 5pxçš„å®‰å…¨è¾¹è·
      }

      // å‚ç›´æ–¹å‘è°ƒæ•´ - å¦‚æœèœå•ä¼šè¶…å‡ºåº•éƒ¨è¾¹ç•Œï¼Œåˆ™å‘ä¸ŠExpand
      if (y + menuHeight > windowHeight) {
        posY = windowHeight - menuHeight - 5; // 5pxçš„å®‰å…¨è¾¹è·

        // å¦‚æœå‘ä¸ŠExpandä¹Ÿä¸å¤Ÿç©ºé—´ï¼Œå°½é‡Showåœ¨è§†å£ä¸­å¤®
        if (posY < 0) {
          posY = Math.max(5, (windowHeight - menuHeight) >> 1);
        }
      }

      // åº”ç”¨è®¡ç®—åçš„ä½ç½®
      menu.style.left = `${posX}px`;
      menu.style.top = `${posY}px`;
      menu.style.visibility = "visible";

      // è°ƒæ•´å­èœå•æ–¹å‘
      adjustSubmenuPosition(menu, windowWidth, windowHeight);
    }

    // è°ƒæ•´å­èœå•ä½ç½®
    function adjustSubmenuPosition(menu, windowWidth, windowHeight) {
      const proxyMenu = menu.querySelector(".proxy-menu");
      if (!proxyMenu) return;

      // Resetæ–¹å‘ç±»
      proxyMenu.classList.remove("open-upward", "open-leftward");

      // è·å–èœå•itemsä½ç½®
      const menuItemRect = proxyMenu.getBoundingClientRect();
      const submenu = proxyMenu.querySelector(".proxy-submenu");

      // å…ˆä¸´æ—¶Showå­èœå•ä»¥è·å–å…¶å°ºå¯¸
      const originalVisibility = submenu.style.visibility;
      submenu.style.visibility = "hidden";
      submenu.style.opacity = "1";

      const submenuRect = submenu.getBoundingClientRect();
      const submenuHeight = submenuRect.height;
      const submenuWidth = submenuRect.width;

      // è¿˜åŸå­èœå•Status
      submenu.style.visibility = originalVisibility;
      submenu.style.opacity = "";

      // æ£€æŸ¥å³ä¾§YesNoæœ‰è¶³å¤Ÿç©ºé—´
      const rightSpace = windowWidth - menuItemRect.right;
      if (rightSpace < submenuWidth) {
        proxyMenu.classList.add("open-leftward");
      }

      // æ£€æŸ¥åº•éƒ¨YesNoæœ‰è¶³å¤Ÿç©ºé—´
      const bottomSpace = windowHeight - menuItemRect.top;
      if (bottomSpace < submenuHeight) {
        // å¦‚æœåº•éƒ¨ç©ºé—´ä¸å¤Ÿï¼Œæ£€æŸ¥é¡¶éƒ¨YesNoæœ‰è¶³å¤Ÿç©ºé—´
        const topSpace = menuItemRect.bottom;
        if (topSpace >= submenuHeight || topSpace > bottomSpace) {
          proxyMenu.classList.add("open-upward");
        }
      }
    }

    // UpdateProxyå­èœå•
    function updateProxySubmenu() {
      const submenu = document.getElementById("proxySubmenu");
      if (!submenu) return;

      // è·å–é€‰ä¸­çš„tokenå¯¹è±¡ - æ ¼å¼: [index, alias, tokenData]
      const selectedTokenArrs = allTokens.filter((tokenArr) => {
        const [_, __, tokenData] = tokenArr;
        return selectedTokens.has(tokenData.primary_token);
      });
      const selectionSize = selectedTokenArrs.length;

      // è®¡ç®—é€‰ä¸­itemsä¸­çš„Proxyä½¿ç”¨æƒ…å†µ
      const selectedProxyUsage = { "": 0 }; // åˆå§‹åŒ– "Unspecified" è®¡æ•°
      proxyList.forEach((proxy) => {
        selectedProxyUsage[proxy] = 0;
      }); // åˆå§‹åŒ–å·²çŸ¥Proxyè®¡æ•°

      selectedTokenArrs.forEach((tokenArr) => {
        const [_, __, tokenData] = tokenArr;
        const proxy = tokenData.proxy || ""; // è·å–é€‰ä¸­ token çš„Proxy
        // ç¡®ä¿è®¡æ•°å¯¹è±¡é‡Œæœ‰è¿™key
        if (!(proxy in selectedProxyUsage)) {
          selectedProxyUsage[proxy] = 0;
        }
        selectedProxyUsage[proxy]++; // å¢åŠ å¯¹åº”Proxyçš„è®¡æ•°
      });

      // æ„å»º "Unspecified" é€‰items
      const isUnspecifiedActive =
        selectionSize > 0 && selectedProxyUsage[""] === selectionSize;
      let html = `
      <div class="context-menu-item ${isUnspecifiedActive ? "active" : ""}" onclick="setProxy('')">
        <span>Unspecified</span>
        <span class="proxy-count">${selectedProxyUsage[""]}</span>
        <span class="check-mark"></span>
      </div>
      <div class="context-menu-divider"></div>
    `;

      // Addæ‰€æœ‰AvailableProxyé€‰items
      if (proxyList.length > 0) {
        proxyList.forEach((proxy) => {
          if (!proxy) return; // è·³è¿‡ç©ºProxyå
          const count = selectedProxyUsage[proxy] || 0; // è·å–é€‰ä¸­itemsä¸­ä½¿ç”¨è¿™Proxyçš„Count
          // æ£€æŸ¥YesNoæ‰€æœ‰é€‰ä¸­çš„ Token éƒ½ä½¿ç”¨äº†æ­¤Proxy
          const isActive =
            selectionSize > 0 && count === selectionSize && proxy !== "";

          html += `
          <div class="context-menu-item ${isActive ? "active" : ""}" onclick="setProxy('${proxy}')">
            <span>${proxy}</span>
            <span class="proxy-count">${count}</span>
            <span class="check-mark"></span>
          </div>
        `;
        });
      } else {
        html += `<div class="context-menu-item disabled"><span>NoneAvailableProxy</span></div>`;
      }

      submenu.innerHTML = html;

      // Add has-submenu ç±»ä»¥ä¾¿Showç®­å¤´
      const proxyMenuEl = document.querySelector(".proxy-menu");
      if (proxyMenuEl) {
        proxyMenuEl.classList.add("has-submenu");
      }
    }

    // è·å–Tokenä¿¡æ¯
    async function getTokenInfo() {
      showToast("LoadingTokenåˆ—è¡¨...", "info");

      // Saveå½“å‰Filterrecordsä»¶
      const searchTerm = document.getElementById("searchInput").value;
      const membershipFilter =
        document.getElementById("membershipFilter").value;
      const usageMinValue = document.getElementById("usageMin").value;
      const usageMaxValue = document.getElementById("usageMax").value;
      const trialMinValue = document.getElementById("trialMin").value;
      const trialMaxValue = document.getElementById("trialMax").value;
      const profileFilter = document.getElementById("profileFilter").value;
      const proxyFilter = document.getElementById("proxyFilter").value;
      const timezoneFilter = document.getElementById("timezoneFilter").value; // SaveTimezoneFilterrecordsä»¶

      // RefreshProxyåˆ—è¡¨
      await getProxies();

      const data = await makeAuthenticatedRequest("/tokens/get");
      if (data && data.tokens) {
        // ç›´æ¥ä½¿ç”¨æ–°çš„æ•°æ®æ ¼å¼
        allTokens = data.tokens;
        renderTokens(allTokens);
        updateStatusBar();
        updateProxyFilter(); // UpdateProxyFilterä¸‹æ‹‰æ¡†
        updateTimezoneFilter(); // UpdateTimezoneFilterä¸‹æ‹‰æ¡†
        updateStatusSubmenu(); // UpdateStatuså­èœå•

        // æ¢å¤Filterrecordsä»¶
        document.getElementById("searchInput").value = searchTerm;
        document.getElementById("membershipFilter").value = membershipFilter;
        document.getElementById("usageMin").value = usageMinValue;
        document.getElementById("usageMax").value = usageMaxValue;
        document.getElementById("trialMin").value = trialMinValue;
        document.getElementById("trialMax").value = trialMaxValue;
        document.getElementById("profileFilter").value = profileFilter;
        document.getElementById("proxyFilter").value = proxyFilter;
        document.getElementById("timezoneFilter").value = timezoneFilter; // æ¢å¤TimezoneFilterrecordsä»¶

        // åº”ç”¨Filter
        filterTokens();

        showToast("Tokenåˆ—è¡¨å·²Update", "success");
      } else {
        showToast("è·å–Tokenåˆ—è¡¨Failed", "error");
      }
    }

    // UpdateProxyFilterä¸‹æ‹‰æ¡†
    function updateProxyFilter() {
      const proxyFilterSelect = document.getElementById("proxyFilter");

      // ä¿æŒPageä¸€å’ŒPageäºŒé€‰itemsï¼ˆAllProxyå’ŒUnspecified Proxyï¼‰
      while (proxyFilterSelect.options.length > 2) {
        proxyFilterSelect.remove(2);
      }

      // ä½¿ç”¨å…¬Totalæ–¹æ³•è·å–Proxyä½¿ç”¨ç»Ÿè®¡
      const proxyUsage = getProxyUsageStats();

      // AddProxyé€‰items
      proxyList.forEach((proxy) => {
        if (proxy) {
          // ç¡®ä¿Proxyåä¸ä¸ºç©º
          const option = document.createElement("option");
          option.value = proxy;
          option.textContent = `${proxy} (${proxyUsage[proxy] || 0})`;
          proxyFilterSelect.appendChild(option);
        }
      });
    }

    // SettingsProxy
    async function setProxy(proxyName) {
      if (selectedTokens.size === 0) {
        showToast("è¯·å…ˆSelectToken", "info");
        return;
      }

      // è·å–é€‰ä¸­tokençš„åˆ«å - æ ¼å¼: [index, alias, tokenData]
      const aliasesToUpdate = [...selectedTokens].map((token) => {
        const tokenArr = allTokens.find((arr) => {
          const [_, __, tokenData] = arr;
          return tokenData.primary_token === token;
        });
        return tokenArr ? tokenArr[1] : token; // tokenArr[1] Yes alias
      });

      showToast("æ­£åœ¨UpdateProxySettings...", "info");

      try {
        const data = await makeAuthenticatedRequest("/tokens/proxy/set", {
          body: JSON.stringify({
            aliases: aliasesToUpdate,
            proxy: proxyName || null, // ç©ºå­—ç¬¦ä¸²å‘é€nullä»¥æ¸…é™¤Proxy
          }),
        });

        if (data && data.status === "success") {
          showToast(data.message || "ProxySettingsSuccess", "success");
          getTokenInfo(); // RefreshTokenåˆ—è¡¨
        } else {
          showToast("ProxySettingsFailed", "error");
        }
      } catch (error) {
        showToast("ProxySettingsFailed", "error");
      }
    }

    // UpdateGenerate Keyå¯¹è¯æ¡†ä¸­çš„ProxySelect
    function updateProxySelect() {
      const proxySelect = document.getElementById("proxySelect");
      if (!proxySelect || proxyList.length === 0) return;

      // Clearç°æœ‰é€‰itemsï¼ˆä¿ç•™Pageä¸€"è·ŸéšTokenSettings"é€‰itemsï¼‰
      while (proxySelect.options.length > 1) {
        proxySelect.remove(1);
      }

      // AddProxyé€‰items
      proxyList.forEach((proxy) => {
        const option = document.createElement("option");
        option.value = proxy;
        option.textContent = proxy;
        proxySelect.appendChild(option);
      });
    }

    // æ¸²æŸ“Tokenåˆ—è¡¨
    function renderTokens(tokens) {
      const fileListBody = document.getElementById("fileListBody");
      const emptyState = document.getElementById("emptyState");

      if (tokens.length === 0) {
        fileListBody.innerHTML = "";
        emptyState.style.display = "block";
        return;
      }

      emptyState.style.display = "none";

      fileListBody.innerHTML = tokens
        .map((tokenArr, idx) => {
          // æ ¼å¼: [index, alias, tokenData]
          const [index, alias, tokenData] = tokenArr;
          const user = tokenData.user || {};
          const stripe = tokenData.stripe || {};
          const usage = tokenData.usage || {};
          const premium = usage.premium || {};
          const token = tokenData.primary_token;
          const checksum = tokenData.checksum
            ? `${tokenData.checksum.first}${tokenData.checksum.second}`
            : "";
          const disabled = !tokenData.status.enabled;
          const timezone = tokenData.timezone || "";
          const proxy = tokenData.proxy || "";

          const displayName =
            alias || user.email || token.substring(0, 15) + "...";

          return `
        <tr data-token="${token}" data-alias="${alias}" data-checksum="${checksum}" data-index="${idx}" class="${selectedTokens.has(token) ? "selected" : ""}">
          <td>
            <span class="status-indicator ${disabled ? "status-disabled" : "status-enabled"}"></span>
            <span class="file-icon">ğŸ”‘</span>
            ${displayName}
          </td>
          <td>${formatMembershipType(stripe.membership_type)}</td>
          <td>${premium.num_requests || 0}/${premium.max_requests || "âˆ"}</td>
          <td>${stripe.days_remaining_on_trial > 0 ? `${stripe.days_remaining_on_trial}days` : "-"}</td>
          <td><span class="timezone-name" onclick="openTimezoneSelectorForToken('${token}', event)">${timezone || "Unspecified"}</span></td>
          <td><span class="proxy-name" onclick="openProxySelector('${displayName}','${token}', event)">${proxy || "Unspecified"}</span></td>
        </tr>
      `;
        })
        .join("");

      // Addç‚¹å‡»äº‹ä»¶å¤„ç†
      const rows = document.querySelectorAll("#fileListBody tr");
      rows.forEach((row) => {
        row.addEventListener("click", function (e) {
          // å¦‚æœç‚¹å‡»çš„YesProxyNameæˆ–TimezoneNameï¼Œä¸å¤„ç†è¡ŒSelect
          if (
            e.target.classList.contains("proxy-name") ||
            e.target.classList.contains("timezone-name")
          ) {
            return;
          }

          const row = e.target.closest("tr");
          if (!row) return;

          const token = this.dataset.token;
          const index = parseInt(this.dataset.index);

          const modifierKey = isModifierKey(e);

          if (e.shiftKey && lastSelectedIndex !== -1) {
            // Shift+ç‚¹å‡»å®ç°RangeSelect
            const start = Math.min(lastSelectedIndex, index);
            const end = Math.max(lastSelectedIndex, index);

            clearSelection();

            for (let i = start; i <= end; i++) {
              const rowToken = rows[i].dataset.token;
              selectToken(rowToken);
            }
          } else if (modifierKey) {
            // Ctrl+ç‚¹å‡»å®ç°å¤šé€‰
            if (selectedTokens.has(token)) {
              deselectToken(token);
            } else {
              selectToken(token, true);
              lastSelectedIndex = index;
            }
          } else {
            // æ™®é€šç‚¹å‡»
            clearSelection();
            selectToken(token);
            lastSelectedIndex = index;
          }

          updateSelectionStatus();
        });
      });

      // åŒå‡»ViewDetails
      fileListBody.addEventListener("dblclick", function (e) {
        const row = e.target.closest("tr");
        if (!row) return;

        const token = row.dataset.token;
        selectToken(token);
        viewDetails();
      });

      updateSelectionStatus();
      // UpdateProxyå­èœå•
      updateProxySubmenu();
    }

    // ä¸ºå•Tokenæ‰“å¼€TimezoneSelectå™¨
    function openTimezoneSelectorForToken(token, event) {
      // é˜»æ­¢äº‹ä»¶å†’æ³¡ï¼Œé¿å…è§¦å‘è¡ŒSelect
      event.stopPropagation();

      // é€‰ä¸­è¯¥Token
      clearSelection();
      selectToken(token);

      // æ‰“å¼€TimezoneSelectå™¨
      openTimezoneSelector();
    }

    // FilterToken
    function filterTokens() {
      const searchTerm = document
        .getElementById("searchInput")
        .value.toLowerCase();
      const membershipFilter =
        document.getElementById("membershipFilter").value;
      const usageMinValue = document.getElementById("usageMin").value;
      const usageMaxValue = document.getElementById("usageMax").value;
      const trialMinValue = document.getElementById("trialMin").value;
      const trialMaxValue = document.getElementById("trialMax").value;
      const profileFilter = document.getElementById("profileFilter").value;
      const proxyFilter = document.getElementById("proxyFilter").value;
      const timezoneFilter = document.getElementById("timezoneFilter").value; // æ–°å¢TimezoneFilter

      const filteredTokens = allTokens.filter((tokenArr) => {
        // æ ¼å¼: [index, alias, tokenData]
        const [index, alias, tokenData] = tokenArr;
        const user = tokenData.user || {};
        const stripe = tokenData.stripe || {};
        const usage = tokenData.usage || {};
        const premium = usage.premium || {};
        const token = tokenData.primary_token;
        const timezone = tokenData.timezone || "";
        const proxy = tokenData.proxy || "";

        // Searchrecordsä»¶
        const emailMatch = (user.email || "")
          .toLowerCase()
          .includes(searchTerm);
        const tokenMatch = (token || "").toLowerCase().includes(searchTerm);
        const aliasMatch = (alias || "").toLowerCase().includes(searchTerm);
        const searchMatch =
          searchTerm === "" || emailMatch || tokenMatch || aliasMatch;

        // ä¼šå‘˜TypeFilter
        const membershipType = stripe.membership_type || "";
        let membershipMatch = true;
        if (membershipFilter !== "all") {
          membershipMatch = membershipType === membershipFilter;
        }

        // ä½¿UsageåŒºé—´Filter
        let usageMatch = true;
        const currentUsage = premium.num_requests || 0;
        if (usageMinValue !== "") {
          usageMatch = usageMatch && currentUsage >= parseInt(usageMinValue);
        }
        if (usageMaxValue !== "") {
          usageMatch = usageMatch && currentUsage <= parseInt(usageMaxValue);
        }

        // è¯•ç”¨æœŸåŒºé—´Filter
        let trialMatch = true;
        const daysRemaining = stripe.days_remaining_on_trial || 0;
        if (trialMinValue !== "") {
          trialMatch = trialMatch && daysRemaining >= parseInt(trialMinValue);
        }
        if (trialMaxValue !== "") {
          trialMatch = trialMatch && daysRemaining <= parseInt(trialMaxValue);
        }

        // ProfileFilter
        let profileMatch = true;
        if (profileFilter === "has_profile") {
          profileMatch = user && Object.keys(user).length > 0;
        } else if (profileFilter === "no_profile") {
          profileMatch = !user || Object.keys(user).length === 0;
        }

        // ProxyFilter
        let proxyMatch = true;
        if (proxyFilter !== "all") {
          if (proxyFilter === "none") {
            proxyMatch = proxy === "";
          } else {
            proxyMatch = proxy === proxyFilter;
          }
        }

        // TimezoneFilter
        let timezoneMatch = true;
        if (timezoneFilter !== "all") {
          if (timezoneFilter === "none") {
            timezoneMatch = timezone === "";
          } else {
            timezoneMatch = timezone === timezoneFilter;
          }
        }

        return (
          searchMatch &&
          membershipMatch &&
          usageMatch &&
          trialMatch &&
          profileMatch &&
          proxyMatch &&
          timezoneMatch
        );
      });

      renderTokens(filteredTokens);

      // åœ¨Statusæ ShowFilterç»“æœ
      updateStatusBar(filteredTokens.length);
    }

    // UpdateStatusæ 
    function updateStatusBar(filteredCount) {
      const total = allTokens.length;
      const selected = selectedTokens.size;
      const selectionStatus = document.getElementById("selectionStatus");
      const totalCount = document.getElementById("totalCount");

      if (selectionStatus)
        selectionStatus.textContent = `å·²Select: ${selected} itemsç›®`;
      if (totalCount) {
        // ä½¿ç”¨!== undefinedåˆ¤æ–­ï¼Œè¿™æ ·å³ä½¿filteredCountä¸º0ä¹Ÿä¼šæ­£ç¡®Show
        totalCount.textContent = `Total ${filteredCount !== undefined ? filteredCount : total} Token`;
      }
    }

    // æ ¼å¼åŒ–ä¼šå‘˜Type
    function formatMembershipType(type) {
      if (!type) return "-";
      const types = {
        free: "Free",
        free_trial: "Trial",
        pro: "Pro",
        pro_plus: "Pro Plus",
        ultra: "Ultra",
        enterprise: "Enterprise",
      };
      return types[type] || type;
    }

    // SelectToken
    function selectToken(token, append = false) {
      if (!token) return;

      if (!append) {
        clearSelection();
      }

      selectedTokens.add(token);
      const row = document.querySelector(`tr[data-token="${token}"]`);
      if (row) {
        row.classList.add("selected");
      }

      updateSelectionStatus();
    }

    // CancelSelectToken
    function deselectToken(token) {
      if (!token) return;

      selectedTokens.delete(token);
      const row = document.querySelector(`tr[data-token="${token}"]`);
      if (row) {
        row.classList.remove("selected");
      }

      updateSelectionStatus();
    }

    // æ¸…é™¤æ‰€æœ‰Select
    function clearSelection() {
      selectedTokens.clear();
      const rows = document.querySelectorAll("#fileListBody tr.selected");
      rows.forEach((row) => {
        row.classList.remove("selected");
      });

      updateSelectionStatus();
    }

    // Selectæ‰€æœ‰Token
    function selectAllTokens() {
      clearSelection();

      const rows = document.querySelectorAll("#fileListBody tr");
      rows.forEach((row) => {
        const token = row.dataset.token;
        selectedTokens.add(token);
        row.classList.add("selected");
      });

      updateSelectionStatus();
    }

    // UpdateSelectStatus
    function updateSelectionStatus() {
      updateStatusBar();

      // å¦‚æœåªSelectäº†ä¸€Tokenï¼ŒUpdateDetails
      if (selectedTokens.size === 1) {
        updateDetailsPanel([...selectedTokens][0]);
      }
    }

    // ViewTokenDetails
    function viewDetails() {
      if (selectedTokens.size === 0) return;

      // å¦‚æœSelectäº†å¤šTokenï¼ŒåªShowPageä¸€
      const token = [...selectedTokens][0];
      updateDetailsPanel(token);
      toggleDetailsPanel(true);
      // Closeå³é”®èœå•
      document.getElementById("contextMenu").style.display = "none";
    }

    // UpdateDetailsé¢æ¿
    function updateDetailsPanel(token) {
      // æŸ¥æ‰¾tokenå¯¹è±¡ - æ ¼å¼: [index, alias, tokenData]
      const tokenArr = allTokens.find((arr) => {
        const [_, __, tokenData] = arr;
        return tokenData.primary_token === token;
      });
      if (!tokenArr) return;

      const [index, alias, tokenData] = tokenArr;
      const user = tokenData.user || {};
      const stripe = tokenData.stripe || {};
      const usage = tokenData.usage || {};
      const premium = usage.premium || {};
      const timezone = tokenData.timezone || "-";
      const proxy = tokenData.proxy || "-";
      const checksum = tokenData.checksum
        ? `${tokenData.checksum.first}${tokenData.checksum.second}`
        : "-";

      document.getElementById("detailsTitle").textContent =
        user.email || "æœªçŸ¥è´¦æˆ·";

      const content = document.getElementById("detailsContent");
      content.innerHTML = `
        <div class="details-property">
          <div class="details-property-name">åˆ«å</div>
          <div class="details-property-value">${alias}</div>
        </div>
        <div class="details-property">
          <div class="details-property-name">Token</div>
          <div class="details-property-value">${tokenData.primary_token}</div>
        </div>
        <div class="details-property">
          <div class="details-property-name">æ ¡éªŒå’Œ</div>
          <div class="details-property-value">${checksum}</div>
        </div>
        <div class="details-property">
          <div class="details-property-name">Config Version</div>
          <div class="details-property-value">${tokenData.config_version || "-"}</div>
        </div>
        <div class="details-property">
          <div class="details-property-name">Session ID</div>
          <div class="details-property-value">${tokenData.session_id || "-"}</div>
        </div>
        <div class="details-property">
          <div class="details-property-name">Timezone</div>
          <div class="details-property-value">${timezone}</div>
        </div>
        <div class="details-property">
          <div class="details-property-name">Proxy</div>
          <div class="details-property-value">${proxy}</div>
        </div>
        <div class="details-property">
          <div class="details-property-name">ä¼šå‘˜Type</div>
          <div class="details-property-value">${formatMembershipType(stripe.membership_type)}</div>
        </div>
        <div class="details-property">
          <div class="details-property-name">Premium Usage</div>
          <div class="details-property-value">${premium.num_requests || 0}/${premium.max_requests || "âˆ"}</div>
        </div>
        <div class="details-property">
          <div class="details-property-name">Trial Remaining</div>
          <div class="details-property-value">${stripe.days_remaining_on_trial > 0 ? `${stripe.days_remaining_on_trial}days` : "-"}</div>
        </div>
        <div class="details-property">
          <div class="details-property-name">User ID</div>
          <div class="details-property-value">${user.user_id || "-"}</div>
        </div>
        <div class="details-property">
          <div class="details-property-name">åˆ›å»ºTime</div>
          <div class="details-property-value">${formatDate(user.created_at) || "-"}</div>
        </div>
      `;
    }

    // åˆ‡æ¢Detailsé¢æ¿Show
    function toggleDetailsPanel(show) {
      const panel = document.getElementById("detailsPanel");
      if (show) {
        panel.classList.add("open");
        document.body.style.overflow = "hidden"; // Disableä¸»ä½“pageé¢æ»šåŠ¨
        detailsPanelOpen = true;
      } else {
        panel.classList.remove("open");
        document.body.style.overflow = ""; // æ¢å¤ä¸»ä½“pageé¢æ»šåŠ¨
        detailsPanelOpen = false;
      }
    }

    // æ ¼å¼åŒ–Date
    function formatDate(dateString) {
      if (!dateString) return "-";
      try {
        const date = new Date(dateString);
        return date.toLocaleString("zh-CN");
      } catch (e) {
        return dateString;
      }
    }

    /**
     * å°†é€‰ä¸­çš„TokenCopyåˆ°å‰ªè´´æ¿
     * æ ¼å¼ï¼šæœ‰åˆ«åæ—¶ä¸º "{alias}::{token},{checksum}"ï¼ŒNoneåˆ«åæ—¶ä¸º "{token},{checksum}"
     */
    async function copyTokenToClipboard() {
      if (selectedTokens.size === 0) {
        showToast("è¯·å…ˆSelectToken", "info");
        return;
      }

      // è·å–é€‰ä¸­çš„tokenå¯¹è±¡ - æ ¼å¼: [index, alias, tokenData]
      const selectedTokenArrs = allTokens.filter((tokenArr) => {
        const [_, __, tokenData] = tokenArr;
        return selectedTokens.has(tokenData.primary_token);
      });
      const tokensToCopy = selectedTokenArrs
        .map(formatTokenForCopy)
        .join("\n");

      const success = await copyToClipboard(tokensToCopy, {
        showMessage: false,
        onSuccess: () =>
          showToast(
            `å·²Copy ${selectedTokens.size} Tokenåˆ°å‰ªè´´æ¿`,
            "success",
          ),
        onError: () => showToast("CopyFailedï¼Œè¯·æ‰‹åŠ¨Copy", "error"),
      });

      // Closeå³é”®èœå•
      document.getElementById("contextMenu").style.display = "none";
    }

    /**
     * æ ¼å¼åŒ–å•Tokenå¯¹è±¡ä¸ºCopyæ ¼å¼
     * @param {Array} tokenArr - Tokenæ•°ç»„ [index, alias, tokenData]
     * @returns {string} æ ¼å¼åŒ–åçš„å­—ç¬¦ä¸²
     */
    function formatTokenForCopy(tokenArr) {
      const [index, alias, tokenData] = tokenArr;
      const token = tokenData.primary_token;
      const checksum = tokenData.checksum
        ? `${tokenData.checksum.first}${tokenData.checksum.second}`
        : "";
      const checksumPart = checksum ? `,${checksum}` : "";

      return alias
        ? `${alias}::${token}${checksumPart}`
        : `${token}${checksumPart}`;
    } // Deleteé€‰ä¸­çš„Token
    function deleteSelectedTokens(singleToken) {
      // å¦‚æœæä¾›äº†å•Tokenï¼Œåˆ™åªDeleteè¯¥Token
      if (singleToken) {
        tokensToDelete = [singleToken];
      } else {
        tokensToDelete = [...selectedTokens];

        if (tokensToDelete.length === 0) {
          showToast("è¯·å…ˆSelectè¦Deleteçš„Token", "info");
          return;
        }
      }

      const count = tokensToDelete.length;
      document.getElementById("confirmMessage").textContent =
        count > 1
          ? `OKè¦Deleteé€‰ä¸­çš„ ${count} Tokenå—ï¼Ÿ`
          : "OKè¦Deleteé€‰ä¸­çš„Tokenå—ï¼Ÿ";

      showModal("confirmModal");

      // Closeå³é”®èœå•
      document.getElementById("contextMenu").style.display = "none";
    }

    // ConfirmDeleteToken
    async function confirmDeleteTokens() {
      if (tokensToDelete.length === 0) return;

      closeModal("confirmModal");
      showToast("æ­£åœ¨DeleteToken...", "info");

      // å°†tokenè½¬æ¢ä¸ºalias - æ ¼å¼: [index, alias, tokenData]
      const aliasesToDelete = tokensToDelete.map((token) => {
        const tokenArr = allTokens.find((arr) => {
          const [_, __, tokenData] = arr;
          return tokenData.primary_token === token;
        });
        return tokenArr ? tokenArr[1] : token; // tokenArr[1] Yes alias
      });

      const data = await makeAuthenticatedRequest("/tokens/del", {
        body: JSON.stringify({
          aliases: aliasesToDelete,
          include_failed_tokens: true,
        }),
      });

      if (data) {
        const failedCount = data.failed_tokens?.length || 0;
        const successCount = aliasesToDelete.length - failedCount;
        const message = `DeleteSuccess: ${successCount} Token${failedCount ? `ï¼ŒFailed: ${failedCount} ` : ""}`;

        showToast(message, "success");
        clearSelection();
        getTokenInfo();
      } else {
        showToast("DeleteFailed", "error");
      }

      tokensToDelete = [];
    }

    // Refreshé€‰ä¸­Tokençš„Profile
    async function refreshSelectedProfiles() {
      if (selectedTokens.size === 0) {
        showToast("è¯·å…ˆSelectToken", "info");
        return;
      }

      // å°†tokenè½¬æ¢ä¸ºalias - æ ¼å¼: [index, alias, tokenData]
      const aliasesToRefresh = [...selectedTokens].map((token) => {
        const tokenArr = allTokens.find((arr) => {
          const [_, __, tokenData] = arr;
          return tokenData.primary_token === token;
        });
        return tokenArr ? tokenArr[1] : token; // tokenArr[1] Yes alias
      });

      showToast(
        `æ­£åœ¨Refresh ${aliasesToRefresh.length} Tokençš„Profile...`,
        "info",
      );

      // Closeå³é”®èœå•
      document.getElementById("contextMenu").style.display = "none";

      const data = await makeAuthenticatedRequest("/tokens/profile/update", {
        body: JSON.stringify(aliasesToRefresh),
      });

      if (data) {
        showToast(`Refreshå®Œæˆ: ${data.message}`, "success");
        getTokenInfo();
      } else {
        showToast("RefreshFailed", "error");
      }
    }

    // Refreshé€‰ä¸­Tokençš„ConfigurationVersion
    async function refreshSelectedConfigVersions() {
      if (selectedTokens.size === 0) {
        showToast("è¯·å…ˆSelectToken", "info");
        return;
      }

      // å°†tokenè½¬æ¢ä¸ºalias - æ ¼å¼: [index, alias, tokenData]
      const aliasesToRefresh = [...selectedTokens].map((token) => {
        const tokenArr = allTokens.find((arr) => {
          const [_, __, tokenData] = arr;
          return tokenData.primary_token === token;
        });
        return tokenArr ? tokenArr[1] : token; // tokenArr[1] Yes alias
      });

      showToast(
        `æ­£åœ¨Refresh ${aliasesToRefresh.length} Tokençš„Config Version...`,
        "info",
      );

      // Closeå³é”®èœå•
      document.getElementById("contextMenu").style.display = "none";

      const data = await makeAuthenticatedRequest(
        "/tokens/config-version/update",
        {
          body: JSON.stringify(aliasesToRefresh),
        },
      );

      if (data) {
        showToast(`Refreshå®Œæˆ: ${data.message}`, "success");
        getTokenInfo();
      } else {
        showToast("RefreshFailed", "error");
      }
    }

    // æ‰¹é‡AddToken
    function addTokens() {
      showModal("addTokensModal");
    }

    /**
     * AddTokenConfirmå¤„ç†
     * - éªŒè¯è¾“å…¥
     * - è§£æTokenåˆ—è¡¨
     * - æäº¤Request
     * - UpdateUIStatus
     */
    async function confirmAddTokens() {
      const tokensInput = document.getElementById("addTokensInput").value;
      const status = document.getElementById("addTokensStatus").value;

      if (!tokensInput) {
        showToast("è¯·è¾“å…¥è¦Addçš„Token", "warning");
        return;
      }

      closeModal("addTokensModal");
      showToast("æ­£åœ¨AddToken...", "info");

      const tokenList = tokensInput
        .split("\n")
        .map((line) => line.trim())
        .filter((line) => line && !line.startsWith("#"))
        .map((line) => parseTokenLine(line));

      const data = await makeAuthenticatedRequest("/tokens/add", {
        body: JSON.stringify({
          tokens: tokenList,
          status: status !== "disabled",
        }),
      });

      if (data) {
        showToast(`AddSuccess: ${data.message}`, "success");
        document.getElementById("addTokensInput").value = "";
        getTokenInfo();
      } else {
        showToast("AddFailed", "error");
      }
    }

    /**
     * è§£æTokenè¡Œ
     * æ”¯æŒæ ¼å¼:
     * - alias::token,checksum
     * - alias%3A%3Atoken,checksum
     * - token,checksum
     * - alias::token
     * - alias%3A%3Atoken
     * - token
     * @param {string} line éç©ºè¾“å…¥è¡Œ
     * @returns {{alias: string|null, token: string, checksum: string|null}}
     */
    function parseTokenLine(line) {
      const [main, checksum] = line.split(",").map((s) => s?.trim() || null);

      const separator = "::";
      const encodedSeparator = "%3A%3A";
      const sepIndex = main.includes(separator)
        ? main.indexOf(separator)
        : main.indexOf(encodedSeparator);
      const sepLength = main.includes(separator) ? 2 : 6;

      const hasAlias = sepIndex !== -1;
      const alias = hasAlias
        ? main.substring(0, sepIndex).trim() || null
        : null;
      const token = hasAlias
        ? main.substring(sepIndex + sepLength).trim()
        : main;

      return { alias, token, checksum };
    }

    // ExportTokenåˆ—è¡¨
    function exportTokens() {
      const jsonData = JSON.stringify(allTokens, null, 2);
      const blob = new Blob([jsonData], { type: "application/json" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = "tokens_export.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      showToast("Tokenåˆ—è¡¨å·²Export", "success");
    }

    // ImportTokenåˆ—è¡¨
    function importTokens() {
      showModal("importModal");
    }

    // ConfirmImport
    async function confirmImport() {
      const fileInput = document.getElementById("importFile");

      if (!fileInput.files || fileInput.files.length === 0) {
        showToast("è¯·Selectè¦Importçš„æ–‡ä»¶", "warning");
        return;
      }

      const file = fileInput.files[0];
      const reader = new FileReader();

      reader.onload = async function (e) {
        try {
          const tokensJson = JSON.parse(e.target.result);

          if (!Array.isArray(tokensJson)) {
            throw new Error("Importçš„æ•°æ®æ ¼å¼ä¸æ­£ç¡®ï¼Œåº”ä¸ºæ•°ç»„");
          }

          // å¤„ç†æ•°æ®æ ¼å¼è½¬æ¢ï¼šä» [number, string, tokenData] è½¬æ¢ä¸º [string, tokenData]
          // Deleteæ•°ç»„çš„Pageä¸€items numberï¼Œä¿ç•™ alias å’Œ tokenData
          const processedTokens = tokensJson.map((tokenArr) => {
            if (Array.isArray(tokenArr) && tokenArr.length >= 3) {
              // DeletePageä¸€items numberï¼Œä¿ç•™ alias å’Œ tokenData
              return [tokenArr[1], tokenArr[2]];
            } else if (Array.isArray(tokenArr) && tokenArr.length === 2) {
              // å¦‚æœå·²ç»Yesæ­£ç¡®æ ¼å¼ï¼Œç›´æ¥è¿”å›
              return tokenArr;
            } else {
              throw new Error(`Noneæ•ˆçš„Tokenæ•°æ®æ ¼å¼ï¼ŒæœŸæœ›æ•°ç»„é•¿åº¦ä¸º2æˆ–3ï¼Œå®é™…é•¿åº¦ä¸º${Array.isArray(tokenArr) ? tokenArr.length : 'éæ•°ç»„'}`);
            }
          });

          closeModal("importModal");
          showToast("æ­£åœ¨ImportToken...", "info");

          const data = await makeAuthenticatedRequest("/tokens/set", {
            body: JSON.stringify(processedTokens),
          });

          if (data) {
            showToast("Tokenåˆ—è¡¨ImportSuccess", "success");
            fileInput.value = "";
            getTokenInfo();
          } else {
            showToast("ImportFailedï¼ŒServiceå™¨æœªè¿”å›ValidResponse", "error");
          }
        } catch (error) {
          showToast("ImportFailed: " + error.message, "error");
        }
      };

      reader.readAsText(file);
    }

    // Generate Key
    function generateKey(token, checksum) {
      // å¦‚æœæœªæä¾›tokenï¼Œåˆ™ä½¿ç”¨é€‰ä¸­çš„token
      if (!token && selectedTokens.size === 0) {
        showToast("è¯·å…ˆSelectToken", "info");
        return;
      }

      const tokenToUse = token || [...selectedTokens][0]; // æŸ¥æ‰¾tokençš„checksum - æ ¼å¼: [index, alias, tokenData]
      let checksumToUse = checksum;
      if (!checksumToUse) {
        const tokenArr = allTokens.find((arr) => {
          const [_, __, tokenData] = arr;
          return tokenData.primary_token === tokenToUse;
        });
        if (tokenArr) {
          const [_, __, tokenData] = tokenArr;
          checksumToUse = tokenData.checksum
            ? `${tokenData.checksum.first}${tokenData.checksum.second}`
            : "";
        }
      }

      document.getElementById("keyToken").textContent = tokenToUse;

      // Resetè¡¨å•
      document.getElementById("disableVision").value = "";
      document.getElementById("enableSlowPool").value = "";
      document.getElementById("usageCheckType").value = "";
      document.getElementById("includeWebReferences").value = "";
      document.getElementById("keyContent").textContent = "";
      document.getElementById("keyResult").style.display = "none";

      // UpdateProxySelectä¸‹æ‹‰æ¡†
      updateProxySelect();

      showModal("keyModal");

      // Closeå³é”®èœå•
      document.getElementById("contextMenu").style.display = "none";
    }

    // Generate Keyæäº¤
    async function generateKeySubmit() {
      const token = document.getElementById("keyToken").textContent; // æŸ¥æ‰¾tokenå¯¹è±¡ - æ ¼å¼: [index, alias, tokenData]
      const tokenArr = allTokens.find((arr) => {
        const [_, __, tokenData] = arr;
        return tokenData.primary_token === token;
      });

      if (!token || !tokenArr) {
        showToast("ç¼ºå°‘Token", "error");
        return;
      }

      const [_, __, tokenData] = tokenArr;

      // éªŒè¯å¿…éœ€å­—æ®µ
      if (
        !tokenData.checksum ||
        !tokenData.checksum.first ||
        !tokenData.checksum.second
      ) {
        showToast("Tokenç¼ºå°‘æ ¡éªŒå’Œä¿¡æ¯ï¼ŒNoneæ³•Generate Key", "error");
        return;
      }

      if (!tokenData.client_key) {
        showToast("Tokenç¼ºå°‘å®¢æˆ·ç«¯å¯†é’¥ï¼ŒNoneæ³•Generate Key", "error");
        return;
      }

      if (!tokenData.config_version) {
        showToast("Tokenç¼ºå°‘ConfigurationVersionï¼ŒNoneæ³•Generate Key", "error");
        return;
      }

      if (!tokenData.session_id) {
        showToast("Tokenç¼ºå°‘ä¼šè¯IDï¼ŒNoneæ³•Generate Key", "error");
        return;
      }

      const disableVision = document.getElementById("disableVision").value;
      const enableSlowPool = document.getElementById("enableSlowPool").value;
      const usageCheckType = document.getElementById("usageCheckType").value;
      const includeWebReferences = document.getElementById(
        "includeWebReferences",
      ).value;
      const proxyName = document.getElementById("proxySelect").value;

      // æ„å»ºRequestä½“
      const requestBody = {
        token: tokenData.primary_token,
        checksum: {
          first: tokenData.checksum.first,
          second: tokenData.checksum.second,
        },
        client_key: tokenData.client_key,
        config_version: tokenData.config_version,
        session_id: tokenData.session_id,
      };

      // Addå¯é€‰å‚æ•°
      if (disableVision) {
        requestBody.disable_vision = disableVision === "true";
      }
      if (enableSlowPool) {
        requestBody.enable_slow_pool = enableSlowPool === "true";
      }
      if (includeWebReferences) {
        requestBody.include_web_references = includeWebReferences === "true";
      }

      // å¦‚æœSelectäº†ç‰¹å®šProxyï¼Œåˆ™ä½¿ç”¨Selectçš„Proxy
      if (proxyName) {
        requestBody.proxy_name = proxyName;
      } else {
        // Noåˆ™ä½¿ç”¨Tokençš„bundleä¸­Settingsçš„Proxy
        const tokenProxyName = tokenData.proxy || "";
        if (tokenProxyName) {
          requestBody.proxy_name = tokenProxyName;
        }
      }

      // TimezoneSettings
      if (tokenData.timezone) {
        requestBody.timezone = tokenData.timezone;
      }

      // GCPP HostSettings
      if (tokenData.gcpp_host) {
        requestBody.gcpp_host = tokenData.gcpp_host;
      }

      if (usageCheckType) {
        requestBody.usage_check_models = {
          type: usageCheckType,
        };

        if (usageCheckType === "custom") {
          const selectedModels = Array.from(
            document.querySelectorAll("#modelListContainer input:checked"),
          ).map((input) => input.value);
          if (selectedModels.length > 0) {
            requestBody.usage_check_models.model_ids =
              selectedModels.join(",");
          }
        }
      }

      try {
        const response = await makeAuthenticatedRequest("/build-key", {
          body: JSON.stringify(requestBody),
        });

        if (response && response.keys && response.keys.length > 0) {
          document.getElementById("keyContent").textContent =
            response.keys[0];
          document.getElementById("keyResult").style.display = "block";
          showToast("Keyå·²ç”Ÿæˆï¼Œç‚¹å‡»Copy", "success");
        } else {
          showToast(
            "Generate KeyFailed: " + (response.error || "æœªçŸ¥Error"),
            "error",
          );
        }
      } catch (error) {
        showToast("Generate KeyFailed: " + error.message, "error");
      }
    }

    // Copyç”Ÿæˆçš„Key
    async function copyGeneratedKey() {
      const key = document.getElementById("keyContent").textContent;
      await copyToClipboard(key, {
        showMessage: false,
        successMessage: "Keyå·²Copyåˆ°å‰ªè´´æ¿",
        errorMessage: "KeyCopyFailedï¼Œè¯·æ‰‹åŠ¨Copy",
        onSuccess: () => showToast("Keyå·²Copyåˆ°å‰ªè´´æ¿", "success"),
        onError: () => showToast("KeyCopyFailedï¼Œè¯·æ‰‹åŠ¨Copy", "error"),
        sourceElement: document.getElementById("keyResult"),
      });
    }
    // è·å–æ¨¡å‹åˆ—è¡¨
    async function getModels() {
      const data = await (await fetch("/health")).json();
      if (data && data.models) {
        availableModels = data.models;

        // å¡«å……æ¨¡å‹åˆ—è¡¨
        renderModelList();
      }
    }

    // æ¸²æŸ“æ¨¡å‹åˆ—è¡¨
    function renderModelList() {
      const container = document.getElementById("modelListContainer");

      container.innerHTML = availableModels
        .map(
          (model) => `
        <div class="model-item">
          <input type="checkbox" id="model_${model}" value="${model}">
          <label for="model_${model}">${model}</label>
        </div>
      `,
        )
        .join("");
    }

    // åˆ‡æ¢æ¨¡å‹åˆ—è¡¨Show
    function toggleModelList() {
      const usageCheckType = document.getElementById("usageCheckType").value;
      const container = document.getElementById("modelListContainer");

      if (usageCheckType === "custom") {
        container.style.display = "block";
      } else {
        container.style.display = "none";
      }
    }

    // Showå¯¹è¯æ¡†
    function showModal(modalId) {
      const modal = document.getElementById(modalId);
      const backdrop = document.getElementById(`${modalId}-backdrop`);

      if (modal && backdrop) {
        modal.style.display = "block";
        backdrop.style.display = "block";
        document.body.style.overflow = "hidden"; // Disableä¸»ä½“pageé¢æ»šåŠ¨
      }
    }

    // Closeå¯¹è¯æ¡†
    function closeModal(modalId) {
      const modal = document.getElementById(modalId);
      const backdrop = document.getElementById(`${modalId}-backdrop`);
      document.body.style.overflow = ""; // æ¢å¤ä¸»ä½“pageé¢æ»šåŠ¨

      if (modal && backdrop) {
        modal.style.display = "none";
        backdrop.style.display = "none";
      }
    }

    // Closeæ‰€æœ‰å¯¹è¯æ¡†
    function closeAllModals() {
      const modals = document.querySelectorAll(".modal");
      const backdrops = document.querySelectorAll(".modal-backdrop");
      document.body.style.overflow = ""; // æ¢å¤ä¸»ä½“pageé¢æ»šåŠ¨

      modals.forEach((modal) => {
        modal.style.display = "none";
      });

      backdrops.forEach((backdrop) => {
        backdrop.style.display = "none";
      });
    }

    // è·å–Proxyåˆ—è¡¨
    async function getProxies() {
      try {
        const data = await makeAuthenticatedRequest("/proxies/get");
        if (data) {
          // ä»Proxyå¯¹è±¡ä¸­æå–ProxyNameåˆ—è¡¨
          proxyList = Object.keys(data.proxies || {});
          currentProxy = data.general_proxy || "";
          return true;
        }
      } catch (error) {
        console.error("è·å–Proxyåˆ—è¡¨Failed:", error);
      }
      return false;
    }

    // Showé€šçŸ¥æ¶ˆæ¯
    // Showé€šçŸ¥æ¶ˆæ¯ä¼˜åŒ–Version
    function showToast(message, type = "info", duration = 3000) {
      // è·å–æˆ–åˆ›å»ºé€šçŸ¥å®¹å™¨
      let container = document.getElementById("toast-container");
      if (!container) {
        container = document.createElement("div");
        container.id = "toast-container";
        container.className = "toast-container";
        document.body.appendChild(container);
      }

      // åˆ›å»ºæ–°çš„é€šçŸ¥å…ƒç´ 
      const toast = document.createElement("div");
      toast.className = `toast ${type}`;

      // Addæ–‡æœ¬å®¹å™¨
      toast.innerHTML = `<div class="toast-content">${message}</div>`;

      // Addåˆ°å®¹å™¨
      container.appendChild(toast);

      // å¼ºåˆ¶ä¸€æ¬¡é‡æ’
      void toast.offsetWidth;

      // Showé€šçŸ¥ï¼Œä½¿ç”¨requestAnimationFrameç¡®ä¿å¹³æ»‘è¿‡æ¸¡
      requestAnimationFrame(() => {
        toast.classList.add("show");
      });

      // Settingsè‡ªåŠ¨ç§»é™¤
      setTimeout(() => {
        toast.classList.remove("show");

        // é€šçŸ¥æ¶ˆå¤±åŠ¨ç”»å®Œæˆåç§»é™¤å…ƒç´ 
        setTimeout(() => {
          if (container.contains(toast)) {
            container.removeChild(toast);
          }

          // å¦‚æœæ²¡æœ‰Moreé€šçŸ¥ï¼Œç§»é™¤å®¹å™¨
          if (container.children.length === 0) {
            if (document.body.contains(container)) {
              document.body.removeChild(container);
            }
          }
        }, 400);
      }, duration);

      // é™åˆ¶MaxShowCountï¼Œå¦‚æœè¶…è¿‡åˆ™ç§»é™¤æœ€æ—©çš„
      const maxToasts = 5; // MaxåŒæ—¶Showçš„é€šçŸ¥æ•°
      const toasts = container.querySelectorAll(".toast");
      if (toasts.length > maxToasts) {
        const oldestToast = toasts[0]; // æœ€æ—©çš„é€šçŸ¥
        oldestToast.classList.remove("show");
        setTimeout(() => {
          if (container.contains(oldestToast)) {
            container.removeChild(oldestToast);
          }
        }, 400);
      }
    }

    // æ‰“å¼€ProxySelectå™¨
    function openProxySelector(displayName, token, event) {
      // é˜»æ­¢äº‹ä»¶å†’æ³¡ï¼Œé¿å…è§¦å‘è¡ŒSelect
      event.stopPropagation();

      // æŸ¥æ‰¾tokenå¯¹è±¡ - æ ¼å¼: [index, alias, tokenData]
      const tokenArr = allTokens.find((arr) => {
        const [_, __, tokenData] = arr;
        return tokenData.primary_token === token;
      });
      if (!tokenArr) return;

      const [_, __, tokenData] = tokenArr;

      currentEditingToken = token;

      // Showå½“å‰tokenä¿¡æ¯
      document.getElementById("currentTokenDisplay").textContent =
        displayName;

      // å¡«å……Proxyä¸‹æ‹‰æ¡†
      const proxySelect = document.getElementById("proxySelectDropdown");

      // Clearç°æœ‰é€‰itemsï¼ˆä¿ç•™Pageä¸€"Unspecified"é€‰itemsï¼‰
      while (proxySelect.options.length > 1) {
        proxySelect.remove(1);
      }

      // ä½¿ç”¨å…¬Totalæ–¹æ³•è·å–Proxyä½¿ç”¨ç»Ÿè®¡
      const proxyUsage = getProxyUsageStats();

      // è·å–å½“å‰é€‰ä¸­çš„Proxy
      const currentProxy = tokenData.proxy || "";

      // AddProxyé€‰items
      proxyList.forEach((proxy) => {
        const option = document.createElement("option");
        option.value = proxy;

        // å¦‚æœYeså½“å‰tokenä½¿ç”¨çš„Proxyï¼ŒåŠ ç²—Show
        if (proxy === currentProxy) {
          option.innerHTML = `<strong>${proxy}</strong> (${proxyUsage[proxy] || 0})`;
        } else {
          option.textContent = `${proxy} (${proxyUsage[proxy] || 0})`;
        }

        proxySelect.appendChild(option);
      });

      // Settingså½“å‰é€‰ä¸­çš„Proxy
      proxySelect.value = currentProxy;

      // Showæ¨¡æ€æ¡†
      showModal("proxySelectModal");
    }

    // SaveProxySelect
    async function saveProxySelection() {
      if (!currentEditingToken) return;

      closeModal("proxySelectModal");

      const selectedProxy = document.getElementById(
        "proxySelectDropdown",
      ).value;

      // è·å–tokençš„åˆ«å - æ ¼å¼: [index, alias, tokenData]
      const tokenArr = allTokens.find((arr) => {
        const [_, __, tokenData] = arr;
        return tokenData.primary_token === currentEditingToken;
      });
      const alias = tokenArr ? tokenArr[1] : currentEditingToken; // tokenArr[1] Yes alias

      showToast("æ­£åœ¨UpdateProxySettings...", "info");

      try {
        const data = await makeAuthenticatedRequest("/tokens/proxy/set", {
          body: JSON.stringify({
            aliases: [alias],
            proxy: selectedProxy || null, // ç©ºå­—ç¬¦ä¸²å‘é€nullä»¥æ¸…é™¤Proxy
          }),
        });

        if (data && data.status === "success") {
          showToast(data.message || "ProxySettingsSuccess", "success");
          getTokenInfo(); // RefreshTokenåˆ—è¡¨
        } else {
          showToast("ProxySettingsFailed", "error");
        }
      } catch (error) {
        showToast("ProxySettingsFailed", "error");
      }
    }

    // æŠ½å–ç»Ÿè®¡Proxyä½¿ç”¨Countçš„å…¬Totalæ–¹æ³•
    function getProxyUsageStats() {
      const proxyUsage = {};
      allTokens.forEach((tokenArr) => {
        const [_, __, tokenData] = tokenArr;
        const proxy = tokenData.proxy || "";
        proxyUsage[proxy] = (proxyUsage[proxy] || 0) + 1;
      });
      return proxyUsage;
    }

    // ä¿®æ­£TimezoneSelectå™¨å‡½æ•°
    // æ‰“å¼€TimezoneSelectå™¨
    function openTimezoneSelector() {
      if (selectedTokens.size === 0) {
        showToast("è¯·å…ˆSelectToken", "info");
        return;
      }

      // Settingså½“å‰æ­£åœ¨Editçš„token
      currentEditingToken = [...selectedTokens][0]; // æŸ¥æ‰¾tokenå¯¹è±¡ - æ ¼å¼: [index, alias, tokenData]
      const tokenArr = allTokens.find((arr) => {
        const [_, __, tokenData] = arr;
        return tokenData.primary_token === currentEditingToken;
      });
      if (!tokenArr) return;

      const [_, alias, tokenData] = tokenArr;
      const user = tokenData.user || {};

      // ä½¿ç”¨é‚®ç®±æˆ–è€…tokençš„ç®€çŸ­Show
      const email = user.email || "";
      const displayName =
        email || currentEditingToken.substring(0, 15) + "...";

      // Showå½“å‰é€‰ä¸­çš„TokenCountå’Œè´¦æˆ·ä¿¡æ¯
      let displayText = "";
      if (selectedTokens.size === 1) {
        displayText = displayName;
      } else {
        displayText = `å·²Select ${selectedTokens.size} Token`;
      }
      document.getElementById("timezoneTokenDisplay").textContent =
        displayText;

      // åˆå§‹åŒ–Timezoneåˆ—è¡¨
      initializeTimezoneList();

      // Settingså½“å‰é€‰ä¸­çš„Timezone
      const currentTimezone = tokenData.timezone || "";
      highlightSelectedTimezone(currentTimezone);

      // Showæ¨¡æ€æ¡†
      showModal("timezoneModal");

      // SettingsSearchæ¡†äº‹ä»¶
      document
        .getElementById("timezoneSearchInput")
        .addEventListener("input", searchTimezones);
      document.getElementById("timezoneSearchInput").value = "";

      // Closeå³é”®èœå•
      document.getElementById("contextMenu").style.display = "none";
    }

    // å…¨å±€Timezoneåˆ—è¡¨æ•°ç»„
    let timezoneList = [];

    // åˆå§‹åŒ–Timezoneåˆ—è¡¨
    function initializeTimezoneList() {
      try {
        // å°è¯•ä½¿ç”¨Intl.supportedValuesOfè·å–Timezoneåˆ—è¡¨ï¼ˆç°ä»£æµè§ˆå™¨æ”¯æŒï¼‰
        if (
          typeof Intl !== "undefined" &&
          typeof Intl.supportedValuesOf === "function"
        ) {
          timezoneList = Intl.supportedValuesOf("timeZone");
        } else {
          // å›é€€åˆ°é¢„å®šä¹‰çš„å¸¸ç”¨Timezoneåˆ—è¡¨
          timezoneList = [
            "Africa/Abidjan",
            "Africa/Accra",
            "Africa/Addis_Ababa",
            "Africa/Algiers",
            "Africa/Cairo",
            "Africa/Casablanca",
            "Africa/Johannesburg",
            "Africa/Lagos",
            "Africa/Nairobi",
            "America/Anchorage",
            "America/Argentina/Buenos_Aires",
            "America/Bogota",
            "America/Chicago",
            "America/Denver",
            "America/Los_Angeles",
            "America/Mexico_City",
            "America/New_York",
            "America/Phoenix",
            "America/Sao_Paulo",
            "America/Toronto",
            "Asia/Bangkok",
            "Asia/Dubai",
            "Asia/Hong_Kong",
            "Asia/Jakarta",
            "Asia/Karachi",
            "Asia/Kolkata",
            "Asia/Manila",
            "Asia/Seoul",
            "Asia/Shanghai",
            "Asia/Singapore",
            "Asia/Taipei",
            "Asia/Tehran",
            "Asia/Tokyo",
            "Australia/Melbourne",
            "Australia/Perth",
            "Australia/Sydney",
            "Europe/Amsterdam",
            "Europe/Athens",
            "Europe/Berlin",
            "Europe/Brussels",
            "Europe/Istanbul",
            "Europe/London",
            "Europe/Madrid",
            "Europe/Moscow",
            "Europe/Paris",
            "Europe/Rome",
            "Europe/Stockholm",
            "Pacific/Auckland",
            "Pacific/Honolulu",
            "UTC",
          ];
        }

        renderTimezoneList(timezoneList);
      } catch (error) {
        console.error("è·å–Timezoneåˆ—è¡¨Failed:", error);
        showToast("è·å–Timezoneåˆ—è¡¨Failed", "error");
      }
    }

    // æ¸²æŸ“Timezoneåˆ—è¡¨
    function renderTimezoneList(timezones) {
      const container = document.getElementById("timezoneListContainer");

      // Addä¸€"Unspecified"é€‰items
      let html = `
      <div class="timezone-item" data-timezone="" onclick="selectTimezone('')">
        <span>Unspecified</span>
      </div>
    `;

      // Addå…¶ä»–Timezoneé€‰items
      timezones.forEach((timezone) => {
        html += `
        <div class="timezone-item" data-timezone="${timezone}" onclick="selectTimezone('${timezone}')">
          <span>${timezone}</span>
        </div>
      `;
      });

      container.innerHTML = html;

      // Addæ ·å¼
      const style = document.createElement("style");
      style.textContent = `
      .timezone-item {
        padding: 8px 16px;
        cursor: pointer;
        transition: all var(--transition-fast);
        border-bottom: 1px solid var(--border-color);
      }
      .timezone-item:last-child {
        border-bottom: none;
      }
      .timezone-item:hover {
        background: var(--primary-color-alpha);
      }
      .timezone-item.selected {
        background: var(--primary-color);
        color: white;
      }
    `;
      document.head.appendChild(style);
    }

    // SearchTimezone
    function searchTimezones() {
      const searchTerm = document
        .getElementById("timezoneSearchInput")
        .value.toLowerCase();

      // å¦‚æœSearchè¯ä¸ºç©ºï¼ŒShowæ‰€æœ‰Timezone
      if (!searchTerm) {
        renderTimezoneList(timezoneList);
        return;
      }

      // è¿‡æ»¤åŒ¹é…çš„Timezone
      const filteredTimezones = timezoneList.filter((timezone) =>
        timezone.toLowerCase().includes(searchTerm),
      );

      renderTimezoneList(filteredTimezones);
    }

    // SelectTimezone
    let selectedTimezone = "";
    function selectTimezone(timezone) {
      selectedTimezone = timezone;
      highlightSelectedTimezone(timezone);
    }

    // é«˜äº®Showé€‰ä¸­çš„Timezone
    function highlightSelectedTimezone(timezone) {
      // ç§»é™¤æ‰€æœ‰é€‰ä¸­Status
      const items = document.querySelectorAll(".timezone-item");
      items.forEach((item) => item.classList.remove("selected"));

      // Addé€‰ä¸­Status
      const selectedItem = document.querySelector(
        `.timezone-item[data-timezone="${timezone}"]`,
      );
      if (selectedItem) {
        selectedItem.classList.add("selected");
      }
    }

    // SaveTimezoneSelect
    async function saveTimezoneSelection() {
      if (selectedTokens.size === 0) return;

      closeModal("timezoneModal");

      // è·å–é€‰ä¸­tokençš„åˆ«å - æ ¼å¼: [index, alias, tokenData]
      const aliasesToUpdate = [...selectedTokens].map((token) => {
        const tokenArr = allTokens.find((arr) => {
          const [_, __, tokenData] = arr;
          return tokenData.primary_token === token;
        });
        return tokenArr ? tokenArr[1] : token; // tokenArr[1] Yes alias
      });

      showToast(
        `æ­£åœ¨Update${aliasesToUpdate.length}Tokençš„TimezoneSettings...`,
        "info",
      );

      try {
        const data = await makeAuthenticatedRequest("/tokens/timezone/set", {
          body: JSON.stringify({
            aliases: aliasesToUpdate,
            timezone: selectedTimezone || null, // ç©ºå­—ç¬¦ä¸²å‘é€nullä»¥æ¸…é™¤Timezone
          }),
        });

        if (data && data.status === "success") {
          showToast(data.message || "TimezoneSettingsSuccess", "success");
          getTokenInfo(); // RefreshTokenåˆ—è¡¨
        } else {
          showToast("TimezoneSettingsFailed", "error");
        }
      } catch (error) {
        showToast("TimezoneSettingsFailed", "error");
        console.error("SettingsTimezoneå‡ºé”™:", error);
      }
    }

    // AddUpdateTimezoneFilterä¸‹æ‹‰æ¡†åŠŸèƒ½
    function updateTimezoneFilter() {
      const timezoneFilterSelect = document.getElementById("timezoneFilter");

      // ä¿æŒPageä¸€å’ŒPageäºŒé€‰itemsï¼ˆAllTimezoneå’ŒUnspecified Timezoneï¼‰
      while (timezoneFilterSelect.options.length > 2) {
        timezoneFilterSelect.remove(2);
      }

      // è·å–æ‰€æœ‰ä½¿ç”¨çš„Timezoneå¹¶ç»Ÿè®¡Count
      const timezoneUsage = {};
      allTokens.forEach((tokenArr) => {
        const [_, __, tokenData] = tokenArr;
        const timezone = tokenData.timezone || "";
        if (timezone) {
          // åªç»Ÿè®¡éç©ºTimezone
          timezoneUsage[timezone] = (timezoneUsage[timezone] || 0) + 1;
        }
      });

      // æŒ‰ä½¿UsageSortTimezone
      const sortedTimezones = Object.keys(timezoneUsage).sort(
        (a, b) => timezoneUsage[b] - timezoneUsage[a],
      );

      // AddTimezoneé€‰items
      sortedTimezones.forEach((timezone) => {
        const option = document.createElement("option");
        option.value = timezone;
        option.textContent = `${timezone} (${timezoneUsage[timezone]})`;
        timezoneFilterSelect.appendChild(option);
      });
    }

    // SettingsTokenStatus
    async function setTokenStatus(status) {
      if (selectedTokens.size === 0) {
        showToast("è¯·å…ˆSelectToken", "info");
        return;
      }

      // å°†tokenè½¬æ¢ä¸ºalias - æ ¼å¼: [index, alias, tokenData]
      const aliasesToUpdate = [...selectedTokens].map((token) => {
        const tokenArr = allTokens.find((arr) => {
          const [_, __, tokenData] = arr;
          return tokenData.primary_token === token;
        });
        return tokenArr ? tokenArr[1] : token; // tokenArr[1] Yes alias
      });

      showToast("æ­£åœ¨UpdateTokenStatus...", "info");

      try {
        const result = await makeAuthenticatedRequest("/tokens/status/set", {
          body: JSON.stringify({
            aliases: aliasesToUpdate,
            enabled: status !== "disabled",
          }),
        });

        if (result && result.status === "success") {
          showToast(result.message || "StatusUpdateSuccess", "success");
          getTokenInfo(); // RefreshTokenåˆ—è¡¨
        } else {
          // Showè¯¦ç»†çš„Errorä¿¡æ¯
          const errorMessage =
            result?.error || result?.message || "StatusUpdateFailed";
          showToast(errorMessage, "error");
        }
      } catch (error) {
        // Showè¯¦ç»†çš„Errorä¿¡æ¯
        const errorMessage =
          error.response?.data?.message ||
          error.response?.data?.error ||
          error.message;
        showToast(`StatusUpdateFailed: ${errorMessage}`, "error");
      }

      // Closeä¸Šä¸‹æ–‡èœå•
      document.getElementById("contextMenu").style.display = "none";
      // UpdateStatuså­èœå•
      updateStatusSubmenu();
    }

    // UpdateStatuså­èœå•
    function updateStatusSubmenu() {
      const submenu = document.getElementById("statusSubmenu");
      if (!submenu) return;

      // è·å–é€‰ä¸­çš„tokenå¯¹è±¡ - æ ¼å¼: [index, alias, tokenData]
      const selectedTokenArrs = allTokens.filter((tokenArr) => {
        const [_, __, tokenData] = tokenArr;
        return selectedTokens.has(tokenData.primary_token);
      });
      const selectionSize = selectedTokenArrs.length;

      // è®¡ç®—é€‰ä¸­itemsçš„Statusç»Ÿè®¡
      const selectedStatusStats = {
        enabled: 0,
        disabled: 0,
      };

      selectedTokenArrs.forEach((tokenArr) => {
        const [_, __, tokenData] = tokenArr;
        const status = !tokenData.status.enabled ? "disabled" : "enabled";
        selectedStatusStats[status]++; // å¢åŠ å¯¹åº”Statusçš„è®¡æ•°
      });

      // Update "Enable" é€‰items
      const enabledItem = submenu.querySelector(
        '.context-menu-item[onclick="setTokenStatus(\\"enabled\\")"]',
      );
      if (enabledItem) {
        const enabledCountSpan = enabledItem.querySelector(".status-count");
        if (enabledCountSpan) {
          // Showé€‰ä¸­itemsä¸­Enableçš„Count
          enabledCountSpan.textContent = selectedStatusStats["enabled"];
        }
        // æ£€æŸ¥YesNoæ‰€æœ‰é€‰ä¸­çš„ Token éƒ½å¤„äºEnableStatus
        const isEnabledActive =
          selectionSize > 0 &&
          selectedStatusStats["enabled"] === selectionSize;
        enabledItem.classList.toggle("active", isEnabledActive); // Settingsé€‰ä¸­æ ‡è®°
      }

      // Update "Disable" é€‰items
      const disabledItem = submenu.querySelector(
        '.context-menu-item[onclick="setTokenStatus(\\"disabled\\")"]',
      );
      if (disabledItem) {
        const disabledCountSpan = disabledItem.querySelector(".status-count");
        if (disabledCountSpan) {
          // Showé€‰ä¸­itemsä¸­Disableçš„Count
          disabledCountSpan.textContent = selectedStatusStats["disabled"];
        }
        // æ£€æŸ¥YesNoæ‰€æœ‰é€‰ä¸­çš„ Token éƒ½å¤„äºDisableStatus
        const isDisabledActive =
          selectionSize > 0 &&
          selectedStatusStats["disabled"] === selectionSize;
        disabledItem.classList.toggle("active", isDisabledActive); // Settingsé€‰ä¸­æ ‡è®°
      }

      // Add has-submenu ç±»ä»¥ä¾¿Showç®­å¤´
      const statusMenuEl = document.querySelector(".status-menu");
      if (statusMenuEl) {
        statusMenuEl.classList.add("has-submenu");
      }
    }

    // RenameToken
    function renameToken() {
      if (selectedTokens.size === 0) {
        showToast("è¯·å…ˆSelectToken", "info");
        return;
      }

      if (selectedTokens.size > 1) {
        showToast("ä¸€æ¬¡åªèƒ½Renameä¸€Token", "info");
        return;
      }

      const token = [...selectedTokens][0];
      startRenaming(token);

      // Closeå³é”®èœå•
      document.getElementById("contextMenu").style.display = "none";
    }

    // StartRename
    function startRenaming(token) {
      const row = document.querySelector(`tr[data-token="${token}"]`);
      if (!row) return;

      const tokenCell = row.querySelector("td:first-child");
      if (!tokenCell) return;

      // è·å–å½“å‰åˆ«å - æ ¼å¼: [index, alias, tokenData]
      const tokenArr = allTokens.find((arr) => {
        const [_, __, tokenData] = arr;
        return tokenData.primary_token === token;
      });
      if (!tokenArr) return;

      const [index, currentAlias, tokenData] = tokenArr;
      const user = tokenData.user || {};
      const displayName =
        currentAlias || user.email || token.substring(0, 15) + "...";

      // SaveåŸå§‹å†…å®¹
      const originalContent = tokenCell.innerHTML;

      // åˆ›å»ºè¾“å…¥æ¡†
      const input = document.createElement("input");
      input.type = "text";
      input.className = "inline-edit";
      input.value = currentAlias || "";
      input.placeholder = user.email || "è¾“å…¥åˆ«å";

      // Clearå•å…ƒæ ¼å¹¶Addè¾“å…¥æ¡†
      tokenCell.innerHTML = "";
      tokenCell.appendChild(input);

      // èšç„¦å¹¶é€‰ä¸­æ–‡æœ¬
      input.focus();
      input.select();

      // SaveEdit
      const saveEdit = async () => {
        const newAlias = input.value.trim();

        // æ¢å¤åŸå§‹å†…å®¹
        tokenCell.innerHTML = originalContent;

        // å¦‚æœåˆ«åæ²¡æœ‰å˜åŒ–ï¼Œç›´æ¥è¿”å›
        if (newAlias === currentAlias) {
          return;
        }

        // è°ƒç”¨APIUpdateåˆ«å
        try {
          showToast("æ­£åœ¨Updateåˆ«å...", "info");

          const requestBody = {};
          requestBody[currentAlias || token] = newAlias;

          const data = await makeAuthenticatedRequest("/tokens/alias/set", {
            body: JSON.stringify(requestBody),
          });

          if (data && data.status === "success") {
            showToast("åˆ«åUpdateSuccess", "success");
            getTokenInfo(); // RefreshTokenåˆ—è¡¨
          } else {
            showToast("åˆ«åUpdateFailed", "error");
          }
        } catch (error) {
          showToast("åˆ«åUpdateFailed: " + error.message, "error");
        }
      };

      // CancelEdit
      const cancelEdit = () => {
        tokenCell.innerHTML = originalContent;
      };

      // ç›‘å¬é”®ç›˜äº‹ä»¶
      input.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          saveEdit();
        } else if (e.key === "Escape") {
          e.preventDefault();
          cancelEdit();
        }
      });

      // å¤±å»ç„¦ç‚¹æ—¶Save
      input.addEventListener("blur", saveEdit);
    }

    // Refreshé€‰ä¸­çš„Token
    async function upgradeSelectedTokens() {
      if (selectedTokens.size === 0) {
        showToast("è¯·å…ˆSelectè¦Refreshçš„Token", "info");
        return;
      }

      // å°†tokenè½¬æ¢ä¸ºalias - æ ¼å¼: [index, alias, tokenData]
      const aliasesToUpgrade = [...selectedTokens].map((token) => {
        const tokenArr = allTokens.find((arr) => {
          const [_, __, tokenData] = arr;
          return tokenData.primary_token === token;
        });
        return tokenArr ? tokenArr[1] : token; // tokenArr[1] Yes alias
      });

      showToast(`æ­£åœ¨Refresh ${aliasesToUpgrade.length} Token...`, "info");

      // Closeå³é”®èœå•
      document.getElementById("contextMenu").style.display = "none";

      try {
        const data = await makeAuthenticatedRequest("/tokens/refresh", {
          body: JSON.stringify(aliasesToUpgrade),
        });

        if (data && data.status === "success") {
          showToast(data.message || "RefreshSuccess", "success");
          getTokenInfo();
        } else {
          showToast(
            "RefreshFailed: " + (data.message || data.error || "æœªçŸ¥Error"),
            "error",
          );
        }
      } catch (error) {
        const errorMessage =
          error.response?.data?.message ||
          error.response?.data?.error ||
          error.message;
        showToast(`RefreshFailed: ${errorMessage}`, "error");
      }
    }
  </script>
</body>

</html>