<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/x-icon" href="data:image/x-icon;," />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Request Log Viewer</title>
  <!-- Include shared styles -->
  <link rel="stylesheet" href="/static/shared-styles.css" />
  <script src="/static/shared.js"></script>
  <style>
    /* Filter panel styles */
    .filter-panel {
      background: var(--card-background);
      padding: 20px;
      border-radius: var(--border-radius);
      margin-bottom: var(--spacing);
      border: 1px solid var(--border-color);
    }

    .filter-section {
      margin-bottom: 20px;
      padding-bottom: 20px;
      border-bottom: 1px solid var(--border-color);
    }

    .filter-section:last-child {
      margin-bottom: 0;
      padding-bottom: 0;
      border-bottom: none;
    }

    .filter-section h3 {
      margin: 0 0 15px 0;
      color: var(--primary-color);
      font-size: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .filter-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
    }

    .filter-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .filter-group label {
      font-size: 13px;
      color: var(--text-secondary);
    }

    .filter-group input[type="datetime-local"],
    .filter-group input[type="text"],
    .filter-group input[type="number"],
    .filter-group select {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid var(--border-color);
      border-radius: var(--border-radius);
      background: var(--card-background);
      color: var(--text-primary);
      font-size: 14px;
    }

    .filter-group input:focus,
    .filter-group select:focus {
      border-color: var(--primary-color);
      outline: none;
    }

    .range-input {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .range-input input {
      flex: 1;
    }

    .filter-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
    }

    /* Create correct stacking context */
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: var(--spacing);
    }

    .stat-card {
      background: var(--card-background);
      padding: 20px;
      border-radius: var(--border-radius);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
      transition: all var(--transition-fast);
      border: 1px solid var(--border-color);
    }

    .stat-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
    }

    .stat-card h4 {
      margin: 0 0 8px 0;
      color: var(--primary-color);
    }

    .stat-value {
      font-size: 28px;
      font-weight: 600;
      color: var(--primary-color);
      margin-top: 4px;
    }

    .refresh-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .auto-refresh {
      display: flex;
      align-items: center;
      gap: 8px;
      background: var(--card-background);
      padding: 8px 16px;
      border-radius: var(--border-radius);
      border: 1px solid var(--border-color);
    }

    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.4);
      overflow-y: hidden;
    }

    .modal-content {
      background-color: var(--card-background);
      margin: 5% auto;
      padding: 20px;
      border-radius: var(--border-radius);
      width: 90%;
      max-width: 800px;
      max-height: 85vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      border: 1px solid var(--border-color);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
    }

    .modal-header {
      position: sticky;
      top: 0;
      background: var(--card-background);
      z-index: 10;
      padding-bottom: 15px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px;
    }

    .modal-header h3 {
      margin: 0;
      flex-grow: 1;
    }

    #conversation-content-container {
      flex: 1;
      overflow-y: auto;
      margin: 0 -20px;
      padding: 20px;
    }

    .close {
      font-size: 24px;
      font-weight: bold;
      cursor: pointer;
      padding: 5px 10px;
    }

    .close:hover {
      color: var(--primary-color);
    }

    .info-button {
      padding: 6px 12px;
      font-size: 14px;
      border-radius: var(--border-radius);
      transition: all var(--transition-fast);
      background: var(--primary-color-alpha);
      color: var(--primary-color);
      border: 1px solid var(--primary-color);
    }

    .info-button:hover {
      background: var(--primary-color);
      color: white;
    }

    .message-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
      margin: 0;
      border: 1px solid var(--border-color);
    }

    .message-table th,
    .message-table td {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border-color);
      transition: background-color var(--transition-fast);
    }

    .message-table td {
      word-break: break-word;
    }

    .message-table td:nth-child(2) {
      max-width: 600px;
    }

    .message-table td:first-child {
      width: 80px;
      white-space: nowrap;
    }

    .usage-progress-container {
      margin: 16px 0;
      height: 8px;
      background-color: var(--border-color);
      border-radius: 4px;
      overflow: hidden;
    }

    .usage-progress-bar {
      height: 100%;
      width: 0%;
      transition: width 0.3s ease;
      background-color: var(--primary-color);
      border-radius: 4px;
    }

    .usage-progress-bar.low {
      background-color: #4caf50;
    }

    .usage-progress-bar.medium {
      background-color: #ff9800;
    }

    .usage-progress-bar.high {
      background-color: #f44336;
    }

    /* Token info and conversation preview common styles */
    .token-info-tooltip {
      position: relative;
      display: inline-block;
    }

    .token-info-tooltip .tooltip-content {
      visibility: hidden;
      position: absolute;
      z-index: 1002;
      background-color: var(--card-background);
      color: var(--text-primary);
      padding: 12px 15px;
      border-radius: var(--border-radius);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
      width: 280px;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(100% + 8px);
      opacity: 0;
      transition:
        opacity 0.3s,
        visibility 0.3s;
      text-align: left;
      line-height: 1.6;
      border: 1px solid var(--border-color);
      pointer-events: none;
    }

    .token-info-tooltip:hover .tooltip-content {
      visibility: visible;
      opacity: 1;
    }

    .token-info-tooltip .tooltip-content::after {
      content: "";
      position: absolute;
      top: 100%;
      left: 50%;
      margin-left: -8px;
      border-width: 8px;
      border-style: solid;
      border-color: var(--card-background) transparent transparent transparent;
    }

    .token-info-tooltip::after {
      content: "";
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 100%;
      width: 100%;
      height: 10px;
      background: transparent;
    }

    .token-info-tooltip .tooltip-info-row {
      display: flex;
      justify-content: space-between;
      margin: 2px 0;
    }

    .token-info-tooltip .tooltip-info-row .label {
      color: var(--text-secondary);
      margin-right: 10px;
    }

    .token-info-tooltip .tooltip-info-row .value {
      font-weight: 500;
      word-break: break-word;
    }

    .token-info-container {
      flex: 1;
      overflow-y: auto;
      margin: 0 -20px;
      padding: 20px;
    }

    /* Conversation preview specific styles */
    .prompt-preview .tooltip-content {
      width: 320px;
      max-height: 200px;
      overflow-y: auto;
      overflow-x: hidden;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .prompt-preview .tooltip-content .message-meta {
      font-size: 0.8em;
      color: var(--text-secondary);
      padding: 0;
      margin: 0 0 4px 0;
    }

    .prompt-preview .tooltip-content .last-message {
      font-size: 0.9em;
      line-height: 1.5;
      color: var(--text-primary);
      margin: 0;
      padding: 0;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .prompt-preview .tooltip-content::-webkit-scrollbar {
      width: 6px;
    }

    .prompt-preview .tooltip-content::-webkit-scrollbar-thumb {
      background-color: var(--border-color);
      border-radius: 3px;
    }

    .prompt-preview .tooltip-content::-webkit-scrollbar-track {
      background-color: var(--card-background);
    }

    /* Optimized table styles */
    .table-container {
      border-radius: var(--border-radius);
      overflow: hidden;
      border: 1px solid var(--border-color);
    }

    #logsTable {
      position: relative;
      z-index: 1;
    }

    #logsTable th {
      position: sticky;
      top: 0;
      z-index: 2;
      background: var(--primary-color);
      white-space: nowrap;
      transition: background-color 0.2s ease;
    }

    #logsTable td {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border-color);
      transition: background-color var(--transition-fast);
    }

    #logsTable tr:hover td {
      background-color: var(--hover-color, rgba(0, 0, 0, 0.02));
    }

    .modal-actions {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .danger-button {
      padding: 6px 12px;
      font-size: 14px;
      border-radius: var(--border-radius);
      background: var(--error-color-alpha);
      color: var(--error-color);
      border: 1px solid var(--error-color);
      cursor: pointer;
      transition: all var(--transition-fast);
      margin-right: 8px;
    }

    .danger-button:hover {
      background: var(--error-color);
      color: white;
    }

    .warning-button {
      padding: 6px 12px;
      font-size: 14px;
      border-radius: var(--border-radius);
      background: rgba(255, 193, 7, 0.1);
      color: #e8a400;
      border: 1px solid #e8a400;
      cursor: pointer;
      transition: all var(--transition-fast);
      margin-right: 8px;
    }

    .warning-button:hover {
      background: #e8a400;
      color: white;
    }

    .success-button {
      padding: 6px 12px;
      font-size: 14px;
      border-radius: var(--border-radius);
      background: rgba(76, 175, 80, 0.1);
      color: #4caf50;
      border: 1px solid #4caf50;
      cursor: pointer;
      transition: all var(--transition-fast);
      margin-right: 8px;
    }

    .success-button:hover {
      background: #4caf50;
      color: white;
    }

    /* Chart styles */
    .chart-container {
      background: var(--card-background);
      padding: 20px;
      border-radius: var(--border-radius);
      margin-bottom: var(--spacing);
      border: 1px solid var(--border-color);
      height: 300px;
    }

    /* Add menu toggle styles */
    .tab-menu {
      display: flex;
      margin-bottom: 15px;
    }

    .tab-button {
      padding: 8px 16px;
      background: var(--card-background);
      color: var(--text-secondary);
      border: 1px solid var(--border-color);
      cursor: pointer;
      transition: all var(--transition-fast);
      font-size: 14px;
    }

    .tab-button:first-child {
      border-radius: var(--border-radius) 0 0 var(--border-radius);
    }

    .tab-button:last-child {
      border-radius: 0 var(--border-radius) var(--border-radius) 0;
    }

    .tab-button.active {
      background: var(--primary-color);
      color: white;
      border-color: var(--primary-color);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .delay-chart-container {
      height: 200px;
      margin-bottom: 20px;
    }

    .delay-table-container {
      max-height: none;
      overflow-y: visible;
    }

    .pagination-container {
      margin-top: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .pagination-info {
      flex: 1;
    }

    .pagination-controls {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .page-jumper {
      display: flex;
      align-items: center;
      gap: 5px;
      margin-left: 15px;
    }

    .page-input {
      width: 60px;
      padding: 5px;
      border-radius: var(--border-radius);
      border: 1px solid var(--border-color);
      text-align: center;
    }

    .page-input:focus {
      border-color: var(--primary-color);
      outline: none;
    }

    .page-go-btn {
      padding: 5px 10px;
      border-radius: var(--border-radius);
      border: 1px solid var(--border-color);
      background: var(--card-background);
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .page-go-btn:hover {
      background: var(--primary-color);
      color: white;
      border-color: var(--primary-color);
    }

    /* Responsive styles */
    @media (max-width: 768px) {
      .filter-grid {
        grid-template-columns: 1fr;
      }

      .stats-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
      }

      .stat-card {
        padding: 16px;
      }

      .stat-value {
        font-size: 24px;
      }

      .modal-content {
        margin: 2% auto;
        width: 95%;
        padding: 16px;
      }

      .chart-container {
        height: 200px;
        padding: 16px;
      }

      .modal-header {
        flex-direction: column;
        align-items: flex-start;
      }

      .tab-menu {
        width: 100%;
      }

      .tab-button {
        flex: 1;
      }
    }
  </style>
</head>

<body>
  <h1>Request Log Viewer</h1>

  <div class="container">
    <div class="form-group">
      <label>Authentication Token:</label>
      <input type="password" id="authToken" placeholder="Enter AUTH_TOKEN" />
    </div>

    <!-- New filter panel -->
    <div class="filter-panel">
      <!-- TimeRangeFilter -->
      <div class="filter-section">
        <h3>ðŸ“… TimeRange</h3>
        <div class="filter-grid">
          <div class="filter-group">
            <label for="fromDate">StartTime</label>
            <input type="datetime-local" id="fromDate" />
          </div>
          <div class="filter-group">
            <label for="toDate">EndTime</label>
            <input type="datetime-local" id="toDate" />
          </div>
        </div>
        <div style="margin-top: 10px">
          <label style="
              display: block;
              margin-bottom: 5px;
              font-size: 13px;
              color: var(--text-secondary);
            ">Quick Select</label>
          <div class="button-group" style="justify-content: flex-start">
            <button onclick="setTimeRange('1h')" style="padding: 6px 12px; font-size: 14px">
              Last 1 Hour
            </button>
            <button onclick="setTimeRange('24h')" style="padding: 6px 12px; font-size: 14px">
              Last 24 Hours
            </button>
            <button onclick="setTimeRange('7d')" style="padding: 6px 12px; font-size: 14px">
              Last 7 Days
            </button>
            <button onclick="setTimeRange('30d')" style="padding: 6px 12px; font-size: 14px">
              Last 30 Days
            </button>
          </div>
        </div>
      </div>

      <!-- User filter -->
      <div class="filter-section">
        <h3>ðŸ‘¤ User Filter</h3>
        <div class="filter-grid">
          <div class="filter-group">
            <label for="userId">User ID</label>
            <input type="text" id="userId" placeholder="Exact match User ID" />
          </div>
          <div class="filter-group">
            <label for="email">Email</label>
            <input type="text" id="email" placeholder="Supports partial match" />
          </div>
          <div class="filter-group">
            <label for="membershipType">Membership Type</label>
            <select id="membershipType">
              <option value="">All</option>
              <option value="free">Free</option>
              <option value="free_trial">Trial</option>
              <option value="pro">Pro</option>
              <option value="enterprise">Enterprise</option>
            </select>
          </div>
        </div>
      </div>

      <!-- Model filter -->
      <div class="filter-section">
        <h3>ðŸ¤– Model Filter</h3>
        <div class="filter-grid">
          <div class="filter-group">
            <label for="model">Model Name</label>
            <input type="text" id="model" placeholder="Supports partial match" />
          </div>
          <div class="filter-group">
            <label for="includeModels">Include Models</label>
            <input type="text" id="includeModels" placeholder="Comma separated, e.g.: gpt-4,claude" />
          </div>
          <div class="filter-group">
            <label for="excludeModels">Exclude Models</label>
            <input type="text" id="excludeModels" placeholder="Comma separated, e.g.: gpt-3.5,dall-e" />
          </div>
        </div>
      </div>

      <!-- Performance filter -->
      <div class="filter-section">
        <h3>ðŸ“Š Performance Filter</h3>
        <div class="filter-grid">
          <div class="filter-group">
            <label>Duration Range (seconds)</label>
            <div class="range-input">
              <input type="number" id="minTotalTime" placeholder="Min" step="0.1" min="0" />
              <span>~</span>
              <input type="number" id="maxTotalTime" placeholder="Max" step="0.1" min="0" />
            </div>
          </div>
          <div class="filter-group">
            <label>Tokens Range</label>
            <div class="range-input">
              <input type="number" id="minTokens" placeholder="Min" min="0" />
              <span>~</span>
              <input type="number" id="maxTokens" placeholder="Max" min="0" />
            </div>
          </div>
        </div>
      </div>

      <!-- Other options -->
      <div class="filter-section">
        <h3>ðŸ”§ Other Options</h3>
        <div class="filter-grid">
          <div class="filter-group">
            <label for="status">Status</label>
            <select id="status">
              <option value="">All</option>
              <option value="pending">Processing</option>
              <option value="success">Success</option>
              <option value="failure">Failed</option>
            </select>
          </div>
          <div class="filter-group">
            <label for="stream">Stream Response</label>
            <select id="stream">
              <option value="">All</option>
              <option value="true">Yes</option>
              <option value="false">No</option>
            </select>
          </div>
          <div class="filter-group">
            <label for="hasError">Has Error</label>
            <select id="hasError">
              <option value="">All</option>
              <option value="true">Yes</option>
              <option value="false">No</option>
            </select>
          </div>
          <div class="filter-group">
            <label for="hasChain">Has Conversation</label>
            <select id="hasChain">
              <option value="">All</option>
              <option value="true">Yes</option>
              <option value="false">No</option>
            </select>
          </div>
          <div class="filter-group">
            <label for="hasUsage">Has Usage</label>
            <select id="hasUsage">
              <option value="">All</option>
              <option value="true">Yes</option>
              <option value="false">No</option>
            </select>
          </div>
          <div class="filter-group">
            <label for="reverse">Sort Order</label>
            <select id="reverse">
              <option value="false">Oldest First</option>
              <option value="true" selected>Newest First</option>
            </select>
          </div>
          <div class="filter-group">
            <label for="pageSize">Per Page</label>
            <select id="pageSize">
              <option value="10">10 records</option>
              <option value="20" selected>20 records</option>
              <option value="50">50 records</option>
              <option value="100">100 records</option>
            </select>
          </div>
          <div class="filter-group">
            <label for="errorText">Error Message</label>
            <input type="text" id="errorText" placeholder="Supports partial match" />
          </div>
        </div>
      </div>

      <!-- Filter action buttons -->
      <div class="filter-actions">
        <button onclick="resetFilters()">Reset</button>
        <button onclick="applyFilters()">Apply Filter</button>
      </div>
    </div>

    <div class="refresh-container">
      <div class="button-group">
        <button onclick="fetchLogs()">Refresh Logs</button>
        <button onclick="exportLogs()" style="margin-left: 10px">
          Export Data
        </button>
      </div>
      <div class="auto-refresh">
        <input type="checkbox" id="autoRefresh" checked />
        <label for="autoRefresh">Auto Refresh (60 seconds)</label>
      </div>
    </div>
  </div>

  <div class="container">
    <div class="stats-grid">
      <div class="stat-card">
        <h4>Total Requests</h4>
        <div id="totalRequests" class="stat-value">-</div>
      </div>
      <div class="stat-card">
        <h4>Successful Requests</h4>
        <div id="successRequests" class="stat-value">-</div>
      </div>
      <div class="stat-card">
        <h4>Failed Requests</h4>
        <div id="failureRequests" class="stat-value">-</div>
      </div>
      <div class="stat-card">
        <h4>Last Update</h4>
        <div id="lastUpdate" class="stat-value">-</div>
      </div>
    </div>

    <!-- Add chart container -->
    <div class="chart-container">
      <canvas id="requestsChart"></canvas>
    </div>

    <div class="table-container">
      <table id="logsTable">
        <thead>
          <tr>
            <th>ID</th>
            <th>Time</th>
            <th>Model</th>
            <th>Token Info</th>
            <th>Conversation</th>
            <th>Duration</th>
            <th>Input/Output</th>
            <th>Stream</th>
            <th>Status</th>
            <th>Error Message</th>
          </tr>
        </thead>
        <tbody id="logsBody"></tbody>
      </table>
    </div>

    <!-- Pagination controls -->
    <div class="pagination-container">
      <div class="pagination-info">
        Total <span id="totalRecords">0</span> records, per page
        <input type="number" id="customPageSize" class="page-input" min="5" max="100" value="20" />
        records
        <button class="page-go-btn" onclick="changePageSize()">Apply</button>
      </div>
      <div class="pagination-controls">
        <button id="prevPage" onclick="changePage(-1)" disabled>
          &laquo; Previous
        </button>
        <span id="currentPage">Page 1</span>
        <button id="nextPage" onclick="changePage(1)" disabled>
          Next &raquo;
        </button>
        <div class="page-jumper">
          Go to page
          <input type="number" id="pageNumberInput" class="page-input" min="1" value="1" />
          <button class="page-go-btn" onclick="jumpToPage()">GO</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Token details modal -->
  <div id="tokenModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Token Details</h3>
        <span class="close">&times;</span>
      </div>
      <div class="token-info-container">
        <table class="message-table">
          <tbody>
            <tr>
              <td>Token</td>
              <td id="modalToken">-</td>
            </tr>
            <tr>
              <td>Checksum</td>
              <td id="modalChecksum">-</td>
            </tr>
            <tr>
              <td>Client Key</td>
              <td id="modalClientKey">-</td>
            </tr>
            <tr>
              <td>Config Version</td>
              <td id="modalConfigVersion">-</td>
            </tr>
            <tr>
              <td>Session ID</td>
              <td id="modalSessionId">-</td>
            </tr>
            <tr>
              <td>Proxy</td>
              <td id="modalProxy">-</td>
            </tr>
            <tr>
              <td>Timezone</td>
              <td id="modalTimezone">-</td>
            </tr>
            <tr>
              <td>Email</td>
              <td id="modalEmail">-</td>
            </tr>
            <tr>
              <td>Name</td>
              <td id="modalName">-</td>
            </tr>
            <tr>
              <td>Updated At</td>
              <td id="modalUpdatedAt">-</td>
            </tr>
            <tr>
              <td>Member Type</td>
              <td id="modalMemberType">-</td>
            </tr>
            <tr>
              <td>Payment ID</td>
              <td id="modalPaymentId">-</td>
            </tr>
            <tr>
              <td>Trial Days</td>
              <td id="modalTrialDays">-</td>
            </tr>
          </tbody>
        </table>
        <div id="usageProgressContainer"></div>
      </div>
    </div>
  </div>

  <!-- Conversation details modal -->
  <div id="conversationModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Conversation Details</h3>
        <div class="tab-menu">
          <button id="tab-prompt" class="tab-button active">Conversation Content</button>
          <button id="tab-think" class="tab-button">Thinking Process</button>
          <button id="tab-delays" class="tab-button">Delay Analysis</button>
        </div>
        <span class="close">&times;</span>
      </div>
      <div id="conversation-content-container">
        <div id="dialogContent" class="tab-content active"></div>
        <div id="thinkContent" class="tab-content">
          <pre id="thinkText"></pre>
        </div>
        <div id="delaysContent" class="tab-content">
          <div class="delay-chart-container">
            <canvas id="delayChart"></canvas>
          </div>
          <div class="delay-table-container">
            <table id="delaysTable" class="message-table">
              <thead>
                <tr>
                  <th>ID</th>
                  <th>Text Block</th>
                  <th>Delay Time(s)</th>
                  <th>Rate(chars/seconds)</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Include Chart.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.5.0/chart.umd.min.js"
    integrity="sha512-Y51n9mtKTVBh3Jbx5pZSJNDDMyY+yGe77DGtBPzRlgsf/YLCh13kSZ3JmfHGzYFCmOndraf0sQgfM654b7dJ3w=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script>
    // Global variables
    let currentPageIndex = 0;
    let pageSize = 20;
    let totalRecords = 0;
    let currentFilters = {};
    let refreshInterval = null;
    let requestsChart = null;

    // Initialize variables
    let currentTokenDetails = {};

    // Token info cache
    let tokenInfoCache = {};
    let allTokensLoaded = false; // Flag whether all token info has been loaded

    // Update statistics
    function updateStats(data) {
      // Calculate various statistics
      const totalRequests = data.total || 0;
      const successRequests = data.logs.filter(
        (log) => log.status === "success",
      ).length;
      const failureRequests = data.logs.filter(
        (log) => log.status === "failure",
      ).length;

      // Update statistics cards
      document.getElementById("totalRequests").textContent =
        totalRequests.toLocaleString();
      document.getElementById("successRequests").textContent =
        successRequests.toLocaleString();
      document.getElementById("failureRequests").textContent =
        failureRequests.toLocaleString();
      document.getElementById("lastUpdate").textContent =
        new Date().toLocaleTimeString("zh-CN");
    }

    // Show token details modal
    async function showTokenModal(tokenInfo) {
      const modal = document.getElementById("tokenModal");

      // If key exists, get detailed info from cache first
      if (tokenInfo.key && tokenInfoCache[tokenInfo.key]) {
        // Use cached data
        tokenInfo = { ...tokenInfo, ...tokenInfoCache[tokenInfo.key] };
      }

      // Set basic info
      document.getElementById("modalToken").textContent =
        tokenInfo.primary_token || "-";

      // Handle checksum
      if (tokenInfo.checksum) {
        document.getElementById("modalChecksum").textContent = `${tokenInfo.checksum.first || "-"
          } / ${tokenInfo.checksum.second || "-"}`;
      } else {
        document.getElementById("modalChecksum").textContent = "-";
      }

      // Set other fields
      document.getElementById("modalClientKey").textContent =
        tokenInfo.client_key || "-";
      document.getElementById("modalConfigVersion").textContent =
        tokenInfo.config_version || "-";
      document.getElementById("modalSessionId").textContent =
        tokenInfo.session_id || "-";
      document.getElementById("modalProxy").textContent =
        tokenInfo.proxy || "-";
      document.getElementById("modalTimezone").textContent =
        tokenInfo.timezone || "-";

      // Handle user info
      if (tokenInfo.user) {
        document.getElementById("modalEmail").textContent =
          tokenInfo.user.email || "-";
        document.getElementById("modalName").textContent =
          tokenInfo.user.name || "-";
        document.getElementById("modalUpdatedAt").textContent = tokenInfo.user
          .updated_at
          ? new Date(tokenInfo.user.updated_at).toLocaleString()
          : "-";
      } else {
        document.getElementById("modalEmail").textContent = "-";
        document.getElementById("modalName").textContent = "-";
        document.getElementById("modalUpdatedAt").textContent = "-";
      }

      // Handle Stripe info
      if (tokenInfo.stripe) {
        document.getElementById("modalMemberType").textContent =
          formatMembershipType(tokenInfo.stripe.membership_type);
        document.getElementById("modalPaymentId").textContent =
          tokenInfo.stripe.payment_id || "-";
        document.getElementById("modalTrialDays").textContent =
          tokenInfo.stripe.days_remaining_on_trial > 0
            ? `${tokenInfo.stripe.days_remaining_on_trial} days`
            : "-";
      } else {
        document.getElementById("modalMemberType").textContent = "-";
        document.getElementById("modalPaymentId").textContent = "-";
        document.getElementById("modalTrialDays").textContent = "-";
      }

      // Handle usage info
      const container = document.getElementById("usageProgressContainer");
      container.innerHTML = "";

      if (tokenInfo.usage) {
        const models = {
          Premium: tokenInfo.usage.premium,
          Standard: tokenInfo.usage.standard,
        };

        Object.entries(models).forEach(([modelName, modelData]) => {
          if (modelData) {
            const div = document.createElement("div");
            div.style.marginTop = "10px";

            const label = document.createElement("strong");
            label.textContent = `${modelName} Usage: `;
            div.appendChild(label);

            const text = document.createElement("span");
            if (modelData.max_requests) {
              const percentage = (
                (modelData.num_requests / modelData.max_requests) *
                100
              ).toFixed(1);
              text.textContent = `${modelData.num_requests}/${modelData.max_requests} Request (${percentage}%), ${modelData.num_tokens} tokens`;

              const progressDiv = document.createElement("div");
              progressDiv.className = "usage-progress-container";
              const colorClass =
                percentage < 50 ? "low" : percentage < 80 ? "medium" : "high";
              progressDiv.innerHTML = `<div class="usage-progress-bar ${colorClass}" style="width: ${percentage}%"></div>`;
              div.appendChild(text);
              div.appendChild(progressDiv);
            } else {
              text.textContent = `${modelData.num_requests} Request, ${modelData.num_tokens} tokens`;
              div.appendChild(text);
            }

            container.appendChild(div);
          }
        });
      }

      modal.style.display = "block";
    }

    // Format simple token info for tooltip
    function formatSimpleTokenInfo(tokenInfo) {
      if (!tokenInfo) return "No Token Info";

      // If key exists, get full info from cache first
      let fullTokenInfo = tokenInfo;
      if (tokenInfo.key && tokenInfoCache[tokenInfo.key]) {
        fullTokenInfo = { ...tokenInfo, ...tokenInfoCache[tokenInfo.key] };
      }

      const rows = [];

      if (fullTokenInfo.key) {
        rows.push(["Key", fullTokenInfo.key]);
      }

      if (fullTokenInfo.user) {
        rows.push(["Email", fullTokenInfo.user.email || "-"]);
        if (fullTokenInfo.user.name) {
          rows.push(["Username", fullTokenInfo.user.name]);
        }
      }

      if (fullTokenInfo.stripe) {
        rows.push([
          "Membership Type",
          formatMembershipType(fullTokenInfo.stripe.membership_type),
        ]);
      }

      if (fullTokenInfo.usage?.premium) {
        const premium = fullTokenInfo.usage.premium;
        const usage = premium.max_requests
          ? `${premium.num_requests}/${premium.max_requests}`
          : `${premium.num_requests}`;
        rows.push(["Premium Usage", usage]);
      }

      if (rows.length === 0) {
        return "No detailed info";
      }

      return rows
        .map(
          ([label, value]) =>
            `<div class="tooltip-info-row"><span class="label">${label}:</span><span class="value">${value}</span></div>`,
        )
        .join("");
    }

    // Set time range quick select
    function setTimeRange(range) {
      const now = new Date();
      const toDate = now.toISOString().slice(0, 16); // YYYY-MM-DDTHH:mm
      let fromDate;

      switch (range) {
        case "1h":
          fromDate = new Date(now - 60 * 60 * 1000)
            .toISOString()
            .slice(0, 16);
          break;
        case "24h":
          fromDate = new Date(now - 24 * 60 * 60 * 1000)
            .toISOString()
            .slice(0, 16);
          break;
        case "7d":
          fromDate = new Date(now - 7 * 24 * 60 * 60 * 1000)
            .toISOString()
            .slice(0, 16);
          break;
        case "30d":
          fromDate = new Date(now - 30 * 24 * 60 * 60 * 1000)
            .toISOString()
            .slice(0, 16);
          break;
      }

      document.getElementById("fromDate").value = fromDate;
      document.getElementById("toDate").value = toDate;

      // Auto apply filter
      applyFilters();
    }

    function initChart() {
      const ctx = document.getElementById("requestsChart").getContext("2d");
      requestsChart = new Chart(ctx, {
        type: "line",
        data: {
          labels: [],
          datasets: [
            {
              label: "Requests per hour",
              data: [],
              borderColor: "rgb(75, 192, 192)",
              tension: 0.1,
              fill: false,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                stepSize: 10,
              },
            },
          },
          plugins: {
            title: {
              display: true,
              text: "24-hour request statistics",
            },
          },
        },
      });
    }

    // Update chart data
    function updateChart(data) {
      if (!requestsChart) {
        initChart();
      }

      // Count requests by hour
      const hourlyStats = new Map();
      const now = new Date();
      const past24Hours = new Date(now - 24 * 60 * 60 * 1000);

      // Initialize 24-hour time periods
      for (let i = 0; i < 24; i++) {
        const hour = new Date(now - i * 60 * 60 * 1000);
        const hourKey = hour.toLocaleString("zh-CN", {
          month: "numeric",
          day: "numeric",
          hour: "numeric",
        });
        hourlyStats.set(hourKey, 0);
      }

      // Count requests per hour
      data.logs.forEach((log) => {
        const logTime = new Date(log.timestamp);
        if (logTime >= past24Hours) {
          const hourKey = logTime.toLocaleString("zh-CN", {
            month: "numeric",
            day: "numeric",
            hour: "numeric",
          });
          if (hourlyStats.has(hourKey)) {
            hourlyStats.set(hourKey, hourlyStats.get(hourKey) + 1);
          }
        }
      });

      // Convert to chart data
      const sortedHours = Array.from(hourlyStats.keys()).reverse();
      const counts = sortedHours.map((hour) => hourlyStats.get(hour));

      requestsChart.data.labels = sortedHours;
      requestsChart.data.datasets[0].data = counts;
      requestsChart.update();
    }

    async function updateTable(data) {
      const tbody = document.getElementById("logsBody");
      updateStats(data);
      updateChart(data);

      // Update total records and pagination info
      totalRecords = data.total;
      document.getElementById("totalRecords").textContent = totalRecords;
      updatePaginationControls();

      // Collect all token keys
      const tokenKeys = new Set();
      data.logs.forEach((log) => {
        if (log.token_info && log.token_info.key) {
          tokenKeys.add(log.token_info.key);
        }
      });

      // If all token info hasn't been loaded yet, load and wait for completion
      if (!allTokensLoaded && tokenKeys.size > 0) {
        await loadAllTokenInfo(Array.from(tokenKeys));
      }

      tbody.innerHTML = data.logs
        .map((log) => {
          // Prepare data attributes
          let attributes = {};

          // Handle prompt attribute
          if (log.chain && typeof log.chain.prompt === "string") {
            try {
              const promptJson = JSON.stringify(log.chain.prompt);
              const escapedPrompt = escapeHtml(promptJson);
              attributes.prompt = `data-prompt='${escapedPrompt}'`;
            } catch (e) {
              console.error(
                "Failed to process prompt data:",
                e,
                log.chain.prompt,
              );
            }
          }

          // Handle think attribute
          if (log.chain && typeof log.chain.think === "string") {
            try {
              const thinkJson = JSON.stringify(log.chain.think);
              const escapedThink = escapeHtml(thinkJson);
              attributes.think = `data-think='${escapedThink}'`;
            } catch (e) {
              console.error(
                "Failed to process think data:",
                e,
                log.chain.think,
              );
            }
          }

          // Handle delays attribute
          if (
            log.chain &&
            Array.isArray(log.chain.delays) &&
            log.chain.delays.length === 2 &&
            typeof log.chain.delays[0] === "string" &&
            Array.isArray(log.chain.delays[1])
          ) {
            try {
              const delaysJson = JSON.stringify(log.chain.delays);
              const escapedDelays = escapeHtml(delaysJson);
              attributes.delays = `data-delays='${escapedDelays}'`;
            } catch (e) {
              console.error(
                "Failed to stringify delays data:",
                e,
                log.chain.delays,
              );
            }
          }

          // Combine all attributes
          const allAttributes = Object.values(attributes).join(" ");

          return `<tr>
    <td>${log.id}</td>
    <td>${new Date(log.timestamp).toLocaleString()}</td>
    <td>${log.model}</td>
    <td><div class="token-info-tooltip"><button class="info-button" onclick='showTokenModal(${JSON.stringify(
            log.token_info,
          )})'>View Details<div class="tooltip-content">${formatSimpleTokenInfo(
            log.token_info,
          )}</div></button></div></td>
    <td>${log.chain
              ? `<div class="token-info-tooltip prompt-preview"><button class="info-button view-conversation" ${allAttributes}>View Conversation<div class="tooltip-content">${formatDialogPreview(
                JSON.stringify(log.chain.prompt || ""),
              )}</div></button></div>`
              : "-"
            }</td>
    <td>${formatTiming(log.timing.total)}</td>
    <td>${formatUsage(log.chain?.usage)}</td>
    <td>${log.stream ? "Yes" : "No"}</td>
    <td>${log.status}</td>
    <td>${typeof log.error === "string" ? log.error : (log.error?.error ?? "-")
            }</td>
  </tr>`;
        })
        .join("");

      // Add event listeners
      tbody.querySelectorAll(".view-conversation").forEach((button) => {
        button.addEventListener("click", function () {
          const prompt = this.hasAttribute("data-prompt")
            ? JSON.parse(this.dataset.prompt)
            : "";
          const think = this.hasAttribute("data-think")
            ? JSON.parse(this.dataset.think)
            : "";
          const delays = this.hasAttribute("data-delays")
            ? JSON.parse(this.dataset.delays)
            : [];

          showConversationModal(prompt, think, delays);
        });
      });
    }

    function formatTiming(total) {
      return `${total.toFixed(2)}s`;
    }

    function formatDialogPreview(promptStr) {
      try {
        const messages = parsePrompt(promptStr);
        if (!messages || messages.length === 0) {
          return "No conversation content";
        }

        // Get the last message
        const lastMessage = messages[messages.length - 1];
        const roleLabels = {
          system: "System",
          user: "User",
          assistant: "Assistant",
        };

        return `<div class="message-meta">Last message (${roleLabels[lastMessage.role] || lastMessage.role
          }):</div><div class="last-message">${lastMessage.content
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/\n/g, "<br>")}</div>`;
      } catch (e) {
        console.error("Preview conversation content failed:", e);
        return "Unable to parse conversation content";
      }
    }

    // Update pagination controls status
    function updatePaginationControls() {
      const prevPageBtn = document.getElementById("prevPage");
      const nextPageBtn = document.getElementById("nextPage");
      const currentPageSpan = document.getElementById("currentPage");
      const pageNumberInput = document.getElementById("pageNumberInput");
      const customPageSize = document.getElementById("customPageSize");

      // Calculate total pages
      const totalPages = Math.ceil(totalRecords / pageSize) || 1;

      // Disable or enable previous page button
      prevPageBtn.disabled = currentPageIndex <= 0;

      // Disable or enable next page button (if current page is last page or not enough records)
      const hasMorePages = (currentPageIndex + 1) * pageSize < totalRecords;
      nextPageBtn.disabled = !hasMorePages;

      // Update current page display
      currentPageSpan.textContent = `Page ${currentPageIndex + 1
        } / Total ${totalPages} pages`;

      // Sync input values
      pageNumberInput.value = currentPageIndex + 1;
      pageNumberInput.max = totalPages;
      customPageSize.value = pageSize;
    }

    // Change page
    function changePage(delta) {
      currentPageIndex += delta;
      if (currentPageIndex < 0) currentPageIndex = 0;

      fetchLogs();
    }

    // Jump to specified page
    function jumpToPage() {
      const pageNumberInput = document.getElementById("pageNumberInput");
      const pageNumber = parseInt(pageNumberInput.value);
      const totalPages = Math.ceil(totalRecords / pageSize) || 1;

      if (isNaN(pageNumber) || pageNumber < 1) {
        showGlobalMessage("Please enter a valid page number", true);
        pageNumberInput.value = currentPageIndex + 1;
        return;
      }

      if (pageNumber > totalPages) {
        showGlobalMessage(`Page number out of range, max page is ${totalPages}`, true);
        pageNumberInput.value = totalPages;
        return;
      }

      currentPageIndex = pageNumber - 1;
      fetchLogs();
    }

    // Change per page display count
    function changePageSize() {
      const customPageSize = document.getElementById("customPageSize");
      const newPageSize = parseInt(customPageSize.value);

      if (isNaN(newPageSize) || newPageSize < 5 || newPageSize > 100) {
        showGlobalMessage("Per page count must be between 5-100", true);
        customPageSize.value = pageSize;
        return;
      }

      // Reset to first page and use new page size
      currentPageIndex = 0;
      pageSize = newPageSize;
      fetchLogs();
    }

    // Get time range filter
    function getTimeRangeFilter() {
      const fromDate = document.getElementById("fromDate").value;
      const toDate = document.getElementById("toDate").value;

      const filter = {};

      if (fromDate) {
        // Convert to RFC3339 format
        filter.from_date = new Date(fromDate).toISOString();
      }

      if (toDate) {
        filter.to_date = new Date(toDate).toISOString();
      }

      return filter;
    }

    // Get user filter
    function getUserFilter() {
      const filter = {};

      const userId = document.getElementById("userId").value.trim();
      if (userId) filter.user_id = userId;

      const email = document.getElementById("email").value.trim();
      if (email) filter.email = email;

      const membership = document.getElementById("membershipType").value;
      if (membership) filter.membership_type = membership;

      return filter;
    }

    // Get model filter
    function getModelFilter() {
      const filter = {};

      const model = document.getElementById("model").value.trim();
      if (model) filter.model = model;

      const includeModels = document
        .getElementById("includeModels")
        .value.trim();
      if (includeModels) {
        filter.include_models = includeModels
          .split(",")
          .map((m) => m.trim())
          .filter((m) => m);
      }

      const excludeModels = document
        .getElementById("excludeModels")
        .value.trim();
      if (excludeModels) {
        filter.exclude_models = excludeModels
          .split(",")
          .map((m) => m.trim())
          .filter((m) => m);
      }

      return filter;
    }

    // Get performance filter
    function getPerformanceFilter() {
      const filter = {};

      const minTime = parseFloat(
        document.getElementById("minTotalTime").value,
      );
      if (!isNaN(minTime)) filter.min_total_time = minTime;

      const maxTime = parseFloat(
        document.getElementById("maxTotalTime").value,
      );
      if (!isNaN(maxTime)) filter.max_total_time = maxTime;

      const minTokens = parseInt(document.getElementById("minTokens").value);
      if (!isNaN(minTokens)) filter.min_tokens = minTokens;

      const maxTokens = parseInt(document.getElementById("maxTokens").value);
      if (!isNaN(maxTokens)) filter.max_tokens = maxTokens;

      return filter;
    }

    // Get other filters
    function getOtherFilters() {
      const filter = {};

      const status = document.getElementById("status").value;
      if (status) filter.status = status;

      const stream = document.getElementById("stream").value;
      if (stream) filter.stream = stream === "true";

      const hasError = document.getElementById("hasError").value;
      if (hasError) filter.has_error = hasError === "true";

      const hasChain = document.getElementById("hasChain").value;
      if (hasChain) filter.has_chain = hasChain === "true";

      const hasUsage = document.getElementById("hasUsage").value;
      if (hasUsage) filter.has_usage = hasUsage === "true";

      const error = document.getElementById("errorText").value.trim();
      if (error) filter.error = error;

      return filter;
    }

    // Apply filter conditions
    function applyFilters() {
      // Reset to first page
      currentPageIndex = 0;

      // Update per page count
      const pageSizeSelect = document.getElementById("pageSize");
      if (pageSizeSelect) {
        pageSize = parseInt(pageSizeSelect.value);
        // Sync custom input
        document.getElementById("customPageSize").value = pageSize;
      }

      // Get filtered data
      fetchLogs();
    }

    // Reset filter conditions
    function resetFilters() {
      // Reset all input fields
      document.getElementById("fromDate").value = "";
      document.getElementById("toDate").value = "";
      document.getElementById("userId").value = "";
      document.getElementById("email").value = "";
      document.getElementById("membershipType").value = "";
      document.getElementById("model").value = "";
      document.getElementById("includeModels").value = "";
      document.getElementById("excludeModels").value = "";
      document.getElementById("minTotalTime").value = "";
      document.getElementById("maxTotalTime").value = "";
      document.getElementById("minTokens").value = "";
      document.getElementById("maxTokens").value = "";
      document.getElementById("status").value = "";
      document.getElementById("stream").value = "";
      document.getElementById("hasError").value = "";
      document.getElementById("hasChain").value = "";
      document.getElementById("hasUsage").value = "";
      document.getElementById("reverse").value = "false";
      document.getElementById("pageSize").value = "20";
      document.getElementById("errorText").value = "";

      // Reset page number
      currentPageIndex = 0;
      pageSize = 20;

      // Refresh data
      fetchLogs();
    }

    async function fetchLogs() {
      // Build query parameters
      const query = {
        // Pagination parameters
        limit: pageSize,
        offset: currentPageIndex * pageSize,
        reverse: document.getElementById("reverse").value === "true",

        // Time range
        ...getTimeRangeFilter(),

        // User filter
        ...getUserFilter(),

        // Model filter
        ...getModelFilter(),

        // Performance filter
        ...getPerformanceFilter(),

        // Other filters
        ...getOtherFilters(),
      };

      // Send request to new API endpoint
      const data = await makeAuthenticatedRequest("/logs/get", {
        body: JSON.stringify({ query }),
      });

      if (data) {
        updateTable(data);
        showGlobalMessage("Logs fetched successfully");
      }
    }

    // Get token details
    async function fetchTokenDetails(tokens) {
      const data = await makeAuthenticatedRequest("/logs/tokens/get", {
        body: JSON.stringify(tokens),
      });

      if (data) {
        return data.tokens;
      }

      return null;
    }

    // Batch load all token info to cache
    async function loadAllTokenInfo(tokenKeys) {
      if (tokenKeys.length === 0) return;

      console.log(`Loading ${tokenKeys.length} token details...`);

      try {
        const detailsData = await fetchTokenDetails(tokenKeys);
        if (detailsData) {
          // Store all token info in cache
          Object.entries(detailsData).forEach(([key, info]) => {
            tokenInfoCache[key] = info;
          });

          allTokensLoaded = true;
          console.log(
            `Successfully loaded ${Object.keys(detailsData).length} token details`,
          );
          showGlobalMessage(
            `Cached ${Object.keys(detailsData).length} Token Info`,
          );
        }
      } catch (error) {
        console.error("Load token info failed:", error);
      }
    }

    // Export log data
    async function exportLogs() {
      // Get all data under current filter conditions
      const query = {
        // No limit, export all data
        limit: 10000,
        offset: 0,
        reverse: document.getElementById("reverse").value === "true",

        // Time range
        ...getTimeRangeFilter(),

        // User filter
        ...getUserFilter(),

        // Model filter
        ...getModelFilter(),

        // Performance filter
        ...getPerformanceFilter(),

        // Other filters
        ...getOtherFilters(),
      };

      const data = await makeAuthenticatedRequest("/logs/get", {
        method: "POST",
        body: JSON.stringify({ query }),
      });

      if (data) {
        // Create CSV format data
        const csvContent = createCSVFromLogs(data.logs);

        // Download CSV file
        const blob = new Blob([csvContent], {
          type: "text/csv;charset=utf-8;",
        });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", `logs_${new Date().toISOString()}.csv`);
        link.style.visibility = "hidden";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        showGlobalMessage(`Successfully exported ${data.logs.length} log records`);
      }
    }

    // Create CSV content
    function createCSVFromLogs(logs) {
      const headers = [
        "ID",
        "Time",
        "Model",
        "Token Key",
        "User Email",
        "Membership Type",
        "Duration(seconds)",
        "Input Tokens",
        "Output Tokens",
        "Stream",
        "Status",
        "Error Message",
      ];

      const rows = logs.map((log) => {
        const tokenInfo = log.token_info || {};
        const stripe = tokenInfo.stripe || {};
        const usage = log.chain?.usage || {};
        const user = tokenInfo.user || {};

        return [
          log.id,
          new Date(log.timestamp).toLocaleString(),
          log.model,
          tokenInfo.key || "-",
          user.email || "-",
          stripe.membership_type || "-",
          log.timing.total.toFixed(2),
          usage.input || 0,
          usage.output || 0,
          log.stream ? "Yes" : "No",
          log.status,
          typeof log.error === "string" ? log.error : log.error?.error || "-",
        ];
      });

      // Convert to CSV format
      const csvRows = [headers, ...rows].map((row) =>
        row.map((cell) => `"${String(cell).replace(/"/g, '""')}"`).join(","),
      );

      return csvRows.join("\n");
    }

    // Auto refresh control
    document
      .getElementById("autoRefresh")
      .addEventListener("change", function (e) {
        if (e.target.checked) {
          refreshInterval = setInterval(fetchLogs, 60000);
        } else {
          clearInterval(refreshInterval);
        }
      });

    // Auto fetch logs after page load
    document.addEventListener("DOMContentLoaded", () => {
      const authToken = getAuthToken();
      if (authToken) {
        document.getElementById("authToken").value = authToken;

        // Set default page size
        pageSize = parseInt(
          document.getElementById("pageSize").value || "20",
        );
        document.getElementById("customPageSize").value = pageSize;

        fetchLogs();
      }
      // Start auto refresh
      refreshInterval = setInterval(fetchLogs, 60000);

      // Add page number input enter key support
      document
        .getElementById("pageNumberInput")
        .addEventListener("keyup", function (event) {
          if (event.key === "Enter") {
            jumpToPage();
          }
        });

      // Add page size input enter key support
      document
        .getElementById("customPageSize")
        .addEventListener("keyup", function (event) {
          if (event.key === "Enter") {
            changePageSize();
          }
        });
    });

    // Initialize token handling
    initializeTokenHandling("authToken");

    // Add cleanup logic
    window.addEventListener("beforeunload", () => {
      if (refreshInterval) {
        clearInterval(refreshInterval);
      }
    });

    // Add modal close logic
    document.querySelectorAll(".modal .close").forEach((closeBtn) => {
      closeBtn.onclick = function () {
        this.closest(".modal").style.display = "none";
      };
    });

    window.onclick = function (event) {
      if (event.target.classList.contains("modal")) {
        event.target.style.display = "none";
      }
    };

    /**
     * Parse conversation content
     * @param {string} promptStr - Original prompt string
     * @returns {Array<{role: string, content: string}>} Parsed conversation array
     */
    function parsePrompt(promptStr) {
      if (!promptStr) return [];

      // Try to parse JSON format prompt
      try {
        const parsed = JSON.parse(promptStr);

        // If already parsed format
        if (Array.isArray(parsed)) {
          return parsed.map((msg) => ({
            role: msg.role,
            content: msg.content,
          }));
        }
      } catch (e) {
        // If JSON parsing failed, it's raw string format, use original parsing logic
      }

      const messages = [];
      const lines = promptStr.split("\n");
      let currentRole = "";
      let currentContent = "";

      const roleMap = {
        BEGIN_SYSTEM: "system",
        BEGIN_USER: "user",
        BEGIN_ASSISTANT: "assistant",
      };

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];

        // Check if it's a role marker line
        let foundRole = false;
        for (const [marker, role] of Object.entries(roleMap)) {
          if (line.includes(marker)) {
            // Save previous message (if any)
            if (currentRole && currentContent.trim()) {
              messages.push({
                role: currentRole,
                content: currentContent.trim(),
              });
            }
            // Set new role
            currentRole = role;
            currentContent = "";
            foundRole = true;
            break;
          }
        }

        // If not a role marker line and not an END marker line, add to current content
        if (!foundRole && !line.includes("END_")) {
          currentContent += line + "\n";
        }
      }

      // Add last message
      if (currentRole && currentContent.trim()) {
        messages.push({
          role: currentRole,
          content: currentContent.trim(),
        });
      }

      return messages;
    }

    function escapeHtml(content) {
      // First escape HTML special chars
      const escaped = content
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
      return escaped;
    }

    function escapeHtmlAndControlChars(content) {
      // First escape HTML special chars
      let escaped = content
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");

      // Then escape control chars
      escaped = escaped
        .replace(/\\/g, "\\\\")
        .replace(/\n/g, "\\n")
        .replace(/\t/g, "\\t")
        .replace(/\r/g, "\\r");

      return escaped;
    }

    /**
     * Format conversation content to HTML table
     * @param {Array<{role: string, content: string}>} messages - Conversation message array
     * @returns {string} HTML table string
     */
    function formatPromptToTable(messages) {
      if (!messages || messages.length === 0) {
        return "<p>No conversation content</p>";
      }

      const roleLabels = {
        system: "System",
        user: "User",
        assistant: "Assistant",
      };

      return `<table class="message-table"><thead><tr><th>Role</th><th>Content</th></tr></thead><tbody>${messages
        .map(
          (msg) =>
            `<tr><td>${roleLabels[msg.role] || msg.role}</td><td>${escapeHtml(
              msg.content,
            ).replace(/\n/g, "<br>")}</td></tr>`,
        )
        .join("")}</tbody></table>`;
    }

    /**
     * Show conversation details popup
     * @param {string} promptStr - Conversation prompt string
     * @param {string} thinkStr - Thinking process string
     * @param {Array} delaysTuple - Delay data array
     */
    function showConversationModal(promptStr, thinkStr, delaysTuple) {
      try {
        const modal = document.getElementById("conversationModal");
        const dialogContent = document.getElementById("dialogContent");
        const thinkContent = document.getElementById("thinkContent");
        const delaysContent = document.getElementById("delaysContent");
        const tabPrompt = document.getElementById("tab-prompt");
        const tabThink = document.getElementById("tab-think");
        const tabDelays = document.getElementById("tab-delays");
        const delaysTableBody = document.querySelector("#delaysTable tbody");
        const delayChartContainer = document.querySelector(
          ".delay-chart-container",
        );

        if (
          !modal ||
          !dialogContent ||
          !thinkContent ||
          !delaysContent ||
          !tabPrompt ||
          !tabThink ||
          !tabDelays ||
          !delaysTableBody ||
          !delayChartContainer
        ) {
          console.error("Modal elements not found");
          return;
        }

        // Handle Prompt
        try {
          const messages = parsePrompt(promptStr);
          dialogContent.innerHTML = formatPromptToTable(messages);
        } catch (e) {
          console.error("Parse prompt data failed:", e);
          dialogContent.innerHTML = "<p>Unable to load conversation content.</p>";
        }

        // Handle thinking process
        if (thinkStr && typeof thinkStr === "string") {
          document.getElementById("thinkText").textContent = thinkStr;
          tabThink.style.display = "";
        } else {
          document.getElementById("thinkText").textContent = "No thinking process";
          tabThink.style.display = "none";
        }

        // Handle delays
        delaysTableBody.innerHTML = "";
        delayChartContainer.innerHTML = '<canvas id="delayChart"></canvas>';

        let fullText = "";
        let delayPoints = [];
        let chartDataPoints = [{ time: 0, chars: 0, text: "" }];

        if (delaysTuple) {
          if (
            Array.isArray(delaysTuple) &&
            delaysTuple.length === 2 &&
            typeof delaysTuple[0] === "string" &&
            Array.isArray(delaysTuple[1])
          ) {
            fullText = delaysTuple[0];
            delayPoints = delaysTuple[1];
          } else {
            console.warn("Delays data format is incorrect:", delaysTuple);
          }
        }

        if (delayPoints.length > 0) {
          const textChars = Array.from(fullText);
          let currentIndex = 0;
          let totalChars = 0;
          let totalTime = 0;

          delayPoints.forEach(([length, deltaTime], index) => {
            if (
              typeof length !== "number" ||
              typeof deltaTime !== "number" ||
              length < 0 ||
              deltaTime < 0
            ) {
              console.warn(
                `Skipping invalid delay point at index ${index}:`,
                [length, deltaTime],
              );
              return;
            }

            const chunkChars = textChars.slice(currentIndex, currentIndex + length);
            const chunkText = chunkChars.join('');
            currentIndex += length;
            totalChars += length;
            totalTime += deltaTime;

            const rate = deltaTime > 0 ? length / deltaTime : Infinity;
            const avgRate = totalTime > 0 ? totalChars / totalTime : Infinity;

            const row = document.createElement("tr");
            row.innerHTML = `
            <td>${index + 1}</td>
            <td>${escapeHtmlAndControlChars(chunkText)}</td>
            <td>${deltaTime.toFixed(3)}</td>
            <td>${isFinite(rate) ? rate.toFixed(1) : "N/A"} (Average: ${isFinite(avgRate) ? avgRate.toFixed(1) : "N/A"
              })</td>
          `;
            delaysTableBody.appendChild(row);

            chartDataPoints.push({
              time: totalTime,
              chars: totalChars,
              text: chunkText,
            });
          });

          initDelayChart(chartDataPoints);
          tabDelays.style.display = "";
        } else {
          delaysTableBody.innerHTML =
            '<tr><td colspan="4">No delay data</td></tr>';
          delayChartContainer.innerHTML =
            '<div style="text-align: center; padding: 20px;">No delay data available for analysis</div>';
          tabDelays.style.display = "none";
        }

        // Set tab pages
        tabPrompt.onclick = () => setActiveTab("prompt");
        tabThink.onclick = () => setActiveTab("think");
        tabDelays.onclick = () => setActiveTab("delays");

        setActiveTab("prompt");
        modal.style.display = "block";
      } catch (e) {
        console.error("Show conversation details failed:", e);
      }
    }

    /**
     * Set current active tab page
     * @param {string} tabName - Tab page name ('prompt' or 'delays')
     */
    function setActiveTab(tabName) {
      const dialogContent = document.getElementById("dialogContent");
      const thinkContent = document.getElementById("thinkContent");
      const delaysContent = document.getElementById("delaysContent");
      const tabPrompt = document.getElementById("tab-prompt");
      const tabThink = document.getElementById("tab-think");
      const tabDelays = document.getElementById("tab-delays");

      if (
        !dialogContent ||
        !thinkContent ||
        !delaysContent ||
        !tabPrompt ||
        !tabThink ||
        !tabDelays
      ) {
        console.error("Tab elements not found");
        return;
      }

      if (tabName === "prompt") {
        dialogContent.classList.add("active");
        thinkContent.classList.remove("active");
        delaysContent.classList.remove("active");
        tabPrompt.classList.add("active");
        tabThink.classList.remove("active");
        tabDelays.classList.remove("active");
      } else if (tabName === "think") {
        dialogContent.classList.remove("active");
        thinkContent.classList.add("active");
        delaysContent.classList.remove("active");
        tabPrompt.classList.remove("active");
        tabThink.classList.add("active");
        tabDelays.classList.remove("active");
      } else {
        dialogContent.classList.remove("active");
        thinkContent.classList.remove("active");
        delaysContent.classList.add("active");
        tabPrompt.classList.remove("active");
        tabThink.classList.remove("active");
        tabDelays.classList.add("active");
      }
    }

    /**
     * Initialize delay chart
     * @param {Array<{time: number, chars: number, text: string}>} chartDataPoints - Data points array containing cumulative time, char count and block text
     */
    function initDelayChart(chartDataPoints) {
      if (!chartDataPoints || chartDataPoints.length <= 1) {
        const container = document.querySelector(".delay-chart-container");
        if (container) {
          container.innerHTML =
            '<div style="text-align: center; padding: 20px;">Insufficient delay data, unable to draw chart</div>';
        }
        return;
      }

      const ctx = document.getElementById("delayChart");
      if (!ctx) {
        console.error("Cannot find chart canvas element");
        return;
      }

      const existingChart = Chart.getChart(ctx);
      if (existingChart) {
        existingChart.destroy();
      }

      const maxPoints = 100;
      let sampledPoints = chartDataPoints;

      if (chartDataPoints.length > maxPoints) {
        sampledPoints = [];
        const interval = (chartDataPoints.length - 2) / (maxPoints - 2);

        sampledPoints.push(chartDataPoints[0]);

        for (let i = 1; i < maxPoints - 1; i++) {
          const rawIndex = Math.round(i * interval);
          const actualIndex = Math.min(
            rawIndex + 1,
            chartDataPoints.length - 2,
          );
          sampledPoints.push(chartDataPoints[actualIndex]);
        }

        sampledPoints.push(chartDataPoints[chartDataPoints.length - 1]);
      }

      new Chart(ctx, {
        type: "line",
        data: {
          datasets: [
            {
              label: "Cumulative output chars",
              data: sampledPoints.map((point) => ({
                x: point.time,
                y: point.chars,
              })),
              borderColor: "rgb(75,192,192)",
              backgroundColor: "rgba(75,192,192,0.2)",
              tension: 0.1,
              fill: true,
              pointRadius: 3,
              pointHoverRadius: 5,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: "Character output progress",
            },
            tooltip: {
              callbacks: {
                title: function (context) {
                  const pointIndex = context[0].dataIndex;
                  if (pointIndex < sampledPoints.length) {
                    return `Duration: ${sampledPoints[pointIndex].time.toFixed(
                      1,
                    )} seconds`;
                  }
                  return "";
                },
                label: function (context) {
                  const pointIndex = context.dataIndex;
                  if (pointIndex < sampledPoints.length) {
                    const point = sampledPoints[pointIndex];
                    const prevPoint =
                      pointIndex > 0
                        ? sampledPoints[pointIndex - 1]
                        : { time: 0, chars: 0, text: "" };

                    const deltaTime = point.time - prevPoint.time;
                    const deltaChars = point.chars - prevPoint.chars;
                    const currentRate =
                      deltaTime > 0
                        ? (deltaChars / deltaTime).toFixed(1)
                        : "N/A";
                    const avgRate =
                      point.time > 0
                        ? (point.chars / point.time).toFixed(1)
                        : "N/A";

                    const chunkText = point.text || "";

                    return [
                      `Cumulative chars: ${point.chars}`,
                      `Average rate: ${avgRate} chars/second`,
                      `Current block rate: ${currentRate} chars/second`,
                      `Current block text: ${escapeHtmlAndControlChars(
                        chunkText.length > 50
                          ? chunkText.substring(0, 50) + "..."
                          : chunkText,
                      )}`,
                    ];
                  }
                  return "";
                },
              },
            },
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: "Cumulative chars",
              },
            },
            x: {
              type: "linear",
              beginAtZero: true,
              title: {
                display: true,
                text: "Cumulative duration (seconds)",
              },
              ticks: {
                callback: function (value) {
                  return value.toFixed(1) + "s";
                },
              },
            },
          },
        },
      });
    }

    /**
     * Format usage info
     * @param {Object} usage - Usage object { input: number, output: number }
     * @returns {string} Formatted string
     */
    function formatUsage(usage) {
      if (!usage) return "-";
      return `${usage.input} / ${usage.output}`;
    }
  </script>
</body>

</html>