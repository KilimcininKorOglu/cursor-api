// This file is @generated by pbuild.
/// .aiserver.v1.CursorPosition
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct CursorPosition {
    #[serde(default)]
    pub line: i32,
    #[serde(default)]
    pub column: i32,
}
impl ::prost::Message for CursorPosition {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.line) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.line, buf) }
        if !::proto_value::is_default(&self.column) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.column, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::int32::merge(wire_type, &mut self.line, buf, ctx).map_err(|mut error| { error.push("CursorPosition", "line"); error }),
            2 => ::prost::encoding::int32::merge(wire_type, &mut self.column, buf, ctx).map_err(|mut error| { error.push("CursorPosition", "column"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.line) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.line) }
        if !::proto_value::is_default(&self.column) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.column) }
        len
    }
    fn clear(&mut self) {
        self.line = 0i32;
        self.column = 0i32;
    }
}
/// .aiserver.v1.EnvironmentInfo
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash)]
pub struct EnvironmentInfo {
    pub exthost_platform: ::core::option::Option<::byte_str::ByteStr>,
    pub exthost_arch: ::core::option::Option<::byte_str::ByteStr>,
    pub local_timestamp: ::alloc::string::String,
    pub cursor_version: ::bytes::Bytes,
}
impl ::prost::Message for EnvironmentInfo {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if let ::core::option::Option::Some(ref value) = self.exthost_platform { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.exthost_arch { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value, buf) }
        if !::proto_value::is_default(&self.local_timestamp) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, &self.local_timestamp, buf) }
        if !::proto_value::is_default(&self.cursor_version) { ::prost::encoding::bytes::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(7) }, &self.cursor_version, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => if let ::core::option::Option::Some(ref mut value) = self.exthost_platform { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.exthost_platform = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("EnvironmentInfo", "exthost_platform"); error }),
            2 => if let ::core::option::Option::Some(ref mut value) = self.exthost_arch { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.exthost_arch = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("EnvironmentInfo", "exthost_arch"); error }),
            5 => ::prost::encoding::string::merge(wire_type, &mut self.local_timestamp, buf, ctx).map_err(|mut error| { error.push("EnvironmentInfo", "local_timestamp"); error }),
            7 => ::prost::encoding::bytes::merge(wire_type, &mut self.cursor_version, buf, ctx).map_err(|mut error| { error.push("EnvironmentInfo", "cursor_version"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if let ::core::option::Option::Some(ref value) = self.exthost_platform { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, value) }
        if let ::core::option::Option::Some(ref value) = self.exthost_arch { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value) }
        if !::proto_value::is_default(&self.local_timestamp) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, &self.local_timestamp) }
        if !::proto_value::is_default(&self.cursor_version) { len += ::prost::encoding::bytes::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(7) }, &self.cursor_version) }
        len
    }
    fn clear(&mut self) {
        self.exthost_platform = ::core::option::Option::None;
        self.exthost_arch = ::core::option::Option::None;
        self.local_timestamp.clear();
        self.cursor_version.clear();
    }
}
/// .aiserver.v1.SimplestRange
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct SimplestRange {
    #[serde(default)]
    pub start_line: i32,
    #[serde(default)]
    pub end_line_inclusive: i32,
}
impl ::prost::Message for SimplestRange {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.start_line) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.start_line, buf) }
        if !::proto_value::is_default(&self.end_line_inclusive) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.end_line_inclusive, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::int32::merge(wire_type, &mut self.start_line, buf, ctx).map_err(|mut error| { error.push("SimplestRange", "start_line"); error }),
            2 => ::prost::encoding::int32::merge(wire_type, &mut self.end_line_inclusive, buf, ctx).map_err(|mut error| { error.push("SimplestRange", "end_line_inclusive"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.start_line) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.start_line) }
        if !::proto_value::is_default(&self.end_line_inclusive) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.end_line_inclusive) }
        len
    }
    fn clear(&mut self) {
        self.start_line = 0i32;
        self.end_line_inclusive = 0i32;
    }
}
/// .aiserver.v1.SimpleRange
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct SimpleRange {
    #[serde(default)]
    pub start_line_number: i32,
    #[serde(default)]
    pub start_column: i32,
    #[serde(default)]
    pub end_line_number_inclusive: i32,
    #[serde(default)]
    pub end_column: i32,
}
impl ::prost::Message for SimpleRange {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.start_line_number) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.start_line_number, buf) }
        if !::proto_value::is_default(&self.start_column) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.start_column, buf) }
        if !::proto_value::is_default(&self.end_line_number_inclusive) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.end_line_number_inclusive, buf) }
        if !::proto_value::is_default(&self.end_column) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.end_column, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::int32::merge(wire_type, &mut self.start_line_number, buf, ctx).map_err(|mut error| { error.push("SimpleRange", "start_line_number"); error }),
            2 => ::prost::encoding::int32::merge(wire_type, &mut self.start_column, buf, ctx).map_err(|mut error| { error.push("SimpleRange", "start_column"); error }),
            3 => ::prost::encoding::int32::merge(wire_type, &mut self.end_line_number_inclusive, buf, ctx).map_err(|mut error| { error.push("SimpleRange", "end_line_number_inclusive"); error }),
            4 => ::prost::encoding::int32::merge(wire_type, &mut self.end_column, buf, ctx).map_err(|mut error| { error.push("SimpleRange", "end_column"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.start_line_number) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.start_line_number) }
        if !::proto_value::is_default(&self.start_column) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.start_column) }
        if !::proto_value::is_default(&self.end_line_number_inclusive) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.end_line_number_inclusive) }
        if !::proto_value::is_default(&self.end_column) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.end_column) }
        len
    }
    fn clear(&mut self) {
        self.start_line_number = 0i32;
        self.start_column = 0i32;
        self.end_line_number_inclusive = 0i32;
        self.end_column = 0i32;
    }
}
/// .aiserver.v1.LineRange
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash, ::serde::Serialize, ::serde::Deserialize)]
pub struct LineRange {
    #[serde(skip_serializing_if = "::proto_value::is_default", default)]
    pub start_line_number: i32,
    #[serde(skip_serializing_if = "::proto_value::is_default", default)]
    pub end_line_number_inclusive: i32,
}
impl ::prost::Message for LineRange {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.start_line_number) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.start_line_number, buf) }
        if !::proto_value::is_default(&self.end_line_number_inclusive) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.end_line_number_inclusive, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::int32::merge(wire_type, &mut self.start_line_number, buf, ctx).map_err(|mut error| { error.push("LineRange", "start_line_number"); error }),
            2 => ::prost::encoding::int32::merge(wire_type, &mut self.end_line_number_inclusive, buf, ctx).map_err(|mut error| { error.push("LineRange", "end_line_number_inclusive"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.start_line_number) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.start_line_number) }
        if !::proto_value::is_default(&self.end_line_number_inclusive) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.end_line_number_inclusive) }
        len
    }
    fn clear(&mut self) {
        self.start_line_number = 0i32;
        self.end_line_number_inclusive = 0i32;
    }
}
/// .aiserver.v1.CursorRange
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct CursorRange {
    #[serde(default)]
    pub start_position: ::core::option::Option<CursorPosition>,
    #[serde(default)]
    pub end_position: ::core::option::Option<CursorPosition>,
}
impl ::prost::Message for CursorRange {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if let ::core::option::Option::Some(ref value) = self.start_position { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.end_position { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => if let ::core::option::Option::Some(ref mut value) = self.start_position { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.start_position = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CursorRange", "start_position"); error }),
            2 => if let ::core::option::Option::Some(ref mut value) = self.end_position { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.end_position = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CursorRange", "end_position"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if let ::core::option::Option::Some(ref value) = self.start_position { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, value) }
        if let ::core::option::Option::Some(ref value) = self.end_position { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value) }
        len
    }
    fn clear(&mut self) {
        self.start_position = ::core::option::Option::None;
        self.end_position = ::core::option::Option::None;
    }
}
/// .aiserver.v1.DetailedLine
#[derive(Debug, Default, Clone, PartialEq, ::serde::Deserialize)]
pub struct DetailedLine {
    #[serde(default)]
    pub text: ::alloc::string::String,
    #[serde(default)]
    pub line_number: f32,
    #[serde(default)]
    pub is_signature: bool,
}
impl ::prost::Message for DetailedLine {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.text) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.text, buf) }
        if !::proto_value::is_default(&self.line_number) { ::prost::encoding::float::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.line_number, buf) }
        if !::proto_value::is_default(&self.is_signature) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.is_signature, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.text, buf, ctx).map_err(|mut error| { error.push("DetailedLine", "text"); error }),
            2 => ::prost::encoding::float::merge(wire_type, &mut self.line_number, buf, ctx).map_err(|mut error| { error.push("DetailedLine", "line_number"); error }),
            3 => ::prost::encoding::bool::merge(wire_type, &mut self.is_signature, buf, ctx).map_err(|mut error| { error.push("DetailedLine", "is_signature"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.text) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.text) }
        if !::proto_value::is_default(&self.line_number) { len += ::prost::encoding::float::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.line_number) }
        if !::proto_value::is_default(&self.is_signature) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.is_signature) }
        len
    }
    fn clear(&mut self) {
        self.text.clear();
        self.line_number = 0.0f32;
        self.is_signature = false;
    }
}
/// Nested message and enum types in [`CodeBlock`].
pub mod code_block {
    /// .aiserver.v1.CodeBlock.Signatures
    #[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Deserialize)]
    pub struct Signatures {
        #[serde(default)]
        pub ranges: ::alloc::vec::Vec<super::CursorRange>,
    }
    impl ::prost::Message for Signatures {
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) { if !::alloc::vec::Vec::is_empty(&self.ranges) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.ranges, buf) }         }
        fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
            match number.get() {
                1 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.ranges, buf, ctx).map_err(|mut error| { error.push("Signatures", "ranges"); error }),
                _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
            }
        }
        fn encoded_len(&self) -> usize { if !::alloc::vec::Vec::is_empty(&self.ranges) { ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.ranges) } else { 0 } }
        fn clear(&mut self) { self.ranges.clear() }
    }
}
/// .aiserver.v1.CodeBlock
#[derive(Debug, Default, Clone, PartialEq, ::serde::Deserialize)]
pub struct CodeBlock {
    #[serde(default)]
    pub relative_workspace_path: ::alloc::string::String,
    #[serde(default)]
    pub file_contents: ::core::option::Option<::alloc::string::String>,
    #[serde(default)]
    pub file_contents_length: ::core::option::Option<i32>,
    #[serde(default)]
    pub range: ::core::option::Option<CursorRange>,
    #[serde(default)]
    pub contents: ::alloc::string::String,
    #[serde(default)]
    pub signatures: ::core::option::Option<code_block::Signatures>,
    #[serde(default)]
    pub override_contents: ::core::option::Option<::alloc::string::String>,
    #[serde(default)]
    pub original_contents: ::core::option::Option<::alloc::string::String>,
    #[serde(default)]
    pub detailed_lines: ::alloc::vec::Vec<DetailedLine>,
    #[serde(default)]
    pub file_git_context: ::core::option::Option<FileGit>,
}
impl ::prost::Message for CodeBlock {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.relative_workspace_path) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.relative_workspace_path, buf) }
        if let ::core::option::Option::Some(ref value) = self.file_contents { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.range { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, value, buf) }
        if !::proto_value::is_default(&self.contents) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.contents, buf) }
        if let ::core::option::Option::Some(ref value) = self.signatures { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.override_contents { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(6) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.original_contents { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(7) }, value, buf) }
        if !::alloc::vec::Vec::is_empty(&self.detailed_lines) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(8) }, &self.detailed_lines, buf) }
        if let ::core::option::Option::Some(ref value) = self.file_contents_length { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(9) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.file_git_context { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(10) }, value, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.relative_workspace_path, buf, ctx).map_err(|mut error| { error.push("CodeBlock", "relative_workspace_path"); error }),
            2 => if let ::core::option::Option::Some(ref mut value) = self.file_contents { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.file_contents = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CodeBlock", "file_contents"); error }),
            3 => if let ::core::option::Option::Some(ref mut value) = self.range { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.range = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CodeBlock", "range"); error }),
            4 => ::prost::encoding::string::merge(wire_type, &mut self.contents, buf, ctx).map_err(|mut error| { error.push("CodeBlock", "contents"); error }),
            5 => if let ::core::option::Option::Some(ref mut value) = self.signatures { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.signatures = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CodeBlock", "signatures"); error }),
            6 => if let ::core::option::Option::Some(ref mut value) = self.override_contents { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.override_contents = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CodeBlock", "override_contents"); error }),
            7 => if let ::core::option::Option::Some(ref mut value) = self.original_contents { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.original_contents = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CodeBlock", "original_contents"); error }),
            8 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.detailed_lines, buf, ctx).map_err(|mut error| { error.push("CodeBlock", "detailed_lines"); error }),
            9 => if let ::core::option::Option::Some(ref mut value) = self.file_contents_length { ::prost::encoding::int32::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::int32::merge(wire_type, &mut value, buf, ctx).map(|_| self.file_contents_length = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CodeBlock", "file_contents_length"); error }),
            10 => if let ::core::option::Option::Some(ref mut value) = self.file_git_context { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.file_git_context = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CodeBlock", "file_git_context"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.relative_workspace_path) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.relative_workspace_path) }
        if let ::core::option::Option::Some(ref value) = self.file_contents { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value) }
        if let ::core::option::Option::Some(ref value) = self.range { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, value) }
        if !::proto_value::is_default(&self.contents) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.contents) }
        if let ::core::option::Option::Some(ref value) = self.signatures { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, value) }
        if let ::core::option::Option::Some(ref value) = self.override_contents { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(6) }, value) }
        if let ::core::option::Option::Some(ref value) = self.original_contents { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(7) }, value) }
        if !::alloc::vec::Vec::is_empty(&self.detailed_lines) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(8) }, &self.detailed_lines) }
        if let ::core::option::Option::Some(ref value) = self.file_contents_length { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(9) }, value) }
        if let ::core::option::Option::Some(ref value) = self.file_git_context { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(10) }, value) }
        len
    }
    fn clear(&mut self) {
        self.relative_workspace_path.clear();
        self.file_contents = ::core::option::Option::None;
        self.file_contents_length = ::core::option::Option::None;
        self.range = ::core::option::Option::None;
        self.contents.clear();
        self.signatures = ::core::option::Option::None;
        self.override_contents = ::core::option::Option::None;
        self.original_contents = ::core::option::Option::None;
        self.detailed_lines.clear();
        self.file_git_context = ::core::option::Option::None;
    }
}
/// .aiserver.v1.GitCommit
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct GitCommit {
    #[serde(default)]
    pub commit: ::alloc::string::String,
    #[serde(default)]
    pub author: ::alloc::string::String,
    #[serde(default)]
    pub date: ::alloc::string::String,
    #[serde(default)]
    pub message: ::alloc::string::String,
}
impl ::prost::Message for GitCommit {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.commit) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.commit, buf) }
        if !::proto_value::is_default(&self.author) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.author, buf) }
        if !::proto_value::is_default(&self.date) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.date, buf) }
        if !::proto_value::is_default(&self.message) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.message, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.commit, buf, ctx).map_err(|mut error| { error.push("GitCommit", "commit"); error }),
            2 => ::prost::encoding::string::merge(wire_type, &mut self.author, buf, ctx).map_err(|mut error| { error.push("GitCommit", "author"); error }),
            3 => ::prost::encoding::string::merge(wire_type, &mut self.date, buf, ctx).map_err(|mut error| { error.push("GitCommit", "date"); error }),
            4 => ::prost::encoding::string::merge(wire_type, &mut self.message, buf, ctx).map_err(|mut error| { error.push("GitCommit", "message"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.commit) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.commit) }
        if !::proto_value::is_default(&self.author) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.author) }
        if !::proto_value::is_default(&self.date) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.date) }
        if !::proto_value::is_default(&self.message) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.message) }
        len
    }
    fn clear(&mut self) {
        self.commit.clear();
        self.author.clear();
        self.date.clear();
        self.message.clear();
    }
}
/// .aiserver.v1.FileGit
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct FileGit {
    #[serde(default)]
    pub commits: ::alloc::vec::Vec<GitCommit>,
}
impl ::prost::Message for FileGit {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) { if !::alloc::vec::Vec::is_empty(&self.commits) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.commits, buf) }     }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.commits, buf, ctx).map_err(|mut error| { error.push("FileGit", "commits"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize { if !::alloc::vec::Vec::is_empty(&self.commits) { ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.commits) } else { 0 } }
    fn clear(&mut self) { self.commits.clear() }
}
/// Nested message and enum types in [`Diagnostic`].
pub mod diagnostic {
    /// .aiserver.v1.Diagnostic.DiagnosticSeverity
    #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde::Deserialize)]
    pub enum DiagnosticSeverity {
        #[default]
        #[serde(rename = "unspecified")]
        Unspecified = 0,
        #[serde(rename = "error")]
        Error = 1,
        #[serde(rename = "warning")]
        Warning = 2,
        #[serde(rename = "information")]
        Information = 3,
        #[serde(rename = "hint")]
        Hint = 4,
    }
    impl ::core::convert::From::<DiagnosticSeverity> for i32 {
        #[inline]
        fn from(value: DiagnosticSeverity) -> i32 { value as i32 }
    }
    impl ::core::convert::TryFrom::<i32> for DiagnosticSeverity {
        type Error = ();
        #[inline]
        fn try_from(value: i32) -> ::core::result::Result<Self, ()> {
            match value {
                0 => ::core::result::Result::Ok(Self::Unspecified),
                1 => ::core::result::Result::Ok(Self::Error),
                2 => ::core::result::Result::Ok(Self::Warning),
                3 => ::core::result::Result::Ok(Self::Information),
                4 => ::core::result::Result::Ok(Self::Hint),
                _ => ::core::result::Result::Err(()),
            }
        }
    }
    /// .aiserver.v1.Diagnostic.RelatedInformation
    #[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Deserialize)]
    pub struct RelatedInformation {
        #[serde(default)]
        pub message: ::alloc::string::String,
        #[serde(default)]
        pub range: ::core::option::Option<super::CursorRange>,
    }
    impl ::prost::Message for RelatedInformation {
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if !::proto_value::is_default(&self.message) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.message, buf) }
            if let ::core::option::Option::Some(ref value) = self.range { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value, buf) }
        }
        fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
            match number.get() {
                1 => ::prost::encoding::string::merge(wire_type, &mut self.message, buf, ctx).map_err(|mut error| { error.push("RelatedInformation", "message"); error }),
                2 => if let ::core::option::Option::Some(ref mut value) = self.range { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.range = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("RelatedInformation", "range"); error }),
                _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
            }
        }
        fn encoded_len(&self) -> usize {
            let mut len = 0;
            if !::proto_value::is_default(&self.message) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.message) }
            if let ::core::option::Option::Some(ref value) = self.range { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value) }
            len
        }
        fn clear(&mut self) {
            self.message.clear();
            self.range = ::core::option::Option::None;
        }
    }
}
/// .aiserver.v1.Diagnostic
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct Diagnostic {
    #[serde(default)]
    pub message: ::alloc::string::String,
    #[serde(default)]
    pub range: ::core::option::Option<CursorRange>,
    #[serde(default)]
    pub severity: ::proto_value::Enum<diagnostic::DiagnosticSeverity>,
    #[serde(default)]
    pub related_information: ::alloc::vec::Vec<diagnostic::RelatedInformation>,
}
impl ::prost::Message for Diagnostic {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.message) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.message, buf) }
        if let ::core::option::Option::Some(ref value) = self.range { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value, buf) }
        if !::proto_value::is_default(&self.severity) { ::prost::encoding::r#enum::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.severity, buf) }
        if !::alloc::vec::Vec::is_empty(&self.related_information) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.related_information, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.message, buf, ctx).map_err(|mut error| { error.push("Diagnostic", "message"); error }),
            2 => if let ::core::option::Option::Some(ref mut value) = self.range { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.range = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("Diagnostic", "range"); error }),
            3 => ::prost::encoding::r#enum::merge(wire_type, &mut self.severity, buf, ctx).map_err(|mut error| { error.push("Diagnostic", "severity"); error }),
            4 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.related_information, buf, ctx).map_err(|mut error| { error.push("Diagnostic", "related_information"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.message) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.message) }
        if let ::core::option::Option::Some(ref value) = self.range { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value) }
        if !::proto_value::is_default(&self.severity) { len += ::prost::encoding::r#enum::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.severity) }
        if !::alloc::vec::Vec::is_empty(&self.related_information) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.related_information) }
        len
    }
    fn clear(&mut self) {
        self.message.clear();
        self.range = ::core::option::Option::None;
        self.severity = ::proto_value::Enum::default();
        self.related_information.clear();
    }
}
/// .aiserver.v1.BM25Chunk
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct Bm25Chunk {
    #[serde(default)]
    pub content: ::alloc::string::String,
    #[serde(default)]
    pub range: ::core::option::Option<SimplestRange>,
    #[serde(default)]
    pub score: i32,
    #[serde(default)]
    pub relative_path: ::alloc::string::String,
}
impl ::prost::Message for Bm25Chunk {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.content) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.content, buf) }
        if let ::core::option::Option::Some(ref value) = self.range { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value, buf) }
        if !::proto_value::is_default(&self.score) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.score, buf) }
        if !::proto_value::is_default(&self.relative_path) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.relative_path, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.content, buf, ctx).map_err(|mut error| { error.push("BM25Chunk", "content"); error }),
            2 => if let ::core::option::Option::Some(ref mut value) = self.range { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.range = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("BM25Chunk", "range"); error }),
            3 => ::prost::encoding::int32::merge(wire_type, &mut self.score, buf, ctx).map_err(|mut error| { error.push("BM25Chunk", "score"); error }),
            4 => ::prost::encoding::string::merge(wire_type, &mut self.relative_path, buf, ctx).map_err(|mut error| { error.push("BM25Chunk", "relative_path"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.content) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.content) }
        if let ::core::option::Option::Some(ref value) = self.range { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value) }
        if !::proto_value::is_default(&self.score) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.score) }
        if !::proto_value::is_default(&self.relative_path) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.relative_path) }
        len
    }
    fn clear(&mut self) {
        self.content.clear();
        self.range = ::core::option::Option::None;
        self.score = 0i32;
        self.relative_path.clear();
    }
}
/// .aiserver.v1.CurrentFileInfo
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct CurrentFileInfo {
    #[serde(default)]
    pub relative_workspace_path: ::alloc::string::String,
    #[serde(default)]
    pub contents: ::alloc::string::String,
    #[serde(default)]
    pub rely_on_filesync: bool,
    #[serde(default)]
    pub sha_256_hash: ::core::option::Option<::alloc::string::String>,
    #[serde(default)]
    pub top_chunks: ::alloc::vec::Vec<Bm25Chunk>,
    #[serde(default)]
    pub contents_start_at_line: i32,
    #[serde(default)]
    pub cursor_position: ::core::option::Option<CursorPosition>,
    #[serde(default)]
    pub dataframes: ::alloc::vec::Vec<DataframeInfo>,
    #[serde(default)]
    pub total_number_of_lines: i32,
    #[serde(default)]
    pub language_id: ::alloc::string::String,
    #[serde(default)]
    pub selection: ::core::option::Option<CursorRange>,
    #[serde(default)]
    pub alternative_version_id: ::core::option::Option<i32>,
    #[serde(default)]
    pub diagnostics: ::alloc::vec::Vec<Diagnostic>,
    #[serde(default)]
    pub file_version: ::core::option::Option<i32>,
    #[serde(default)]
    pub workspace_root_path: ::alloc::string::String,
    #[serde(default)]
    pub line_ending: ::core::option::Option<::alloc::string::String>,
}
impl ::prost::Message for CurrentFileInfo {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.relative_workspace_path) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.relative_workspace_path, buf) }
        if !::proto_value::is_default(&self.contents) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.contents, buf) }
        if let ::core::option::Option::Some(ref value) = self.cursor_position { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, value, buf) }
        if !::alloc::vec::Vec::is_empty(&self.dataframes) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.dataframes, buf) }
        if !::proto_value::is_default(&self.language_id) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, &self.language_id, buf) }
        if let ::core::option::Option::Some(ref value) = self.selection { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(6) }, value, buf) }
        if !::alloc::vec::Vec::is_empty(&self.diagnostics) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(7) }, &self.diagnostics, buf) }
        if !::proto_value::is_default(&self.total_number_of_lines) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(8) }, &self.total_number_of_lines, buf) }
        if !::proto_value::is_default(&self.contents_start_at_line) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(9) }, &self.contents_start_at_line, buf) }
        if !::alloc::vec::Vec::is_empty(&self.top_chunks) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(10) }, &self.top_chunks, buf) }
        if let ::core::option::Option::Some(ref value) = self.alternative_version_id { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(11) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.file_version { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(14) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.sha_256_hash { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(17) }, value, buf) }
        if !::proto_value::is_default(&self.rely_on_filesync) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(18) }, &self.rely_on_filesync, buf) }
        if !::proto_value::is_default(&self.workspace_root_path) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(19) }, &self.workspace_root_path, buf) }
        if let ::core::option::Option::Some(ref value) = self.line_ending { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(20) }, value, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.relative_workspace_path, buf, ctx).map_err(|mut error| { error.push("CurrentFileInfo", "relative_workspace_path"); error }),
            2 => ::prost::encoding::string::merge(wire_type, &mut self.contents, buf, ctx).map_err(|mut error| { error.push("CurrentFileInfo", "contents"); error }),
            3 => if let ::core::option::Option::Some(ref mut value) = self.cursor_position { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.cursor_position = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CurrentFileInfo", "cursor_position"); error }),
            4 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.dataframes, buf, ctx).map_err(|mut error| { error.push("CurrentFileInfo", "dataframes"); error }),
            5 => ::prost::encoding::string::merge(wire_type, &mut self.language_id, buf, ctx).map_err(|mut error| { error.push("CurrentFileInfo", "language_id"); error }),
            6 => if let ::core::option::Option::Some(ref mut value) = self.selection { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.selection = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CurrentFileInfo", "selection"); error }),
            7 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.diagnostics, buf, ctx).map_err(|mut error| { error.push("CurrentFileInfo", "diagnostics"); error }),
            8 => ::prost::encoding::int32::merge(wire_type, &mut self.total_number_of_lines, buf, ctx).map_err(|mut error| { error.push("CurrentFileInfo", "total_number_of_lines"); error }),
            9 => ::prost::encoding::int32::merge(wire_type, &mut self.contents_start_at_line, buf, ctx).map_err(|mut error| { error.push("CurrentFileInfo", "contents_start_at_line"); error }),
            10 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.top_chunks, buf, ctx).map_err(|mut error| { error.push("CurrentFileInfo", "top_chunks"); error }),
            11 => if let ::core::option::Option::Some(ref mut value) = self.alternative_version_id { ::prost::encoding::int32::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::int32::merge(wire_type, &mut value, buf, ctx).map(|_| self.alternative_version_id = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CurrentFileInfo", "alternative_version_id"); error }),
            14 => if let ::core::option::Option::Some(ref mut value) = self.file_version { ::prost::encoding::int32::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::int32::merge(wire_type, &mut value, buf, ctx).map(|_| self.file_version = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CurrentFileInfo", "file_version"); error }),
            17 => if let ::core::option::Option::Some(ref mut value) = self.sha_256_hash { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.sha_256_hash = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CurrentFileInfo", "sha_256_hash"); error }),
            18 => ::prost::encoding::bool::merge(wire_type, &mut self.rely_on_filesync, buf, ctx).map_err(|mut error| { error.push("CurrentFileInfo", "rely_on_filesync"); error }),
            19 => ::prost::encoding::string::merge(wire_type, &mut self.workspace_root_path, buf, ctx).map_err(|mut error| { error.push("CurrentFileInfo", "workspace_root_path"); error }),
            20 => if let ::core::option::Option::Some(ref mut value) = self.line_ending { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.line_ending = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CurrentFileInfo", "line_ending"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.relative_workspace_path) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.relative_workspace_path) }
        if !::proto_value::is_default(&self.contents) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.contents) }
        if let ::core::option::Option::Some(ref value) = self.cursor_position { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, value) }
        if !::alloc::vec::Vec::is_empty(&self.dataframes) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.dataframes) }
        if !::proto_value::is_default(&self.language_id) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, &self.language_id) }
        if let ::core::option::Option::Some(ref value) = self.selection { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(6) }, value) }
        if !::alloc::vec::Vec::is_empty(&self.diagnostics) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(7) }, &self.diagnostics) }
        if !::proto_value::is_default(&self.total_number_of_lines) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(8) }, &self.total_number_of_lines) }
        if !::proto_value::is_default(&self.contents_start_at_line) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(9) }, &self.contents_start_at_line) }
        if !::alloc::vec::Vec::is_empty(&self.top_chunks) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(10) }, &self.top_chunks) }
        if let ::core::option::Option::Some(ref value) = self.alternative_version_id { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(11) }, value) }
        if let ::core::option::Option::Some(ref value) = self.file_version { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(14) }, value) }
        if let ::core::option::Option::Some(ref value) = self.sha_256_hash { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(17) }, value) }
        if !::proto_value::is_default(&self.rely_on_filesync) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(18) }, &self.rely_on_filesync) }
        if !::proto_value::is_default(&self.workspace_root_path) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(19) }, &self.workspace_root_path) }
        if let ::core::option::Option::Some(ref value) = self.line_ending { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(20) }, value) }
        len
    }
    fn clear(&mut self) {
        self.relative_workspace_path.clear();
        self.contents.clear();
        self.rely_on_filesync = false;
        self.sha_256_hash = ::core::option::Option::None;
        self.top_chunks.clear();
        self.contents_start_at_line = 0i32;
        self.cursor_position = ::core::option::Option::None;
        self.dataframes.clear();
        self.total_number_of_lines = 0i32;
        self.language_id.clear();
        self.selection = ::core::option::Option::None;
        self.alternative_version_id = ::core::option::Option::None;
        self.diagnostics.clear();
        self.file_version = ::core::option::Option::None;
        self.workspace_root_path.clear();
        self.line_ending = ::core::option::Option::None;
    }
}
/// .aiserver.v1.AzureState
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
pub struct AzureState {}
impl ::prost::Message for AzureState {
    fn encode_raw(&self, _: &mut impl ::prost::bytes::BufMut) {}
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> { ::prost::encoding::skip_field(wire_type, number, buf, ctx) }
    #[inline]
    fn encoded_len(&self) -> usize { 0 }
    fn clear(&mut self) {}
}
/// .aiserver.v1.ModelDetails
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash)]
pub struct ModelDetails {
    pub model_name: ::core::option::Option<::byte_str::ByteStr>,
    pub azure_state: ::core::option::Option<AzureState>,
    pub enable_slow_pool: ::core::option::Option<bool>,
    pub max_mode: ::core::option::Option<bool>,
}
impl ::prost::Message for ModelDetails {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if let ::core::option::Option::Some(ref value) = self.model_name { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.azure_state { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.enable_slow_pool { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.max_mode { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(8) }, value, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => if let ::core::option::Option::Some(ref mut value) = self.model_name { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.model_name = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("ModelDetails", "model_name"); error }),
            4 => if let ::core::option::Option::Some(ref mut value) = self.azure_state { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.azure_state = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("ModelDetails", "azure_state"); error }),
            5 => if let ::core::option::Option::Some(ref mut value) = self.enable_slow_pool { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.enable_slow_pool = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("ModelDetails", "enable_slow_pool"); error }),
            8 => if let ::core::option::Option::Some(ref mut value) = self.max_mode { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.max_mode = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("ModelDetails", "max_mode"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if let ::core::option::Option::Some(ref value) = self.model_name { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, value) }
        if let ::core::option::Option::Some(ref value) = self.azure_state { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, value) }
        if let ::core::option::Option::Some(ref value) = self.enable_slow_pool { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, value) }
        if let ::core::option::Option::Some(ref value) = self.max_mode { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(8) }, value) }
        len
    }
    fn clear(&mut self) {
        self.model_name = ::core::option::Option::None;
        self.azure_state = ::core::option::Option::None;
        self.enable_slow_pool = ::core::option::Option::None;
        self.max_mode = ::core::option::Option::None;
    }
}
/// Nested message and enum types in [`DataframeInfo`].
pub mod dataframe_info {
    /// .aiserver.v1.DataframeInfo.Column
    #[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Deserialize)]
    pub struct Column {
        #[serde(default)]
        pub key: ::alloc::string::String,
        #[serde(default)]
        pub r#type: ::alloc::string::String,
    }
    impl ::prost::Message for Column {
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if !::proto_value::is_default(&self.key) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.key, buf) }
            if !::proto_value::is_default(&self.r#type) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.r#type, buf) }
        }
        fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
            match number.get() {
                1 => ::prost::encoding::string::merge(wire_type, &mut self.key, buf, ctx).map_err(|mut error| { error.push("Column", "key"); error }),
                2 => ::prost::encoding::string::merge(wire_type, &mut self.r#type, buf, ctx).map_err(|mut error| { error.push("Column", "type"); error }),
                _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
            }
        }
        fn encoded_len(&self) -> usize {
            let mut len = 0;
            if !::proto_value::is_default(&self.key) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.key) }
            if !::proto_value::is_default(&self.r#type) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.r#type) }
            len
        }
        fn clear(&mut self) {
            self.key.clear();
            self.r#type.clear();
        }
    }
}
/// .aiserver.v1.DataframeInfo
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct DataframeInfo {
    #[serde(default)]
    pub name: ::alloc::string::String,
    #[serde(default)]
    pub shape: ::alloc::string::String,
    #[serde(default)]
    pub data_dimensionality: i32,
    #[serde(default)]
    pub columns: ::alloc::vec::Vec<dataframe_info::Column>,
    #[serde(default)]
    pub row_count: i32,
    #[serde(default)]
    pub index_column: ::alloc::string::String,
}
impl ::prost::Message for DataframeInfo {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.name) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.name, buf) }
        if !::proto_value::is_default(&self.shape) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.shape, buf) }
        if !::proto_value::is_default(&self.data_dimensionality) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.data_dimensionality, buf) }
        if !::alloc::vec::Vec::is_empty(&self.columns) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(6) }, &self.columns, buf) }
        if !::proto_value::is_default(&self.row_count) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(7) }, &self.row_count, buf) }
        if !::proto_value::is_default(&self.index_column) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(8) }, &self.index_column, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.name, buf, ctx).map_err(|mut error| { error.push("DataframeInfo", "name"); error }),
            2 => ::prost::encoding::string::merge(wire_type, &mut self.shape, buf, ctx).map_err(|mut error| { error.push("DataframeInfo", "shape"); error }),
            3 => ::prost::encoding::int32::merge(wire_type, &mut self.data_dimensionality, buf, ctx).map_err(|mut error| { error.push("DataframeInfo", "data_dimensionality"); error }),
            6 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.columns, buf, ctx).map_err(|mut error| { error.push("DataframeInfo", "columns"); error }),
            7 => ::prost::encoding::int32::merge(wire_type, &mut self.row_count, buf, ctx).map_err(|mut error| { error.push("DataframeInfo", "row_count"); error }),
            8 => ::prost::encoding::string::merge(wire_type, &mut self.index_column, buf, ctx).map_err(|mut error| { error.push("DataframeInfo", "index_column"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.name) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.name) }
        if !::proto_value::is_default(&self.shape) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.shape) }
        if !::proto_value::is_default(&self.data_dimensionality) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.data_dimensionality) }
        if !::alloc::vec::Vec::is_empty(&self.columns) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(6) }, &self.columns) }
        if !::proto_value::is_default(&self.row_count) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(7) }, &self.row_count) }
        if !::proto_value::is_default(&self.index_column) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(8) }, &self.index_column) }
        len
    }
    fn clear(&mut self) {
        self.name.clear();
        self.shape.clear();
        self.data_dimensionality = 0i32;
        self.columns.clear();
        self.row_count = 0i32;
        self.index_column.clear();
    }
}
/// .aiserver.v1.LinterError
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct LinterError {
    #[serde(default)]
    pub message: ::alloc::string::String,
    #[serde(default)]
    pub range: ::core::option::Option<CursorRange>,
    #[serde(default)]
    pub source: ::core::option::Option<::alloc::string::String>,
    #[serde(default)]
    pub related_information: ::alloc::vec::Vec<diagnostic::RelatedInformation>,
    #[serde(default)]
    pub severity: ::core::option::Option<::proto_value::Enum<diagnostic::DiagnosticSeverity>>,
    #[serde(default)]
    pub is_stale: ::core::option::Option<bool>,
}
impl ::prost::Message for LinterError {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.message) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.message, buf) }
        if let ::core::option::Option::Some(ref value) = self.range { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.source { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, value, buf) }
        if !::alloc::vec::Vec::is_empty(&self.related_information) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.related_information, buf) }
        if let ::core::option::Option::Some(ref value) = self.severity { ::prost::encoding::r#enum::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.is_stale { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(6) }, value, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.message, buf, ctx).map_err(|mut error| { error.push("LinterError", "message"); error }),
            2 => if let ::core::option::Option::Some(ref mut value) = self.range { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.range = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("LinterError", "range"); error }),
            3 => if let ::core::option::Option::Some(ref mut value) = self.source { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.source = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("LinterError", "source"); error }),
            4 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.related_information, buf, ctx).map_err(|mut error| { error.push("LinterError", "related_information"); error }),
            5 => if let ::core::option::Option::Some(ref mut value) = self.severity { ::prost::encoding::r#enum::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::r#enum::merge(wire_type, &mut value, buf, ctx).map(|_| self.severity = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("LinterError", "severity"); error }),
            6 => if let ::core::option::Option::Some(ref mut value) = self.is_stale { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.is_stale = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("LinterError", "is_stale"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.message) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.message) }
        if let ::core::option::Option::Some(ref value) = self.range { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value) }
        if let ::core::option::Option::Some(ref value) = self.source { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, value) }
        if !::alloc::vec::Vec::is_empty(&self.related_information) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.related_information) }
        if let ::core::option::Option::Some(ref value) = self.severity { len += ::prost::encoding::r#enum::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, value) }
        if let ::core::option::Option::Some(ref value) = self.is_stale { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(6) }, value) }
        len
    }
    fn clear(&mut self) {
        self.message.clear();
        self.range = ::core::option::Option::None;
        self.source = ::core::option::Option::None;
        self.related_information.clear();
        self.severity = ::core::option::Option::None;
        self.is_stale = ::core::option::Option::None;
    }
}
/// .aiserver.v1.LinterErrors
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct LinterErrors {
    #[serde(default)]
    pub relative_workspace_path: ::alloc::string::String,
    #[serde(default)]
    pub errors: ::alloc::vec::Vec<LinterError>,
    #[serde(default)]
    pub file_contents: ::alloc::string::String,
}
impl ::prost::Message for LinterErrors {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.relative_workspace_path) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.relative_workspace_path, buf) }
        if !::alloc::vec::Vec::is_empty(&self.errors) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.errors, buf) }
        if !::proto_value::is_default(&self.file_contents) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.file_contents, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.relative_workspace_path, buf, ctx).map_err(|mut error| { error.push("LinterErrors", "relative_workspace_path"); error }),
            2 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.errors, buf, ctx).map_err(|mut error| { error.push("LinterErrors", "errors"); error }),
            3 => ::prost::encoding::string::merge(wire_type, &mut self.file_contents, buf, ctx).map_err(|mut error| { error.push("LinterErrors", "file_contents"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.relative_workspace_path) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.relative_workspace_path) }
        if !::alloc::vec::Vec::is_empty(&self.errors) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.errors) }
        if !::proto_value::is_default(&self.file_contents) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.file_contents) }
        len
    }
    fn clear(&mut self) {
        self.relative_workspace_path.clear();
        self.errors.clear();
        self.file_contents.clear();
    }
}
/// .aiserver.v1.ExplicitContext
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash)]
pub struct ExplicitContext {
    pub context: ::byte_str::ByteStr,
    pub repo_context: ::core::option::Option<::byte_str::ByteStr>,
    pub mode_specific_context: ::core::option::Option<::byte_str::ByteStr>,
}
impl ::prost::Message for ExplicitContext {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.context) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.context, buf) }
        if let ::core::option::Option::Some(ref value) = self.repo_context { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.mode_specific_context { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, value, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.context, buf, ctx).map_err(|mut error| { error.push("ExplicitContext", "context"); error }),
            2 => if let ::core::option::Option::Some(ref mut value) = self.repo_context { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.repo_context = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("ExplicitContext", "repo_context"); error }),
            4 => if let ::core::option::Option::Some(ref mut value) = self.mode_specific_context { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.mode_specific_context = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("ExplicitContext", "mode_specific_context"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.context) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.context) }
        if let ::core::option::Option::Some(ref value) = self.repo_context { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value) }
        if let ::core::option::Option::Some(ref value) = self.mode_specific_context { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, value) }
        len
    }
    fn clear(&mut self) {
        self.context.clear();
        self.repo_context = ::core::option::Option::None;
        self.mode_specific_context = ::core::option::Option::None;
    }
}
/// Nested message and enum types in [`ErrorDetails`].
pub mod error_details {
    /// .aiserver.v1.ErrorDetails.Error
    #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum Error {
        #[default]
        Unspecified = 0,
        BadApiKey = 1,
        BadUserApiKey = 42,
        NotLoggedIn = 2,
        InvalidAuthId = 3,
        NotHighEnoughPermissions = 4,
        AgentRequiresLogin = 18,
        BadModelName = 5,
        NotFound = 39,
        Deprecated = 40,
        UserNotFound = 6,
        FreeUserRateLimitExceeded = 7,
        ProUserRateLimitExceeded = 8,
        FreeUserUsageLimit = 9,
        ProUserUsageLimit = 10,
        ResourceExhausted = 41,
        AuthTokenNotFound = 11,
        AuthTokenExpired = 12,
        Openai = 13,
        OpenaiRateLimitExceeded = 14,
        OpenaiAccountLimitExceeded = 15,
        TaskUuidNotFound = 16,
        TaskNoPermissions = 17,
        AgentEngineNotFound = 19,
        MaxTokens = 20,
        ProUserOnly = 23,
        ApiKeyNotSupported = 24,
        UserAbortedRequest = 21,
        Timeout = 25,
        GenericRateLimitExceeded = 22,
        SlashEditFileTooLong = 26,
        FileUnsupported = 27,
        Gpt4VisionPreviewRateLimit = 28,
        CustomMessage = 29,
        OutdatedClient = 30,
        ClaudeImageTooLarge = 31,
        GitgraphNotFound = 32,
        FileNotFound = 33,
        ApiKeyRateLimit = 34,
        Debounced = 35,
        BadRequest = 36,
        RepositoryServiceRepositoryIsNotInitialized = 37,
        Unauthorized = 38,
        ConversationTooLong = 43,
        UsagePricingRequired = 44,
        UsagePricingRequiredChangeable = 45,
        GithubNoUserCredentials = 46,
        GithubUserNoAccess = 47,
        GithubAppNoAccess = 48,
        GithubMultipleOwners = 49,
        RateLimited = 50,
        RateLimitedChangeable = 51,
        Custom = 52,
        HooksBlocked = 53,
    }
    impl ::core::convert::From::<Error> for i32 {
        #[inline]
        fn from(value: Error) -> i32 { value as i32 }
    }
    impl ::core::convert::TryFrom::<i32> for Error {
        type Error = ();
        #[inline]
        fn try_from(value: i32) -> ::core::result::Result<Self, ()> {
            match value {
                0 => ::core::result::Result::Ok(Self::Unspecified),
                1 => ::core::result::Result::Ok(Self::BadApiKey),
                42 => ::core::result::Result::Ok(Self::BadUserApiKey),
                2 => ::core::result::Result::Ok(Self::NotLoggedIn),
                3 => ::core::result::Result::Ok(Self::InvalidAuthId),
                4 => ::core::result::Result::Ok(Self::NotHighEnoughPermissions),
                18 => ::core::result::Result::Ok(Self::AgentRequiresLogin),
                5 => ::core::result::Result::Ok(Self::BadModelName),
                39 => ::core::result::Result::Ok(Self::NotFound),
                40 => ::core::result::Result::Ok(Self::Deprecated),
                6 => ::core::result::Result::Ok(Self::UserNotFound),
                7 => ::core::result::Result::Ok(Self::FreeUserRateLimitExceeded),
                8 => ::core::result::Result::Ok(Self::ProUserRateLimitExceeded),
                9 => ::core::result::Result::Ok(Self::FreeUserUsageLimit),
                10 => ::core::result::Result::Ok(Self::ProUserUsageLimit),
                41 => ::core::result::Result::Ok(Self::ResourceExhausted),
                11 => ::core::result::Result::Ok(Self::AuthTokenNotFound),
                12 => ::core::result::Result::Ok(Self::AuthTokenExpired),
                13 => ::core::result::Result::Ok(Self::Openai),
                14 => ::core::result::Result::Ok(Self::OpenaiRateLimitExceeded),
                15 => ::core::result::Result::Ok(Self::OpenaiAccountLimitExceeded),
                16 => ::core::result::Result::Ok(Self::TaskUuidNotFound),
                17 => ::core::result::Result::Ok(Self::TaskNoPermissions),
                19 => ::core::result::Result::Ok(Self::AgentEngineNotFound),
                20 => ::core::result::Result::Ok(Self::MaxTokens),
                23 => ::core::result::Result::Ok(Self::ProUserOnly),
                24 => ::core::result::Result::Ok(Self::ApiKeyNotSupported),
                21 => ::core::result::Result::Ok(Self::UserAbortedRequest),
                25 => ::core::result::Result::Ok(Self::Timeout),
                22 => ::core::result::Result::Ok(Self::GenericRateLimitExceeded),
                26 => ::core::result::Result::Ok(Self::SlashEditFileTooLong),
                27 => ::core::result::Result::Ok(Self::FileUnsupported),
                28 => ::core::result::Result::Ok(Self::Gpt4VisionPreviewRateLimit),
                29 => ::core::result::Result::Ok(Self::CustomMessage),
                30 => ::core::result::Result::Ok(Self::OutdatedClient),
                31 => ::core::result::Result::Ok(Self::ClaudeImageTooLarge),
                32 => ::core::result::Result::Ok(Self::GitgraphNotFound),
                33 => ::core::result::Result::Ok(Self::FileNotFound),
                34 => ::core::result::Result::Ok(Self::ApiKeyRateLimit),
                35 => ::core::result::Result::Ok(Self::Debounced),
                36 => ::core::result::Result::Ok(Self::BadRequest),
                37 => ::core::result::Result::Ok(Self::RepositoryServiceRepositoryIsNotInitialized),
                38 => ::core::result::Result::Ok(Self::Unauthorized),
                43 => ::core::result::Result::Ok(Self::ConversationTooLong),
                44 => ::core::result::Result::Ok(Self::UsagePricingRequired),
                45 => ::core::result::Result::Ok(Self::UsagePricingRequiredChangeable),
                46 => ::core::result::Result::Ok(Self::GithubNoUserCredentials),
                47 => ::core::result::Result::Ok(Self::GithubUserNoAccess),
                48 => ::core::result::Result::Ok(Self::GithubAppNoAccess),
                49 => ::core::result::Result::Ok(Self::GithubMultipleOwners),
                50 => ::core::result::Result::Ok(Self::RateLimited),
                51 => ::core::result::Result::Ok(Self::RateLimitedChangeable),
                52 => ::core::result::Result::Ok(Self::Custom),
                53 => ::core::result::Result::Ok(Self::HooksBlocked),
                _ => ::core::result::Result::Err(()),
            }
        }
    }
}
/// .aiserver.v1.ErrorDetails
#[derive(Debug, Default, Clone, PartialEq)]
pub struct ErrorDetails {
    pub error: ::proto_value::Enum<error_details::Error>,
    pub details: ::core::option::Option<CustomErrorDetails>,
    pub is_expected: ::core::option::Option<bool>,
}
impl ::prost::Message for ErrorDetails {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.error) { ::prost::encoding::r#enum::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.error, buf) }
        if let ::core::option::Option::Some(ref value) = self.details { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.is_expected { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, value, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::r#enum::merge(wire_type, &mut self.error, buf, ctx).map_err(|mut error| { error.push("ErrorDetails", "error"); error }),
            2 => if let ::core::option::Option::Some(ref mut value) = self.details { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.details = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("ErrorDetails", "details"); error }),
            3 => if let ::core::option::Option::Some(ref mut value) = self.is_expected { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.is_expected = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("ErrorDetails", "is_expected"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.error) { len += ::prost::encoding::r#enum::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.error) }
        if let ::core::option::Option::Some(ref value) = self.details { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value) }
        if let ::core::option::Option::Some(ref value) = self.is_expected { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, value) }
        len
    }
    fn clear(&mut self) {
        self.error = ::proto_value::Enum::default();
        self.details = ::core::option::Option::None;
        self.is_expected = ::core::option::Option::None;
    }
}
/// .aiserver.v1.CustomErrorDetails
#[derive(Debug, Default, Clone, PartialEq, ::serde::Serialize)]
pub struct CustomErrorDetails {
    #[serde(skip_serializing_if = "::proto_value::is_default")]
    pub title: ::alloc::string::String,
    #[serde(skip_serializing_if = "::proto_value::is_default")]
    pub detail: ::alloc::string::String,
    #[serde(rename = "additionalInfo", skip_serializing_if = "::std::collections::HashMap::is_empty")]
    pub additional_info: ::std::collections::HashMap<::alloc::string::String, ::alloc::string::String>,
}
impl ::prost::Message for CustomErrorDetails {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.title) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.title, buf) }
        if !::proto_value::is_default(&self.detail) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.detail, buf) }
        if !::std::collections::HashMap::is_empty(&self.additional_info) { ::prost::encoding::hash_map::encode(::prost::encoding::string::encode, ::prost::encoding::string::encoded_len, ::prost::encoding::string::encode, ::prost::encoding::string::encoded_len, unsafe { ::core::num::NonZeroU32::new_unchecked(7) }, &self.additional_info, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.title, buf, ctx).map_err(|mut error| { error.push("CustomErrorDetails", "title"); error }),
            2 => ::prost::encoding::string::merge(wire_type, &mut self.detail, buf, ctx).map_err(|mut error| { error.push("CustomErrorDetails", "detail"); error }),
            7 => ::prost::encoding::hash_map::merge(::prost::encoding::string::merge, ::prost::encoding::string::merge, &mut self.additional_info, buf, ctx).map_err(|mut error| { error.push("CustomErrorDetails", "additional_info"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.title) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.title) }
        if !::proto_value::is_default(&self.detail) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.detail) }
        if !::std::collections::HashMap::is_empty(&self.additional_info) { len += ::prost::encoding::hash_map::encoded_len(::prost::encoding::string::encoded_len, ::prost::encoding::string::encoded_len, unsafe { ::core::num::NonZeroU32::new_unchecked(7) }, &self.additional_info) }
        len
    }
    fn clear(&mut self) {
        self.title.clear();
        self.detail.clear();
        self.additional_info.clear();
    }
}
/// Nested message and enum types in [`ImageProto`].
pub mod image_proto {
    /// .aiserver.v1.ImageProto.Dimension
    #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
    pub struct Dimension {
        pub width: i32,
        pub height: i32,
    }
    impl ::prost::Message for Dimension {
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if !::proto_value::is_default(&self.width) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.width, buf) }
            if !::proto_value::is_default(&self.height) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.height, buf) }
        }
        fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
            match number.get() {
                1 => ::prost::encoding::int32::merge(wire_type, &mut self.width, buf, ctx).map_err(|mut error| { error.push("Dimension", "width"); error }),
                2 => ::prost::encoding::int32::merge(wire_type, &mut self.height, buf, ctx).map_err(|mut error| { error.push("Dimension", "height"); error }),
                _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
            }
        }
        fn encoded_len(&self) -> usize {
            let mut len = 0;
            if !::proto_value::is_default(&self.width) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.width) }
            if !::proto_value::is_default(&self.height) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.height) }
            len
        }
        fn clear(&mut self) {
            self.width = 0i32;
            self.height = 0i32;
        }
    }
}
/// .aiserver.v1.ImageProto
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash)]
pub struct ImageProto {
    pub data: ::bytes::Bytes,
    pub dimension: ::core::option::Option<image_proto::Dimension>,
    pub uuid: ::alloc::string::String,
}
impl ::prost::Message for ImageProto {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.data) { ::prost::encoding::bytes::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.data, buf) }
        if let ::core::option::Option::Some(ref value) = self.dimension { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value, buf) }
        if !::proto_value::is_default(&self.uuid) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.uuid, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::bytes::merge(wire_type, &mut self.data, buf, ctx).map_err(|mut error| { error.push("ImageProto", "data"); error }),
            2 => if let ::core::option::Option::Some(ref mut value) = self.dimension { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.dimension = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("ImageProto", "dimension"); error }),
            3 => ::prost::encoding::string::merge(wire_type, &mut self.uuid, buf, ctx).map_err(|mut error| { error.push("ImageProto", "uuid"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.data) { len += ::prost::encoding::bytes::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.data) }
        if let ::core::option::Option::Some(ref value) = self.dimension { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value) }
        if !::proto_value::is_default(&self.uuid) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.uuid) }
        len
    }
    fn clear(&mut self) {
        self.data.clear();
        self.dimension = ::core::option::Option::None;
        self.uuid.clear();
    }
}
/// .aiserver.v1.ComposerExternalLink
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash)]
pub struct ComposerExternalLink {
    pub url: ::alloc::string::String,
    pub uuid: ::alloc::string::String,
    pub pdf_content: ::alloc::string::String,
    pub is_pdf: bool,
    pub filename: ::byte_str::ByteStr,
}
impl ::prost::Message for ComposerExternalLink {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.url) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.url, buf) }
        if !::proto_value::is_default(&self.uuid) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.uuid, buf) }
        if !::proto_value::is_default(&self.pdf_content) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.pdf_content, buf) }
        if !::proto_value::is_default(&self.is_pdf) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.is_pdf, buf) }
        if !::proto_value::is_default(&self.filename) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, &self.filename, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.url, buf, ctx).map_err(|mut error| { error.push("ComposerExternalLink", "url"); error }),
            2 => ::prost::encoding::string::merge(wire_type, &mut self.uuid, buf, ctx).map_err(|mut error| { error.push("ComposerExternalLink", "uuid"); error }),
            3 => ::prost::encoding::string::merge(wire_type, &mut self.pdf_content, buf, ctx).map_err(|mut error| { error.push("ComposerExternalLink", "pdf_content"); error }),
            4 => ::prost::encoding::bool::merge(wire_type, &mut self.is_pdf, buf, ctx).map_err(|mut error| { error.push("ComposerExternalLink", "is_pdf"); error }),
            5 => ::prost::encoding::string::merge(wire_type, &mut self.filename, buf, ctx).map_err(|mut error| { error.push("ComposerExternalLink", "filename"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.url) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.url) }
        if !::proto_value::is_default(&self.uuid) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.uuid) }
        if !::proto_value::is_default(&self.pdf_content) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.pdf_content) }
        if !::proto_value::is_default(&self.is_pdf) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.is_pdf) }
        if !::proto_value::is_default(&self.filename) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, &self.filename) }
        len
    }
    fn clear(&mut self) {
        self.url.clear();
        self.uuid.clear();
        self.pdf_content.clear();
        self.is_pdf = false;
        self.filename.clear();
    }
}
/// .aiserver.v1.LspSubgraphPosition
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct LspSubgraphPosition {
    #[serde(default)]
    pub line: i32,
    #[serde(default)]
    pub character: i32,
}
impl ::prost::Message for LspSubgraphPosition {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.line) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.line, buf) }
        if !::proto_value::is_default(&self.character) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.character, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::int32::merge(wire_type, &mut self.line, buf, ctx).map_err(|mut error| { error.push("LspSubgraphPosition", "line"); error }),
            2 => ::prost::encoding::int32::merge(wire_type, &mut self.character, buf, ctx).map_err(|mut error| { error.push("LspSubgraphPosition", "character"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.line) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.line) }
        if !::proto_value::is_default(&self.character) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.character) }
        len
    }
    fn clear(&mut self) {
        self.line = 0i32;
        self.character = 0i32;
    }
}
/// .aiserver.v1.LspSubgraphRange
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct LspSubgraphRange {
    #[serde(default)]
    pub start_line: i32,
    #[serde(default)]
    pub start_character: i32,
    #[serde(default)]
    pub end_line: i32,
    #[serde(default)]
    pub end_character: i32,
}
impl ::prost::Message for LspSubgraphRange {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.start_line) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.start_line, buf) }
        if !::proto_value::is_default(&self.start_character) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.start_character, buf) }
        if !::proto_value::is_default(&self.end_line) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.end_line, buf) }
        if !::proto_value::is_default(&self.end_character) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.end_character, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::int32::merge(wire_type, &mut self.start_line, buf, ctx).map_err(|mut error| { error.push("LspSubgraphRange", "start_line"); error }),
            2 => ::prost::encoding::int32::merge(wire_type, &mut self.start_character, buf, ctx).map_err(|mut error| { error.push("LspSubgraphRange", "start_character"); error }),
            3 => ::prost::encoding::int32::merge(wire_type, &mut self.end_line, buf, ctx).map_err(|mut error| { error.push("LspSubgraphRange", "end_line"); error }),
            4 => ::prost::encoding::int32::merge(wire_type, &mut self.end_character, buf, ctx).map_err(|mut error| { error.push("LspSubgraphRange", "end_character"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.start_line) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.start_line) }
        if !::proto_value::is_default(&self.start_character) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.start_character) }
        if !::proto_value::is_default(&self.end_line) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.end_line) }
        if !::proto_value::is_default(&self.end_character) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.end_character) }
        len
    }
    fn clear(&mut self) {
        self.start_line = 0i32;
        self.start_character = 0i32;
        self.end_line = 0i32;
        self.end_character = 0i32;
    }
}
/// .aiserver.v1.LspSubgraphContextItem
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct LspSubgraphContextItem {
    #[serde(default)]
    pub uri: ::core::option::Option<::alloc::string::String>,
    #[serde(default)]
    pub r#type: ::alloc::string::String,
    #[serde(default)]
    pub content: ::alloc::string::String,
    #[serde(default)]
    pub range: ::core::option::Option<LspSubgraphRange>,
}
impl ::prost::Message for LspSubgraphContextItem {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if let ::core::option::Option::Some(ref value) = self.uri { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, value, buf) }
        if !::proto_value::is_default(&self.r#type) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.r#type, buf) }
        if !::proto_value::is_default(&self.content) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.content, buf) }
        if let ::core::option::Option::Some(ref value) = self.range { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, value, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => if let ::core::option::Option::Some(ref mut value) = self.uri { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.uri = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("LspSubgraphContextItem", "uri"); error }),
            2 => ::prost::encoding::string::merge(wire_type, &mut self.r#type, buf, ctx).map_err(|mut error| { error.push("LspSubgraphContextItem", "type"); error }),
            3 => ::prost::encoding::string::merge(wire_type, &mut self.content, buf, ctx).map_err(|mut error| { error.push("LspSubgraphContextItem", "content"); error }),
            4 => if let ::core::option::Option::Some(ref mut value) = self.range { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.range = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("LspSubgraphContextItem", "range"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if let ::core::option::Option::Some(ref value) = self.uri { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, value) }
        if !::proto_value::is_default(&self.r#type) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.r#type) }
        if !::proto_value::is_default(&self.content) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.content) }
        if let ::core::option::Option::Some(ref value) = self.range { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, value) }
        len
    }
    fn clear(&mut self) {
        self.uri = ::core::option::Option::None;
        self.r#type.clear();
        self.content.clear();
        self.range = ::core::option::Option::None;
    }
}
/// .aiserver.v1.LspSubgraphFullContext
#[derive(Debug, Default, Clone, PartialEq, ::serde::Deserialize)]
pub struct LspSubgraphFullContext {
    #[serde(default)]
    pub uri: ::alloc::string::String,
    #[serde(default)]
    pub symbol_name: ::alloc::string::String,
    #[serde(default)]
    pub positions: ::alloc::vec::Vec<LspSubgraphPosition>,
    #[serde(default)]
    pub context_items: ::alloc::vec::Vec<LspSubgraphContextItem>,
    #[serde(default)]
    pub score: f32,
}
impl ::prost::Message for LspSubgraphFullContext {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.uri) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.uri, buf) }
        if !::proto_value::is_default(&self.symbol_name) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.symbol_name, buf) }
        if !::alloc::vec::Vec::is_empty(&self.positions) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.positions, buf) }
        if !::alloc::vec::Vec::is_empty(&self.context_items) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.context_items, buf) }
        if !::proto_value::is_default(&self.score) { ::prost::encoding::float::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, &self.score, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.uri, buf, ctx).map_err(|mut error| { error.push("LspSubgraphFullContext", "uri"); error }),
            2 => ::prost::encoding::string::merge(wire_type, &mut self.symbol_name, buf, ctx).map_err(|mut error| { error.push("LspSubgraphFullContext", "symbol_name"); error }),
            3 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.positions, buf, ctx).map_err(|mut error| { error.push("LspSubgraphFullContext", "positions"); error }),
            4 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.context_items, buf, ctx).map_err(|mut error| { error.push("LspSubgraphFullContext", "context_items"); error }),
            5 => ::prost::encoding::float::merge(wire_type, &mut self.score, buf, ctx).map_err(|mut error| { error.push("LspSubgraphFullContext", "score"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.uri) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.uri) }
        if !::proto_value::is_default(&self.symbol_name) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.symbol_name) }
        if !::alloc::vec::Vec::is_empty(&self.positions) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.positions) }
        if !::alloc::vec::Vec::is_empty(&self.context_items) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.context_items) }
        if !::proto_value::is_default(&self.score) { len += ::prost::encoding::float::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, &self.score) }
        len
    }
    fn clear(&mut self) {
        self.uri.clear();
        self.symbol_name.clear();
        self.positions.clear();
        self.context_items.clear();
        self.score = 0.0f32;
    }
}
/// .aiserver.v1.FSUploadErrorType
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde::Serialize)]
pub enum FsUploadErrorType {
    #[default]
    #[serde(rename = "unspecified")]
    Unspecified = 0,
    #[serde(rename = "non_existant")]
    NonExistant = 1,
    #[serde(rename = "hash_mismatch")]
    HashMismatch = 2,
}
impl ::core::convert::From::<FsUploadErrorType> for i32 {
    #[inline]
    fn from(value: FsUploadErrorType) -> i32 { value as i32 }
}
impl ::core::convert::TryFrom::<i32> for FsUploadErrorType {
    type Error = ();
    #[inline]
    fn try_from(value: i32) -> ::core::result::Result<Self, ()> {
        match value {
            0 => ::core::result::Result::Ok(Self::Unspecified),
            1 => ::core::result::Result::Ok(Self::NonExistant),
            2 => ::core::result::Result::Ok(Self::HashMismatch),
            _ => ::core::result::Result::Err(()),
        }
    }
}
/// .aiserver.v1.FSSyncErrorType
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde::Serialize)]
pub enum FsSyncErrorType {
    #[default]
    #[serde(rename = "unspecified")]
    Unspecified = 0,
    #[serde(rename = "non_existant")]
    NonExistant = 1,
    #[serde(rename = "hash_mismatch")]
    HashMismatch = 2,
}
impl ::core::convert::From::<FsSyncErrorType> for i32 {
    #[inline]
    fn from(value: FsSyncErrorType) -> i32 { value as i32 }
}
impl ::core::convert::TryFrom::<i32> for FsSyncErrorType {
    type Error = ();
    #[inline]
    fn try_from(value: i32) -> ::core::result::Result<Self, ()> {
        match value {
            0 => ::core::result::Result::Ok(Self::Unspecified),
            1 => ::core::result::Result::Ok(Self::NonExistant),
            2 => ::core::result::Result::Ok(Self::HashMismatch),
            _ => ::core::result::Result::Err(()),
        }
    }
}
/// .aiserver.v1.FSUploadFileRequest
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct FsUploadFileRequest {
    #[serde(default)]
    pub uuid: ::alloc::string::String,
    #[serde(default)]
    pub relative_workspace_path: ::alloc::string::String,
    #[serde(default)]
    pub contents: ::alloc::string::String,
    #[serde(default)]
    pub model_version: i32,
    #[serde(default)]
    pub sha256_hash: ::core::option::Option<::alloc::string::String>,
}
impl ::prost::Message for FsUploadFileRequest {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.uuid) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.uuid, buf) }
        if !::proto_value::is_default(&self.relative_workspace_path) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.relative_workspace_path, buf) }
        if !::proto_value::is_default(&self.contents) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.contents, buf) }
        if !::proto_value::is_default(&self.model_version) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.model_version, buf) }
        if let ::core::option::Option::Some(ref value) = self.sha256_hash { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, value, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.uuid, buf, ctx).map_err(|mut error| { error.push("FSUploadFileRequest", "uuid"); error }),
            2 => ::prost::encoding::string::merge(wire_type, &mut self.relative_workspace_path, buf, ctx).map_err(|mut error| { error.push("FSUploadFileRequest", "relative_workspace_path"); error }),
            3 => ::prost::encoding::string::merge(wire_type, &mut self.contents, buf, ctx).map_err(|mut error| { error.push("FSUploadFileRequest", "contents"); error }),
            4 => ::prost::encoding::int32::merge(wire_type, &mut self.model_version, buf, ctx).map_err(|mut error| { error.push("FSUploadFileRequest", "model_version"); error }),
            5 => if let ::core::option::Option::Some(ref mut value) = self.sha256_hash { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.sha256_hash = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("FSUploadFileRequest", "sha256_hash"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.uuid) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.uuid) }
        if !::proto_value::is_default(&self.relative_workspace_path) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.relative_workspace_path) }
        if !::proto_value::is_default(&self.contents) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.contents) }
        if !::proto_value::is_default(&self.model_version) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.model_version) }
        if let ::core::option::Option::Some(ref value) = self.sha256_hash { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, value) }
        len
    }
    fn clear(&mut self) {
        self.uuid.clear();
        self.relative_workspace_path.clear();
        self.contents.clear();
        self.model_version = 0i32;
        self.sha256_hash = ::core::option::Option::None;
    }
}
/// .aiserver.v1.FSUploadFileResponse
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash, ::serde::Serialize)]
pub struct FsUploadFileResponse {
    #[serde(skip_serializing_if = "::proto_value::is_default")]
    pub error: ::proto_value::Enum<FsUploadErrorType>,
}
impl ::prost::Message for FsUploadFileResponse {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) { if !::proto_value::is_default(&self.error) { ::prost::encoding::r#enum::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.error, buf) }     }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::r#enum::merge(wire_type, &mut self.error, buf, ctx).map_err(|mut error| { error.push("FSUploadFileResponse", "error"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize { if !::proto_value::is_default(&self.error) { ::prost::encoding::r#enum::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.error) } else { 0 } }
    fn clear(&mut self) { self.error = ::proto_value::Enum::default() }
}
/// .aiserver.v1.FilesyncUpdateWithModelVersion
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct FilesyncUpdateWithModelVersion {
    #[serde(default)]
    pub model_version: i32,
    #[serde(default)]
    pub relative_workspace_path: ::alloc::string::String,
    #[serde(default)]
    pub updates: ::alloc::vec::Vec<SingleUpdateRequest>,
    #[serde(default)]
    pub expected_file_length: i32,
}
impl ::prost::Message for FilesyncUpdateWithModelVersion {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.model_version) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.model_version, buf) }
        if !::proto_value::is_default(&self.relative_workspace_path) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.relative_workspace_path, buf) }
        if !::alloc::vec::Vec::is_empty(&self.updates) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.updates, buf) }
        if !::proto_value::is_default(&self.expected_file_length) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.expected_file_length, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::int32::merge(wire_type, &mut self.model_version, buf, ctx).map_err(|mut error| { error.push("FilesyncUpdateWithModelVersion", "model_version"); error }),
            2 => ::prost::encoding::string::merge(wire_type, &mut self.relative_workspace_path, buf, ctx).map_err(|mut error| { error.push("FilesyncUpdateWithModelVersion", "relative_workspace_path"); error }),
            3 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.updates, buf, ctx).map_err(|mut error| { error.push("FilesyncUpdateWithModelVersion", "updates"); error }),
            4 => ::prost::encoding::int32::merge(wire_type, &mut self.expected_file_length, buf, ctx).map_err(|mut error| { error.push("FilesyncUpdateWithModelVersion", "expected_file_length"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.model_version) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.model_version) }
        if !::proto_value::is_default(&self.relative_workspace_path) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.relative_workspace_path) }
        if !::alloc::vec::Vec::is_empty(&self.updates) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.updates) }
        if !::proto_value::is_default(&self.expected_file_length) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.expected_file_length) }
        len
    }
    fn clear(&mut self) {
        self.model_version = 0i32;
        self.relative_workspace_path.clear();
        self.updates.clear();
        self.expected_file_length = 0i32;
    }
}
/// .aiserver.v1.SingleUpdateRequest
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct SingleUpdateRequest {
    #[serde(default)]
    pub start_position: i32,
    #[serde(default)]
    pub end_position: i32,
    #[serde(default)]
    pub change_length: i32,
    #[serde(default)]
    pub replaced_string: ::alloc::string::String,
    #[serde(default)]
    pub range: ::core::option::Option<SimpleRange>,
}
impl ::prost::Message for SingleUpdateRequest {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.start_position) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.start_position, buf) }
        if !::proto_value::is_default(&self.end_position) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.end_position, buf) }
        if !::proto_value::is_default(&self.change_length) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.change_length, buf) }
        if !::proto_value::is_default(&self.replaced_string) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.replaced_string, buf) }
        if let ::core::option::Option::Some(ref value) = self.range { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, value, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::int32::merge(wire_type, &mut self.start_position, buf, ctx).map_err(|mut error| { error.push("SingleUpdateRequest", "start_position"); error }),
            2 => ::prost::encoding::int32::merge(wire_type, &mut self.end_position, buf, ctx).map_err(|mut error| { error.push("SingleUpdateRequest", "end_position"); error }),
            3 => ::prost::encoding::int32::merge(wire_type, &mut self.change_length, buf, ctx).map_err(|mut error| { error.push("SingleUpdateRequest", "change_length"); error }),
            4 => ::prost::encoding::string::merge(wire_type, &mut self.replaced_string, buf, ctx).map_err(|mut error| { error.push("SingleUpdateRequest", "replaced_string"); error }),
            5 => if let ::core::option::Option::Some(ref mut value) = self.range { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.range = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("SingleUpdateRequest", "range"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.start_position) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.start_position) }
        if !::proto_value::is_default(&self.end_position) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.end_position) }
        if !::proto_value::is_default(&self.change_length) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.change_length) }
        if !::proto_value::is_default(&self.replaced_string) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.replaced_string) }
        if let ::core::option::Option::Some(ref value) = self.range { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, value) }
        len
    }
    fn clear(&mut self) {
        self.start_position = 0i32;
        self.end_position = 0i32;
        self.change_length = 0i32;
        self.replaced_string.clear();
        self.range = ::core::option::Option::None;
    }
}
/// .aiserver.v1.FSSyncFileRequest
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct FsSyncFileRequest {
    #[serde(default)]
    pub uuid: ::alloc::string::String,
    #[serde(default)]
    pub relative_workspace_path: ::alloc::string::String,
    #[serde(default)]
    pub model_version: i32,
    #[serde(default)]
    pub filesync_updates: ::alloc::vec::Vec<FilesyncUpdateWithModelVersion>,
    #[serde(default)]
    pub sha256_hash: ::alloc::string::String,
}
impl ::prost::Message for FsSyncFileRequest {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.uuid) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.uuid, buf) }
        if !::proto_value::is_default(&self.relative_workspace_path) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.relative_workspace_path, buf) }
        if !::proto_value::is_default(&self.model_version) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.model_version, buf) }
        if !::alloc::vec::Vec::is_empty(&self.filesync_updates) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.filesync_updates, buf) }
        if !::proto_value::is_default(&self.sha256_hash) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, &self.sha256_hash, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.uuid, buf, ctx).map_err(|mut error| { error.push("FSSyncFileRequest", "uuid"); error }),
            2 => ::prost::encoding::string::merge(wire_type, &mut self.relative_workspace_path, buf, ctx).map_err(|mut error| { error.push("FSSyncFileRequest", "relative_workspace_path"); error }),
            3 => ::prost::encoding::int32::merge(wire_type, &mut self.model_version, buf, ctx).map_err(|mut error| { error.push("FSSyncFileRequest", "model_version"); error }),
            4 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.filesync_updates, buf, ctx).map_err(|mut error| { error.push("FSSyncFileRequest", "filesync_updates"); error }),
            5 => ::prost::encoding::string::merge(wire_type, &mut self.sha256_hash, buf, ctx).map_err(|mut error| { error.push("FSSyncFileRequest", "sha256_hash"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.uuid) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.uuid) }
        if !::proto_value::is_default(&self.relative_workspace_path) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.relative_workspace_path) }
        if !::proto_value::is_default(&self.model_version) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.model_version) }
        if !::alloc::vec::Vec::is_empty(&self.filesync_updates) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.filesync_updates) }
        if !::proto_value::is_default(&self.sha256_hash) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, &self.sha256_hash) }
        len
    }
    fn clear(&mut self) {
        self.uuid.clear();
        self.relative_workspace_path.clear();
        self.model_version = 0i32;
        self.filesync_updates.clear();
        self.sha256_hash.clear();
    }
}
/// .aiserver.v1.FSSyncFileResponse
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash, ::serde::Serialize)]
pub struct FsSyncFileResponse {
    #[serde(skip_serializing_if = "::proto_value::is_default")]
    pub error: ::proto_value::Enum<FsSyncErrorType>,
}
impl ::prost::Message for FsSyncFileResponse {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) { if !::proto_value::is_default(&self.error) { ::prost::encoding::r#enum::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.error, buf) }     }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::r#enum::merge(wire_type, &mut self.error, buf, ctx).map_err(|mut error| { error.push("FSSyncFileResponse", "error"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize { if !::proto_value::is_default(&self.error) { ::prost::encoding::r#enum::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.error) } else { 0 } }
    fn clear(&mut self) { self.error = ::proto_value::Enum::default() }
}
/// .aiserver.v1.CodeResult
#[derive(Debug, Default, Clone, PartialEq, ::serde::Deserialize)]
pub struct CodeResult {
    #[serde(default)]
    pub code_block: ::core::option::Option<CodeBlock>,
    #[serde(default)]
    pub score: f32,
}
impl ::prost::Message for CodeResult {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if let ::core::option::Option::Some(ref value) = self.code_block { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, value, buf) }
        if !::proto_value::is_default(&self.score) { ::prost::encoding::float::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.score, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => if let ::core::option::Option::Some(ref mut value) = self.code_block { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.code_block = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CodeResult", "code_block"); error }),
            2 => ::prost::encoding::float::merge(wire_type, &mut self.score, buf, ctx).map_err(|mut error| { error.push("CodeResult", "score"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if let ::core::option::Option::Some(ref value) = self.code_block { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, value) }
        if !::proto_value::is_default(&self.score) { len += ::prost::encoding::float::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.score) }
        len
    }
    fn clear(&mut self) {
        self.code_block = ::core::option::Option::None;
        self.score = 0.0f32;
    }
}
/// .aiserver.v1.CppIntentInfo
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct CppIntentInfo {
    #[serde(default)]
    pub source: ::alloc::string::String,
}
impl ::prost::Message for CppIntentInfo {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) { if !::proto_value::is_default(&self.source) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.source, buf) }     }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.source, buf, ctx).map_err(|mut error| { error.push("CppIntentInfo", "source"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize { if !::proto_value::is_default(&self.source) { ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.source) } else { 0 } }
    fn clear(&mut self) { self.source.clear() }
}
/// .aiserver.v1.LspSuggestion
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct LspSuggestion {
    #[serde(default)]
    pub label: ::alloc::string::String,
}
impl ::prost::Message for LspSuggestion {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) { if !::proto_value::is_default(&self.label) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.label, buf) }     }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.label, buf, ctx).map_err(|mut error| { error.push("LspSuggestion", "label"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize { if !::proto_value::is_default(&self.label) { ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.label) } else { 0 } }
    fn clear(&mut self) { self.label.clear() }
}
/// .aiserver.v1.LspSuggestedItems
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct LspSuggestedItems {
    #[serde(default)]
    pub suggestions: ::alloc::vec::Vec<LspSuggestion>,
}
impl ::prost::Message for LspSuggestedItems {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) { if !::alloc::vec::Vec::is_empty(&self.suggestions) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.suggestions, buf) }     }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.suggestions, buf, ctx).map_err(|mut error| { error.push("LspSuggestedItems", "suggestions"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize { if !::alloc::vec::Vec::is_empty(&self.suggestions) { ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.suggestions) } else { 0 } }
    fn clear(&mut self) { self.suggestions.clear() }
}
/// Nested message and enum types in [`StreamCppRequest`].
pub mod stream_cpp_request {
    /// .aiserver.v1.StreamCppRequest.ControlToken
    #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde::Deserialize)]
    pub enum ControlToken {
        #[default]
        #[serde(rename = "unspecified")]
        Unspecified = 0,
        #[serde(rename = "quiet")]
        Quiet = 1,
        #[serde(rename = "loud")]
        Loud = 2,
        #[serde(rename = "op")]
        Op = 3,
    }
    impl ::core::convert::From::<ControlToken> for i32 {
        #[inline]
        fn from(value: ControlToken) -> i32 { value as i32 }
    }
    impl ::core::convert::TryFrom::<i32> for ControlToken {
        type Error = ();
        #[inline]
        fn try_from(value: i32) -> ::core::result::Result<Self, ()> {
            match value {
                0 => ::core::result::Result::Ok(Self::Unspecified),
                1 => ::core::result::Result::Ok(Self::Quiet),
                2 => ::core::result::Result::Ok(Self::Loud),
                3 => ::core::result::Result::Ok(Self::Op),
                _ => ::core::result::Result::Err(()),
            }
        }
    }
}
/// .aiserver.v1.StreamCppRequest
#[derive(Debug, Default, Clone, PartialEq, ::serde::Deserialize)]
pub struct StreamCppRequest {
    #[serde(default)]
    pub current_file: ::core::option::Option<CurrentFileInfo>,
    #[serde(default)]
    pub diff_history: ::alloc::vec::Vec<::alloc::string::String>,
    #[serde(default)]
    pub model_name: ::core::option::Option<::alloc::string::String>,
    #[serde(default)]
    pub linter_errors: ::core::option::Option<LinterErrors>,
    #[serde(default)]
    pub context_items: ::alloc::vec::Vec<CppContextItem>,
    #[serde(default)]
    pub diff_history_keys: ::alloc::vec::Vec<::alloc::string::String>,
    #[serde(default)]
    pub give_debug_output: ::core::option::Option<bool>,
    #[serde(default)]
    pub file_diff_histories: ::alloc::vec::Vec<CppFileDiffHistory>,
    #[serde(default)]
    pub merged_diff_histories: ::alloc::vec::Vec<CppFileDiffHistory>,
    #[serde(default)]
    pub block_diff_patches: ::alloc::vec::Vec<BlockDiffPatch>,
    #[serde(default)]
    pub is_nightly: ::core::option::Option<bool>,
    #[serde(default)]
    pub is_debug: ::core::option::Option<bool>,
    #[serde(default)]
    pub immediately_ack: ::core::option::Option<bool>,
    #[serde(default)]
    pub enable_more_context: ::core::option::Option<bool>,
    #[serde(default)]
    pub parameter_hints: ::alloc::vec::Vec<CppParameterHint>,
    #[serde(default)]
    pub lsp_contexts: ::alloc::vec::Vec<LspSubgraphFullContext>,
    #[serde(default)]
    pub cpp_intent_info: ::core::option::Option<CppIntentInfo>,
    #[serde(default)]
    pub workspace_id: ::core::option::Option<::alloc::string::String>,
    #[serde(default)]
    pub additional_files: ::alloc::vec::Vec<AdditionalFile>,
    #[serde(default)]
    pub control_token: ::core::option::Option<::proto_value::Enum<stream_cpp_request::ControlToken>>,
    #[serde(default)]
    pub client_time: ::core::option::Option<f64>,
    #[serde(default)]
    pub filesync_updates: ::alloc::vec::Vec<FilesyncUpdateWithModelVersion>,
    #[serde(default)]
    pub time_since_request_start: f64,
    #[serde(default)]
    pub time_at_request_send: f64,
    #[serde(default)]
    pub client_timezone_offset: ::core::option::Option<f64>,
    #[serde(default)]
    pub lsp_suggested_items: ::core::option::Option<LspSuggestedItems>,
    #[serde(default)]
    pub supports_cpt: ::core::option::Option<bool>,
    #[serde(default)]
    pub supports_crlf_cpt: ::core::option::Option<bool>,
    #[serde(default)]
    pub code_results: ::alloc::vec::Vec<CodeResult>,
}
impl ::prost::Message for StreamCppRequest {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if let ::core::option::Option::Some(ref value) = self.current_file { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, value, buf) }
        if !::alloc::vec::Vec::is_empty(&self.diff_history) { ::prost::encoding::string::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.diff_history, buf) }
        if let ::core::option::Option::Some(ref value) = self.model_name { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.linter_errors { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, value, buf) }
        if !::alloc::vec::Vec::is_empty(&self.diff_history_keys) { ::prost::encoding::string::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, &self.diff_history_keys, buf) }
        if let ::core::option::Option::Some(ref value) = self.give_debug_output { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(6) }, value, buf) }
        if !::alloc::vec::Vec::is_empty(&self.file_diff_histories) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(7) }, &self.file_diff_histories, buf) }
        if !::alloc::vec::Vec::is_empty(&self.merged_diff_histories) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(8) }, &self.merged_diff_histories, buf) }
        if !::alloc::vec::Vec::is_empty(&self.block_diff_patches) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(9) }, &self.block_diff_patches, buf) }
        if let ::core::option::Option::Some(ref value) = self.is_nightly { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(10) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.is_debug { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(11) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.immediately_ack { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(12) }, value, buf) }
        if !::alloc::vec::Vec::is_empty(&self.context_items) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(13) }, &self.context_items, buf) }
        if !::alloc::vec::Vec::is_empty(&self.parameter_hints) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(14) }, &self.parameter_hints, buf) }
        if !::alloc::vec::Vec::is_empty(&self.lsp_contexts) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(15) }, &self.lsp_contexts, buf) }
        if let ::core::option::Option::Some(ref value) = self.cpp_intent_info { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(16) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.enable_more_context { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(17) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.workspace_id { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(18) }, value, buf) }
        if !::alloc::vec::Vec::is_empty(&self.additional_files) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(19) }, &self.additional_files, buf) }
        if let ::core::option::Option::Some(ref value) = self.control_token { ::prost::encoding::r#enum::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(20) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.client_time { ::prost::encoding::double::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(21) }, value, buf) }
        if !::alloc::vec::Vec::is_empty(&self.filesync_updates) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(22) }, &self.filesync_updates, buf) }
        if !::proto_value::is_default(&self.time_since_request_start) { ::prost::encoding::double::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(23) }, &self.time_since_request_start, buf) }
        if !::proto_value::is_default(&self.time_at_request_send) { ::prost::encoding::double::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(24) }, &self.time_at_request_send, buf) }
        if let ::core::option::Option::Some(ref value) = self.client_timezone_offset { ::prost::encoding::double::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(25) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.lsp_suggested_items { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(26) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.supports_cpt { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(27) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.supports_crlf_cpt { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(28) }, value, buf) }
        if !::alloc::vec::Vec::is_empty(&self.code_results) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(29) }, &self.code_results, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => if let ::core::option::Option::Some(ref mut value) = self.current_file { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.current_file = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppRequest", "current_file"); error }),
            2 => ::prost::encoding::string::merge_repeated(wire_type, &mut self.diff_history, buf, ctx).map_err(|mut error| { error.push("StreamCppRequest", "diff_history"); error }),
            3 => if let ::core::option::Option::Some(ref mut value) = self.model_name { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.model_name = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppRequest", "model_name"); error }),
            4 => if let ::core::option::Option::Some(ref mut value) = self.linter_errors { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.linter_errors = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppRequest", "linter_errors"); error }),
            5 => ::prost::encoding::string::merge_repeated(wire_type, &mut self.diff_history_keys, buf, ctx).map_err(|mut error| { error.push("StreamCppRequest", "diff_history_keys"); error }),
            6 => if let ::core::option::Option::Some(ref mut value) = self.give_debug_output { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.give_debug_output = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppRequest", "give_debug_output"); error }),
            7 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.file_diff_histories, buf, ctx).map_err(|mut error| { error.push("StreamCppRequest", "file_diff_histories"); error }),
            8 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.merged_diff_histories, buf, ctx).map_err(|mut error| { error.push("StreamCppRequest", "merged_diff_histories"); error }),
            9 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.block_diff_patches, buf, ctx).map_err(|mut error| { error.push("StreamCppRequest", "block_diff_patches"); error }),
            10 => if let ::core::option::Option::Some(ref mut value) = self.is_nightly { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.is_nightly = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppRequest", "is_nightly"); error }),
            11 => if let ::core::option::Option::Some(ref mut value) = self.is_debug { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.is_debug = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppRequest", "is_debug"); error }),
            12 => if let ::core::option::Option::Some(ref mut value) = self.immediately_ack { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.immediately_ack = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppRequest", "immediately_ack"); error }),
            13 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.context_items, buf, ctx).map_err(|mut error| { error.push("StreamCppRequest", "context_items"); error }),
            14 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.parameter_hints, buf, ctx).map_err(|mut error| { error.push("StreamCppRequest", "parameter_hints"); error }),
            15 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.lsp_contexts, buf, ctx).map_err(|mut error| { error.push("StreamCppRequest", "lsp_contexts"); error }),
            16 => if let ::core::option::Option::Some(ref mut value) = self.cpp_intent_info { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.cpp_intent_info = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppRequest", "cpp_intent_info"); error }),
            17 => if let ::core::option::Option::Some(ref mut value) = self.enable_more_context { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.enable_more_context = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppRequest", "enable_more_context"); error }),
            18 => if let ::core::option::Option::Some(ref mut value) = self.workspace_id { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.workspace_id = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppRequest", "workspace_id"); error }),
            19 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.additional_files, buf, ctx).map_err(|mut error| { error.push("StreamCppRequest", "additional_files"); error }),
            20 => if let ::core::option::Option::Some(ref mut value) = self.control_token { ::prost::encoding::r#enum::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::r#enum::merge(wire_type, &mut value, buf, ctx).map(|_| self.control_token = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppRequest", "control_token"); error }),
            21 => if let ::core::option::Option::Some(ref mut value) = self.client_time { ::prost::encoding::double::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::double::merge(wire_type, &mut value, buf, ctx).map(|_| self.client_time = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppRequest", "client_time"); error }),
            22 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.filesync_updates, buf, ctx).map_err(|mut error| { error.push("StreamCppRequest", "filesync_updates"); error }),
            23 => ::prost::encoding::double::merge(wire_type, &mut self.time_since_request_start, buf, ctx).map_err(|mut error| { error.push("StreamCppRequest", "time_since_request_start"); error }),
            24 => ::prost::encoding::double::merge(wire_type, &mut self.time_at_request_send, buf, ctx).map_err(|mut error| { error.push("StreamCppRequest", "time_at_request_send"); error }),
            25 => if let ::core::option::Option::Some(ref mut value) = self.client_timezone_offset { ::prost::encoding::double::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::double::merge(wire_type, &mut value, buf, ctx).map(|_| self.client_timezone_offset = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppRequest", "client_timezone_offset"); error }),
            26 => if let ::core::option::Option::Some(ref mut value) = self.lsp_suggested_items { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.lsp_suggested_items = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppRequest", "lsp_suggested_items"); error }),
            27 => if let ::core::option::Option::Some(ref mut value) = self.supports_cpt { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.supports_cpt = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppRequest", "supports_cpt"); error }),
            28 => if let ::core::option::Option::Some(ref mut value) = self.supports_crlf_cpt { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.supports_crlf_cpt = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppRequest", "supports_crlf_cpt"); error }),
            29 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.code_results, buf, ctx).map_err(|mut error| { error.push("StreamCppRequest", "code_results"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if let ::core::option::Option::Some(ref value) = self.current_file { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, value) }
        if !::alloc::vec::Vec::is_empty(&self.diff_history) { len += ::prost::encoding::string::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.diff_history) }
        if let ::core::option::Option::Some(ref value) = self.model_name { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, value) }
        if let ::core::option::Option::Some(ref value) = self.linter_errors { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, value) }
        if !::alloc::vec::Vec::is_empty(&self.diff_history_keys) { len += ::prost::encoding::string::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, &self.diff_history_keys) }
        if let ::core::option::Option::Some(ref value) = self.give_debug_output { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(6) }, value) }
        if !::alloc::vec::Vec::is_empty(&self.file_diff_histories) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(7) }, &self.file_diff_histories) }
        if !::alloc::vec::Vec::is_empty(&self.merged_diff_histories) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(8) }, &self.merged_diff_histories) }
        if !::alloc::vec::Vec::is_empty(&self.block_diff_patches) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(9) }, &self.block_diff_patches) }
        if let ::core::option::Option::Some(ref value) = self.is_nightly { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(10) }, value) }
        if let ::core::option::Option::Some(ref value) = self.is_debug { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(11) }, value) }
        if let ::core::option::Option::Some(ref value) = self.immediately_ack { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(12) }, value) }
        if !::alloc::vec::Vec::is_empty(&self.context_items) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(13) }, &self.context_items) }
        if !::alloc::vec::Vec::is_empty(&self.parameter_hints) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(14) }, &self.parameter_hints) }
        if !::alloc::vec::Vec::is_empty(&self.lsp_contexts) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(15) }, &self.lsp_contexts) }
        if let ::core::option::Option::Some(ref value) = self.cpp_intent_info { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(16) }, value) }
        if let ::core::option::Option::Some(ref value) = self.enable_more_context { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(17) }, value) }
        if let ::core::option::Option::Some(ref value) = self.workspace_id { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(18) }, value) }
        if !::alloc::vec::Vec::is_empty(&self.additional_files) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(19) }, &self.additional_files) }
        if let ::core::option::Option::Some(ref value) = self.control_token { len += ::prost::encoding::r#enum::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(20) }, value) }
        if let ::core::option::Option::Some(ref value) = self.client_time { len += ::prost::encoding::double::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(21) }, value) }
        if !::alloc::vec::Vec::is_empty(&self.filesync_updates) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(22) }, &self.filesync_updates) }
        if !::proto_value::is_default(&self.time_since_request_start) { len += ::prost::encoding::double::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(23) }, &self.time_since_request_start) }
        if !::proto_value::is_default(&self.time_at_request_send) { len += ::prost::encoding::double::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(24) }, &self.time_at_request_send) }
        if let ::core::option::Option::Some(ref value) = self.client_timezone_offset { len += ::prost::encoding::double::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(25) }, value) }
        if let ::core::option::Option::Some(ref value) = self.lsp_suggested_items { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(26) }, value) }
        if let ::core::option::Option::Some(ref value) = self.supports_cpt { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(27) }, value) }
        if let ::core::option::Option::Some(ref value) = self.supports_crlf_cpt { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(28) }, value) }
        if !::alloc::vec::Vec::is_empty(&self.code_results) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(29) }, &self.code_results) }
        len
    }
    fn clear(&mut self) {
        self.current_file = ::core::option::Option::None;
        self.diff_history.clear();
        self.model_name = ::core::option::Option::None;
        self.linter_errors = ::core::option::Option::None;
        self.context_items.clear();
        self.diff_history_keys.clear();
        self.give_debug_output = ::core::option::Option::None;
        self.file_diff_histories.clear();
        self.merged_diff_histories.clear();
        self.block_diff_patches.clear();
        self.is_nightly = ::core::option::Option::None;
        self.is_debug = ::core::option::Option::None;
        self.immediately_ack = ::core::option::Option::None;
        self.enable_more_context = ::core::option::Option::None;
        self.parameter_hints.clear();
        self.lsp_contexts.clear();
        self.cpp_intent_info = ::core::option::Option::None;
        self.workspace_id = ::core::option::Option::None;
        self.additional_files.clear();
        self.control_token = ::core::option::Option::None;
        self.client_time = ::core::option::Option::None;
        self.filesync_updates.clear();
        self.time_since_request_start = 0.0f64;
        self.time_at_request_send = 0.0f64;
        self.client_timezone_offset = ::core::option::Option::None;
        self.lsp_suggested_items = ::core::option::Option::None;
        self.supports_cpt = ::core::option::Option::None;
        self.supports_crlf_cpt = ::core::option::Option::None;
        self.code_results.clear();
    }
}
/// Nested message and enum types in [`StreamCppResponse`].
pub mod stream_cpp_response {
    /// .aiserver.v1.StreamCppResponse.CursorPredictionTarget
    #[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Serialize)]
    pub struct CursorPredictionTarget {
        #[serde(rename = "relativePath", skip_serializing_if = "::proto_value::is_default")]
        pub relative_path: ::alloc::string::String,
        #[serde(rename = "lineNumberOneIndexed", skip_serializing_if = "::proto_value::is_default")]
        pub line_number_one_indexed: i32,
        #[serde(rename = "expectedContent", skip_serializing_if = "::proto_value::is_default")]
        pub expected_content: ::alloc::string::String,
        #[serde(rename = "shouldRetriggerCpp", skip_serializing_if = "::proto_value::is_default")]
        pub should_retrigger_cpp: bool,
    }
    impl ::prost::Message for CursorPredictionTarget {
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if !::proto_value::is_default(&self.relative_path) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.relative_path, buf) }
            if !::proto_value::is_default(&self.line_number_one_indexed) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.line_number_one_indexed, buf) }
            if !::proto_value::is_default(&self.expected_content) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.expected_content, buf) }
            if !::proto_value::is_default(&self.should_retrigger_cpp) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.should_retrigger_cpp, buf) }
        }
        fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
            match number.get() {
                1 => ::prost::encoding::string::merge(wire_type, &mut self.relative_path, buf, ctx).map_err(|mut error| { error.push("CursorPredictionTarget", "relative_path"); error }),
                2 => ::prost::encoding::int32::merge(wire_type, &mut self.line_number_one_indexed, buf, ctx).map_err(|mut error| { error.push("CursorPredictionTarget", "line_number_one_indexed"); error }),
                3 => ::prost::encoding::string::merge(wire_type, &mut self.expected_content, buf, ctx).map_err(|mut error| { error.push("CursorPredictionTarget", "expected_content"); error }),
                4 => ::prost::encoding::bool::merge(wire_type, &mut self.should_retrigger_cpp, buf, ctx).map_err(|mut error| { error.push("CursorPredictionTarget", "should_retrigger_cpp"); error }),
                _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
            }
        }
        fn encoded_len(&self) -> usize {
            let mut len = 0;
            if !::proto_value::is_default(&self.relative_path) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.relative_path) }
            if !::proto_value::is_default(&self.line_number_one_indexed) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.line_number_one_indexed) }
            if !::proto_value::is_default(&self.expected_content) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.expected_content) }
            if !::proto_value::is_default(&self.should_retrigger_cpp) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.should_retrigger_cpp) }
            len
        }
        fn clear(&mut self) {
            self.relative_path.clear();
            self.line_number_one_indexed = 0i32;
            self.expected_content.clear();
            self.should_retrigger_cpp = false;
        }
    }
    /// .aiserver.v1.StreamCppResponse.ModelInfo
    #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash, ::serde::Serialize)]
    pub struct ModelInfo {
        #[serde(rename = "isFusedCursorPredictionModel", skip_serializing_if = "::proto_value::is_default")]
        pub is_fused_cursor_prediction_model: bool,
        #[serde(rename = "isMultidiffModel", skip_serializing_if = "::proto_value::is_default")]
        pub is_multidiff_model: bool,
    }
    impl ::prost::Message for ModelInfo {
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if !::proto_value::is_default(&self.is_fused_cursor_prediction_model) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.is_fused_cursor_prediction_model, buf) }
            if !::proto_value::is_default(&self.is_multidiff_model) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.is_multidiff_model, buf) }
        }
        fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
            match number.get() {
                1 => ::prost::encoding::bool::merge(wire_type, &mut self.is_fused_cursor_prediction_model, buf, ctx).map_err(|mut error| { error.push("ModelInfo", "is_fused_cursor_prediction_model"); error }),
                2 => ::prost::encoding::bool::merge(wire_type, &mut self.is_multidiff_model, buf, ctx).map_err(|mut error| { error.push("ModelInfo", "is_multidiff_model"); error }),
                _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
            }
        }
        fn encoded_len(&self) -> usize {
            let mut len = 0;
            if !::proto_value::is_default(&self.is_fused_cursor_prediction_model) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.is_fused_cursor_prediction_model) }
            if !::proto_value::is_default(&self.is_multidiff_model) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.is_multidiff_model) }
            len
        }
        fn clear(&mut self) {
            self.is_fused_cursor_prediction_model = false;
            self.is_multidiff_model = false;
        }
    }
}
/// .aiserver.v1.StreamCppResponse
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Serialize)]
pub struct StreamCppResponse {
    #[serde(skip_serializing_if = "::proto_value::is_default")]
    pub text: ::alloc::string::String,
    #[serde(rename = "suggestionStartLine", skip_serializing_if = "::core::option::Option::is_none")]
    pub suggestion_start_line: ::core::option::Option<i32>,
    #[serde(rename = "suggestionConfidence", skip_serializing_if = "::core::option::Option::is_none")]
    pub suggestion_confidence: ::core::option::Option<i32>,
    #[serde(rename = "doneStream", skip_serializing_if = "::core::option::Option::is_none")]
    pub done_stream: ::core::option::Option<bool>,
    #[serde(rename = "debugModelOutput", skip_serializing_if = "::core::option::Option::is_none")]
    pub debug_model_output: ::core::option::Option<::alloc::string::String>,
    #[serde(rename = "debugModelInput", skip_serializing_if = "::core::option::Option::is_none")]
    pub debug_model_input: ::core::option::Option<::alloc::string::String>,
    #[serde(rename = "debugStreamTime", skip_serializing_if = "::core::option::Option::is_none")]
    pub debug_stream_time: ::core::option::Option<::alloc::string::String>,
    #[serde(rename = "debugTotalTime", skip_serializing_if = "::core::option::Option::is_none")]
    pub debug_total_time: ::core::option::Option<::alloc::string::String>,
    #[serde(rename = "debugTtftTime", skip_serializing_if = "::core::option::Option::is_none")]
    pub debug_ttft_time: ::core::option::Option<::alloc::string::String>,
    #[serde(rename = "debugServerTiming", skip_serializing_if = "::core::option::Option::is_none")]
    pub debug_server_timing: ::core::option::Option<::alloc::string::String>,
    #[serde(rename = "rangeToReplace", skip_serializing_if = "::core::option::Option::is_none")]
    pub range_to_replace: ::core::option::Option<LineRange>,
    #[serde(rename = "cursorPredictionTarget", skip_serializing_if = "::core::option::Option::is_none")]
    pub cursor_prediction_target: ::core::option::Option<stream_cpp_response::CursorPredictionTarget>,
    #[serde(rename = "doneEdit", skip_serializing_if = "::core::option::Option::is_none")]
    pub done_edit: ::core::option::Option<bool>,
    #[serde(rename = "modelInfo", skip_serializing_if = "::core::option::Option::is_none")]
    pub model_info: ::core::option::Option<stream_cpp_response::ModelInfo>,
    #[serde(rename = "beginEdit", skip_serializing_if = "::core::option::Option::is_none")]
    pub begin_edit: ::core::option::Option<bool>,
    #[serde(rename = "shouldRemoveLeadingEol", skip_serializing_if = "::core::option::Option::is_none")]
    pub should_remove_leading_eol: ::core::option::Option<bool>,
    #[serde(rename = "bindingId", skip_serializing_if = "::core::option::Option::is_none")]
    pub binding_id: ::core::option::Option<::byte_str::ByteStr>,
}
impl ::prost::Message for StreamCppResponse {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.text) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.text, buf) }
        if let ::core::option::Option::Some(ref value) = self.suggestion_start_line { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.suggestion_confidence { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.done_stream { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.debug_model_output { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.debug_model_input { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(6) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.debug_stream_time { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(7) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.debug_total_time { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(8) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.debug_ttft_time { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(9) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.debug_server_timing { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(10) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.range_to_replace { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(11) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.cursor_prediction_target { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(12) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.done_edit { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(13) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.model_info { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(14) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.begin_edit { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(15) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.should_remove_leading_eol { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(16) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.binding_id { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(17) }, value, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.text, buf, ctx).map_err(|mut error| { error.push("StreamCppResponse", "text"); error }),
            2 => if let ::core::option::Option::Some(ref mut value) = self.suggestion_start_line { ::prost::encoding::int32::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::int32::merge(wire_type, &mut value, buf, ctx).map(|_| self.suggestion_start_line = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppResponse", "suggestion_start_line"); error }),
            3 => if let ::core::option::Option::Some(ref mut value) = self.suggestion_confidence { ::prost::encoding::int32::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::int32::merge(wire_type, &mut value, buf, ctx).map(|_| self.suggestion_confidence = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppResponse", "suggestion_confidence"); error }),
            4 => if let ::core::option::Option::Some(ref mut value) = self.done_stream { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.done_stream = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppResponse", "done_stream"); error }),
            5 => if let ::core::option::Option::Some(ref mut value) = self.debug_model_output { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.debug_model_output = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppResponse", "debug_model_output"); error }),
            6 => if let ::core::option::Option::Some(ref mut value) = self.debug_model_input { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.debug_model_input = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppResponse", "debug_model_input"); error }),
            7 => if let ::core::option::Option::Some(ref mut value) = self.debug_stream_time { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.debug_stream_time = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppResponse", "debug_stream_time"); error }),
            8 => if let ::core::option::Option::Some(ref mut value) = self.debug_total_time { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.debug_total_time = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppResponse", "debug_total_time"); error }),
            9 => if let ::core::option::Option::Some(ref mut value) = self.debug_ttft_time { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.debug_ttft_time = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppResponse", "debug_ttft_time"); error }),
            10 => if let ::core::option::Option::Some(ref mut value) = self.debug_server_timing { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.debug_server_timing = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppResponse", "debug_server_timing"); error }),
            11 => if let ::core::option::Option::Some(ref mut value) = self.range_to_replace { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.range_to_replace = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppResponse", "range_to_replace"); error }),
            12 => if let ::core::option::Option::Some(ref mut value) = self.cursor_prediction_target { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.cursor_prediction_target = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppResponse", "cursor_prediction_target"); error }),
            13 => if let ::core::option::Option::Some(ref mut value) = self.done_edit { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.done_edit = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppResponse", "done_edit"); error }),
            14 => if let ::core::option::Option::Some(ref mut value) = self.model_info { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.model_info = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppResponse", "model_info"); error }),
            15 => if let ::core::option::Option::Some(ref mut value) = self.begin_edit { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.begin_edit = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppResponse", "begin_edit"); error }),
            16 => if let ::core::option::Option::Some(ref mut value) = self.should_remove_leading_eol { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.should_remove_leading_eol = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppResponse", "should_remove_leading_eol"); error }),
            17 => if let ::core::option::Option::Some(ref mut value) = self.binding_id { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.binding_id = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamCppResponse", "binding_id"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.text) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.text) }
        if let ::core::option::Option::Some(ref value) = self.suggestion_start_line { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value) }
        if let ::core::option::Option::Some(ref value) = self.suggestion_confidence { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, value) }
        if let ::core::option::Option::Some(ref value) = self.done_stream { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, value) }
        if let ::core::option::Option::Some(ref value) = self.debug_model_output { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, value) }
        if let ::core::option::Option::Some(ref value) = self.debug_model_input { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(6) }, value) }
        if let ::core::option::Option::Some(ref value) = self.debug_stream_time { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(7) }, value) }
        if let ::core::option::Option::Some(ref value) = self.debug_total_time { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(8) }, value) }
        if let ::core::option::Option::Some(ref value) = self.debug_ttft_time { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(9) }, value) }
        if let ::core::option::Option::Some(ref value) = self.debug_server_timing { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(10) }, value) }
        if let ::core::option::Option::Some(ref value) = self.range_to_replace { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(11) }, value) }
        if let ::core::option::Option::Some(ref value) = self.cursor_prediction_target { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(12) }, value) }
        if let ::core::option::Option::Some(ref value) = self.done_edit { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(13) }, value) }
        if let ::core::option::Option::Some(ref value) = self.model_info { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(14) }, value) }
        if let ::core::option::Option::Some(ref value) = self.begin_edit { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(15) }, value) }
        if let ::core::option::Option::Some(ref value) = self.should_remove_leading_eol { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(16) }, value) }
        if let ::core::option::Option::Some(ref value) = self.binding_id { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(17) }, value) }
        len
    }
    fn clear(&mut self) {
        self.text.clear();
        self.suggestion_start_line = ::core::option::Option::None;
        self.suggestion_confidence = ::core::option::Option::None;
        self.done_stream = ::core::option::Option::None;
        self.debug_model_output = ::core::option::Option::None;
        self.debug_model_input = ::core::option::Option::None;
        self.debug_stream_time = ::core::option::Option::None;
        self.debug_total_time = ::core::option::Option::None;
        self.debug_ttft_time = ::core::option::Option::None;
        self.debug_server_timing = ::core::option::Option::None;
        self.range_to_replace = ::core::option::Option::None;
        self.cursor_prediction_target = ::core::option::Option::None;
        self.done_edit = ::core::option::Option::None;
        self.model_info = ::core::option::Option::None;
        self.begin_edit = ::core::option::Option::None;
        self.should_remove_leading_eol = ::core::option::Option::None;
        self.binding_id = ::core::option::Option::None;
    }
}
/// .aiserver.v1.CppConfigRequest
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct CppConfigRequest {
    #[serde(default)]
    pub is_nightly: ::core::option::Option<bool>,
    #[serde(default)]
    pub model: ::alloc::string::String,
    #[serde(default)]
    pub supports_cpt: ::core::option::Option<bool>,
}
impl ::prost::Message for CppConfigRequest {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if let ::core::option::Option::Some(ref value) = self.is_nightly { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, value, buf) }
        if !::proto_value::is_default(&self.model) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.model, buf) }
        if let ::core::option::Option::Some(ref value) = self.supports_cpt { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, value, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => if let ::core::option::Option::Some(ref mut value) = self.is_nightly { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.is_nightly = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CppConfigRequest", "is_nightly"); error }),
            2 => ::prost::encoding::string::merge(wire_type, &mut self.model, buf, ctx).map_err(|mut error| { error.push("CppConfigRequest", "model"); error }),
            3 => if let ::core::option::Option::Some(ref mut value) = self.supports_cpt { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.supports_cpt = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CppConfigRequest", "supports_cpt"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if let ::core::option::Option::Some(ref value) = self.is_nightly { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, value) }
        if !::proto_value::is_default(&self.model) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.model) }
        if let ::core::option::Option::Some(ref value) = self.supports_cpt { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, value) }
        len
    }
    fn clear(&mut self) {
        self.is_nightly = ::core::option::Option::None;
        self.model.clear();
        self.supports_cpt = ::core::option::Option::None;
    }
}
/// Nested message and enum types in [`CppConfigResponse`].
pub mod cpp_config_response {
    /// .aiserver.v1.CppConfigResponse.Heuristic
    #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde::Serialize)]
    pub enum Heuristic {
        #[default]
        #[serde(rename = "unspecified")]
        Unspecified = 0,
        #[serde(rename = "lots_of_added_text")]
        LotsOfAddedText = 1,
        #[serde(rename = "duplicating_line_after_suggestion")]
        DuplicatingLineAfterSuggestion = 2,
        #[serde(rename = "duplicating_multiple_lines_after_suggestion")]
        DuplicatingMultipleLinesAfterSuggestion = 3,
        #[serde(rename = "reverting_user_change")]
        RevertingUserChange = 4,
        #[serde(rename = "output_extends_beyond_range_and_is_repeated")]
        OutputExtendsBeyondRangeAndIsRepeated = 5,
        #[serde(rename = "suggesting_recently_rejected_edit")]
        SuggestingRecentlyRejectedEdit = 6,
    }
    impl ::core::convert::From::<Heuristic> for i32 {
        #[inline]
        fn from(value: Heuristic) -> i32 { value as i32 }
    }
    impl ::core::convert::TryFrom::<i32> for Heuristic {
        type Error = ();
        #[inline]
        fn try_from(value: i32) -> ::core::result::Result<Self, ()> {
            match value {
                0 => ::core::result::Result::Ok(Self::Unspecified),
                1 => ::core::result::Result::Ok(Self::LotsOfAddedText),
                2 => ::core::result::Result::Ok(Self::DuplicatingLineAfterSuggestion),
                3 => ::core::result::Result::Ok(Self::DuplicatingMultipleLinesAfterSuggestion),
                4 => ::core::result::Result::Ok(Self::RevertingUserChange),
                5 => ::core::result::Result::Ok(Self::OutputExtendsBeyondRangeAndIsRepeated),
                6 => ::core::result::Result::Ok(Self::SuggestingRecentlyRejectedEdit),
                _ => ::core::result::Result::Err(()),
            }
        }
    }
    /// .aiserver.v1.CppConfigResponse.ImportPredictionConfig
    #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash, ::serde::Serialize)]
    pub struct ImportPredictionConfig {
        #[serde(skip_serializing_if = "::proto_value::is_default")]
        pub is_disabled_by_backend: bool,
        #[serde(skip_serializing_if = "::proto_value::is_default")]
        pub should_turn_on_automatically: bool,
        #[serde(skip_serializing_if = "::proto_value::is_default")]
        pub python_enabled: bool,
    }
    impl ::prost::Message for ImportPredictionConfig {
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if !::proto_value::is_default(&self.is_disabled_by_backend) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.is_disabled_by_backend, buf) }
            if !::proto_value::is_default(&self.should_turn_on_automatically) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.should_turn_on_automatically, buf) }
            if !::proto_value::is_default(&self.python_enabled) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.python_enabled, buf) }
        }
        fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
            match number.get() {
                1 => ::prost::encoding::bool::merge(wire_type, &mut self.is_disabled_by_backend, buf, ctx).map_err(|mut error| { error.push("ImportPredictionConfig", "is_disabled_by_backend"); error }),
                2 => ::prost::encoding::bool::merge(wire_type, &mut self.should_turn_on_automatically, buf, ctx).map_err(|mut error| { error.push("ImportPredictionConfig", "should_turn_on_automatically"); error }),
                3 => ::prost::encoding::bool::merge(wire_type, &mut self.python_enabled, buf, ctx).map_err(|mut error| { error.push("ImportPredictionConfig", "python_enabled"); error }),
                _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
            }
        }
        fn encoded_len(&self) -> usize {
            let mut len = 0;
            if !::proto_value::is_default(&self.is_disabled_by_backend) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.is_disabled_by_backend) }
            if !::proto_value::is_default(&self.should_turn_on_automatically) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.should_turn_on_automatically) }
            if !::proto_value::is_default(&self.python_enabled) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.python_enabled) }
            len
        }
        fn clear(&mut self) {
            self.is_disabled_by_backend = false;
            self.should_turn_on_automatically = false;
            self.python_enabled = false;
        }
    }
    /// .aiserver.v1.CppConfigResponse.MergeBehavior
    #[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Serialize)]
    pub struct MergeBehavior {
        #[serde(skip_serializing_if = "::proto_value::is_default")]
        pub r#type: ::alloc::string::String,
        #[serde(skip_serializing_if = "::core::option::Option::is_none")]
        pub limit: ::core::option::Option<i32>,
        #[serde(skip_serializing_if = "::core::option::Option::is_none")]
        pub radius: ::core::option::Option<i32>,
    }
    impl ::prost::Message for MergeBehavior {
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if !::proto_value::is_default(&self.r#type) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.r#type, buf) }
            if let ::core::option::Option::Some(ref value) = self.limit { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.radius { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, value, buf) }
        }
        fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
            match number.get() {
                1 => ::prost::encoding::string::merge(wire_type, &mut self.r#type, buf, ctx).map_err(|mut error| { error.push("MergeBehavior", "type"); error }),
                2 => if let ::core::option::Option::Some(ref mut value) = self.limit { ::prost::encoding::int32::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::int32::merge(wire_type, &mut value, buf, ctx).map(|_| self.limit = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("MergeBehavior", "limit"); error }),
                3 => if let ::core::option::Option::Some(ref mut value) = self.radius { ::prost::encoding::int32::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::int32::merge(wire_type, &mut value, buf, ctx).map(|_| self.radius = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("MergeBehavior", "radius"); error }),
                _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
            }
        }
        fn encoded_len(&self) -> usize {
            let mut len = 0;
            if !::proto_value::is_default(&self.r#type) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.r#type) }
            if let ::core::option::Option::Some(ref value) = self.limit { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value) }
            if let ::core::option::Option::Some(ref value) = self.radius { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, value) }
            len
        }
        fn clear(&mut self) {
            self.r#type.clear();
            self.limit = ::core::option::Option::None;
            self.radius = ::core::option::Option::None;
        }
    }
    /// .aiserver.v1.CppConfigResponse.RecentlyRejectedEditThresholds
    #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash, ::serde::Serialize)]
    pub struct RecentlyRejectedEditThresholds {
        #[serde(skip_serializing_if = "::proto_value::is_default")]
        pub hard_reject_threshold: i32,
        #[serde(skip_serializing_if = "::proto_value::is_default")]
        pub soft_reject_threshold: i32,
    }
    impl ::prost::Message for RecentlyRejectedEditThresholds {
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if !::proto_value::is_default(&self.hard_reject_threshold) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.hard_reject_threshold, buf) }
            if !::proto_value::is_default(&self.soft_reject_threshold) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.soft_reject_threshold, buf) }
        }
        fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
            match number.get() {
                1 => ::prost::encoding::int32::merge(wire_type, &mut self.hard_reject_threshold, buf, ctx).map_err(|mut error| { error.push("RecentlyRejectedEditThresholds", "hard_reject_threshold"); error }),
                2 => ::prost::encoding::int32::merge(wire_type, &mut self.soft_reject_threshold, buf, ctx).map_err(|mut error| { error.push("RecentlyRejectedEditThresholds", "soft_reject_threshold"); error }),
                _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
            }
        }
        fn encoded_len(&self) -> usize {
            let mut len = 0;
            if !::proto_value::is_default(&self.hard_reject_threshold) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.hard_reject_threshold) }
            if !::proto_value::is_default(&self.soft_reject_threshold) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.soft_reject_threshold) }
            len
        }
        fn clear(&mut self) {
            self.hard_reject_threshold = 0i32;
            self.soft_reject_threshold = 0i32;
        }
    }
    /// .aiserver.v1.CppConfigResponse.SuggestionHintConfig
    #[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Serialize)]
    pub struct SuggestionHintConfig {
        #[serde(skip_serializing_if = "::alloc::vec::Vec::is_empty")]
        pub important_lsp_extensions: ::alloc::vec::Vec<::alloc::string::String>,
        #[serde(skip_serializing_if = "::alloc::vec::Vec::is_empty")]
        pub enabled_for_path_extensions: ::alloc::vec::Vec<::alloc::string::String>,
    }
    impl ::prost::Message for SuggestionHintConfig {
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if !::alloc::vec::Vec::is_empty(&self.important_lsp_extensions) { ::prost::encoding::string::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.important_lsp_extensions, buf) }
            if !::alloc::vec::Vec::is_empty(&self.enabled_for_path_extensions) { ::prost::encoding::string::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.enabled_for_path_extensions, buf) }
        }
        fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
            match number.get() {
                1 => ::prost::encoding::string::merge_repeated(wire_type, &mut self.important_lsp_extensions, buf, ctx).map_err(|mut error| { error.push("SuggestionHintConfig", "important_lsp_extensions"); error }),
                2 => ::prost::encoding::string::merge_repeated(wire_type, &mut self.enabled_for_path_extensions, buf, ctx).map_err(|mut error| { error.push("SuggestionHintConfig", "enabled_for_path_extensions"); error }),
                _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
            }
        }
        fn encoded_len(&self) -> usize {
            let mut len = 0;
            if !::alloc::vec::Vec::is_empty(&self.important_lsp_extensions) { len += ::prost::encoding::string::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.important_lsp_extensions) }
            if !::alloc::vec::Vec::is_empty(&self.enabled_for_path_extensions) { len += ::prost::encoding::string::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.enabled_for_path_extensions) }
            len
        }
        fn clear(&mut self) {
            self.important_lsp_extensions.clear();
            self.enabled_for_path_extensions.clear();
        }
    }
}
/// .aiserver.v1.CppConfigResponse
#[derive(Debug, Default, Clone, PartialEq, ::serde::Serialize)]
pub struct CppConfigResponse {
    #[serde(skip_serializing_if = "::core::option::Option::is_none")]
    pub above_radius: ::core::option::Option<i32>,
    #[serde(skip_serializing_if = "::core::option::Option::is_none")]
    pub below_radius: ::core::option::Option<i32>,
    #[serde(skip_serializing_if = "::core::option::Option::is_none")]
    pub merge_behavior: ::core::option::Option<cpp_config_response::MergeBehavior>,
    #[serde(skip_serializing_if = "::core::option::Option::is_none")]
    pub is_on: ::core::option::Option<bool>,
    #[serde(skip_serializing_if = "::core::option::Option::is_none")]
    pub is_ghost_text: ::core::option::Option<bool>,
    #[serde(skip_serializing_if = "::core::option::Option::is_none")]
    pub should_let_user_enable_cpp_even_if_not_pro: ::core::option::Option<bool>,
    #[serde(skip_serializing_if = "::alloc::vec::Vec::is_empty")]
    pub heuristics: ::alloc::vec::Vec<::proto_value::Enum<cpp_config_response::Heuristic>>,
    #[serde(skip_serializing_if = "::alloc::vec::Vec::is_empty")]
    pub exclude_recently_viewed_files_patterns: ::alloc::vec::Vec<::alloc::string::String>,
    #[serde(skip_serializing_if = "::proto_value::is_default")]
    pub enable_rvf_tracking: bool,
    #[serde(skip_serializing_if = "::proto_value::is_default")]
    pub global_debounce_duration_millis: i32,
    #[serde(skip_serializing_if = "::proto_value::is_default")]
    pub client_debounce_duration_millis: i32,
    #[serde(skip_serializing_if = "::proto_value::is_default")]
    pub cpp_url: ::alloc::string::String,
    #[serde(skip_serializing_if = "::proto_value::is_default")]
    pub use_whitespace_diff_history: bool,
    #[serde(skip_serializing_if = "::core::option::Option::is_none")]
    pub import_prediction_config: ::core::option::Option<cpp_config_response::ImportPredictionConfig>,
    #[serde(skip_serializing_if = "::proto_value::is_default")]
    pub enable_filesync_debounce_skipping: bool,
    #[serde(skip_serializing_if = "::proto_value::is_default")]
    pub check_filesync_hash_percent: f32,
    #[serde(skip_serializing_if = "::proto_value::is_default")]
    pub geo_cpp_backend_url: ::alloc::string::String,
    #[serde(skip_serializing_if = "::core::option::Option::is_none")]
    pub recently_rejected_edit_thresholds: ::core::option::Option<cpp_config_response::RecentlyRejectedEditThresholds>,
    #[serde(skip_serializing_if = "::proto_value::is_default")]
    pub is_fused_cursor_prediction_model: bool,
    #[serde(skip_serializing_if = "::proto_value::is_default")]
    pub include_unchanged_lines: bool,
    #[serde(skip_serializing_if = "::proto_value::is_default")]
    pub should_fetch_rvf_text: bool,
    #[serde(skip_serializing_if = "::core::option::Option::is_none")]
    pub max_number_of_cleared_suggestions_since_last_accept: ::core::option::Option<i32>,
    #[serde(skip_serializing_if = "::core::option::Option::is_none")]
    pub suggestion_hint_config: ::core::option::Option<cpp_config_response::SuggestionHintConfig>,
    #[serde(skip_serializing_if = "::proto_value::is_default")]
    pub allows_tab_chunks: bool,
    #[serde(skip_serializing_if = "::core::option::Option::is_none")]
    pub tab_context_refresh_debounce_ms: ::core::option::Option<i32>,
    #[serde(skip_serializing_if = "::core::option::Option::is_none")]
    pub tab_context_refresh_editor_change_debounce_ms: ::core::option::Option<i32>,
}
impl ::prost::Message for CppConfigResponse {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if let ::core::option::Option::Some(ref value) = self.above_radius { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.below_radius { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.merge_behavior { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.is_on { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.is_ghost_text { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(6) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.should_let_user_enable_cpp_even_if_not_pro { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(7) }, value, buf) }
        if !::alloc::vec::Vec::is_empty(&self.heuristics) { ::prost::encoding::r#enum::encode_packed(unsafe { ::core::num::NonZeroU32::new_unchecked(8) }, &self.heuristics, buf) }
        if !::alloc::vec::Vec::is_empty(&self.exclude_recently_viewed_files_patterns) { ::prost::encoding::string::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(9) }, &self.exclude_recently_viewed_files_patterns, buf) }
        if !::proto_value::is_default(&self.enable_rvf_tracking) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(10) }, &self.enable_rvf_tracking, buf) }
        if !::proto_value::is_default(&self.global_debounce_duration_millis) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(11) }, &self.global_debounce_duration_millis, buf) }
        if !::proto_value::is_default(&self.client_debounce_duration_millis) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(12) }, &self.client_debounce_duration_millis, buf) }
        if !::proto_value::is_default(&self.cpp_url) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(13) }, &self.cpp_url, buf) }
        if !::proto_value::is_default(&self.use_whitespace_diff_history) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(14) }, &self.use_whitespace_diff_history, buf) }
        if let ::core::option::Option::Some(ref value) = self.import_prediction_config { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(15) }, value, buf) }
        if !::proto_value::is_default(&self.enable_filesync_debounce_skipping) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(16) }, &self.enable_filesync_debounce_skipping, buf) }
        if !::proto_value::is_default(&self.check_filesync_hash_percent) { ::prost::encoding::float::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(17) }, &self.check_filesync_hash_percent, buf) }
        if !::proto_value::is_default(&self.geo_cpp_backend_url) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(18) }, &self.geo_cpp_backend_url, buf) }
        if let ::core::option::Option::Some(ref value) = self.recently_rejected_edit_thresholds { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(19) }, value, buf) }
        if !::proto_value::is_default(&self.is_fused_cursor_prediction_model) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(20) }, &self.is_fused_cursor_prediction_model, buf) }
        if !::proto_value::is_default(&self.include_unchanged_lines) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(21) }, &self.include_unchanged_lines, buf) }
        if !::proto_value::is_default(&self.should_fetch_rvf_text) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(22) }, &self.should_fetch_rvf_text, buf) }
        if let ::core::option::Option::Some(ref value) = self.max_number_of_cleared_suggestions_since_last_accept { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(23) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.suggestion_hint_config { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(24) }, value, buf) }
        if !::proto_value::is_default(&self.allows_tab_chunks) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(25) }, &self.allows_tab_chunks, buf) }
        if let ::core::option::Option::Some(ref value) = self.tab_context_refresh_debounce_ms { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(26) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.tab_context_refresh_editor_change_debounce_ms { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(27) }, value, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => if let ::core::option::Option::Some(ref mut value) = self.above_radius { ::prost::encoding::int32::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::int32::merge(wire_type, &mut value, buf, ctx).map(|_| self.above_radius = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CppConfigResponse", "above_radius"); error }),
            2 => if let ::core::option::Option::Some(ref mut value) = self.below_radius { ::prost::encoding::int32::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::int32::merge(wire_type, &mut value, buf, ctx).map(|_| self.below_radius = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CppConfigResponse", "below_radius"); error }),
            4 => if let ::core::option::Option::Some(ref mut value) = self.merge_behavior { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.merge_behavior = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CppConfigResponse", "merge_behavior"); error }),
            5 => if let ::core::option::Option::Some(ref mut value) = self.is_on { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.is_on = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CppConfigResponse", "is_on"); error }),
            6 => if let ::core::option::Option::Some(ref mut value) = self.is_ghost_text { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.is_ghost_text = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CppConfigResponse", "is_ghost_text"); error }),
            7 => if let ::core::option::Option::Some(ref mut value) = self.should_let_user_enable_cpp_even_if_not_pro { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.should_let_user_enable_cpp_even_if_not_pro = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CppConfigResponse", "should_let_user_enable_cpp_even_if_not_pro"); error }),
            8 => ::prost::encoding::r#enum::merge_repeated(wire_type, &mut self.heuristics, buf, ctx).map_err(|mut error| { error.push("CppConfigResponse", "heuristics"); error }),
            9 => ::prost::encoding::string::merge_repeated(wire_type, &mut self.exclude_recently_viewed_files_patterns, buf, ctx).map_err(|mut error| { error.push("CppConfigResponse", "exclude_recently_viewed_files_patterns"); error }),
            10 => ::prost::encoding::bool::merge(wire_type, &mut self.enable_rvf_tracking, buf, ctx).map_err(|mut error| { error.push("CppConfigResponse", "enable_rvf_tracking"); error }),
            11 => ::prost::encoding::int32::merge(wire_type, &mut self.global_debounce_duration_millis, buf, ctx).map_err(|mut error| { error.push("CppConfigResponse", "global_debounce_duration_millis"); error }),
            12 => ::prost::encoding::int32::merge(wire_type, &mut self.client_debounce_duration_millis, buf, ctx).map_err(|mut error| { error.push("CppConfigResponse", "client_debounce_duration_millis"); error }),
            13 => ::prost::encoding::string::merge(wire_type, &mut self.cpp_url, buf, ctx).map_err(|mut error| { error.push("CppConfigResponse", "cpp_url"); error }),
            14 => ::prost::encoding::bool::merge(wire_type, &mut self.use_whitespace_diff_history, buf, ctx).map_err(|mut error| { error.push("CppConfigResponse", "use_whitespace_diff_history"); error }),
            15 => if let ::core::option::Option::Some(ref mut value) = self.import_prediction_config { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.import_prediction_config = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CppConfigResponse", "import_prediction_config"); error }),
            16 => ::prost::encoding::bool::merge(wire_type, &mut self.enable_filesync_debounce_skipping, buf, ctx).map_err(|mut error| { error.push("CppConfigResponse", "enable_filesync_debounce_skipping"); error }),
            17 => ::prost::encoding::float::merge(wire_type, &mut self.check_filesync_hash_percent, buf, ctx).map_err(|mut error| { error.push("CppConfigResponse", "check_filesync_hash_percent"); error }),
            18 => ::prost::encoding::string::merge(wire_type, &mut self.geo_cpp_backend_url, buf, ctx).map_err(|mut error| { error.push("CppConfigResponse", "geo_cpp_backend_url"); error }),
            19 => if let ::core::option::Option::Some(ref mut value) = self.recently_rejected_edit_thresholds { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.recently_rejected_edit_thresholds = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CppConfigResponse", "recently_rejected_edit_thresholds"); error }),
            20 => ::prost::encoding::bool::merge(wire_type, &mut self.is_fused_cursor_prediction_model, buf, ctx).map_err(|mut error| { error.push("CppConfigResponse", "is_fused_cursor_prediction_model"); error }),
            21 => ::prost::encoding::bool::merge(wire_type, &mut self.include_unchanged_lines, buf, ctx).map_err(|mut error| { error.push("CppConfigResponse", "include_unchanged_lines"); error }),
            22 => ::prost::encoding::bool::merge(wire_type, &mut self.should_fetch_rvf_text, buf, ctx).map_err(|mut error| { error.push("CppConfigResponse", "should_fetch_rvf_text"); error }),
            23 => if let ::core::option::Option::Some(ref mut value) = self.max_number_of_cleared_suggestions_since_last_accept { ::prost::encoding::int32::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::int32::merge(wire_type, &mut value, buf, ctx).map(|_| self.max_number_of_cleared_suggestions_since_last_accept = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CppConfigResponse", "max_number_of_cleared_suggestions_since_last_accept"); error }),
            24 => if let ::core::option::Option::Some(ref mut value) = self.suggestion_hint_config { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.suggestion_hint_config = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CppConfigResponse", "suggestion_hint_config"); error }),
            25 => ::prost::encoding::bool::merge(wire_type, &mut self.allows_tab_chunks, buf, ctx).map_err(|mut error| { error.push("CppConfigResponse", "allows_tab_chunks"); error }),
            26 => if let ::core::option::Option::Some(ref mut value) = self.tab_context_refresh_debounce_ms { ::prost::encoding::int32::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::int32::merge(wire_type, &mut value, buf, ctx).map(|_| self.tab_context_refresh_debounce_ms = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CppConfigResponse", "tab_context_refresh_debounce_ms"); error }),
            27 => if let ::core::option::Option::Some(ref mut value) = self.tab_context_refresh_editor_change_debounce_ms { ::prost::encoding::int32::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::int32::merge(wire_type, &mut value, buf, ctx).map(|_| self.tab_context_refresh_editor_change_debounce_ms = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CppConfigResponse", "tab_context_refresh_editor_change_debounce_ms"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if let ::core::option::Option::Some(ref value) = self.above_radius { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, value) }
        if let ::core::option::Option::Some(ref value) = self.below_radius { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value) }
        if let ::core::option::Option::Some(ref value) = self.merge_behavior { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, value) }
        if let ::core::option::Option::Some(ref value) = self.is_on { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, value) }
        if let ::core::option::Option::Some(ref value) = self.is_ghost_text { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(6) }, value) }
        if let ::core::option::Option::Some(ref value) = self.should_let_user_enable_cpp_even_if_not_pro { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(7) }, value) }
        if !::alloc::vec::Vec::is_empty(&self.heuristics) { len += ::prost::encoding::r#enum::encoded_len_packed(unsafe { ::core::num::NonZeroU32::new_unchecked(8) }, &self.heuristics) }
        if !::alloc::vec::Vec::is_empty(&self.exclude_recently_viewed_files_patterns) { len += ::prost::encoding::string::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(9) }, &self.exclude_recently_viewed_files_patterns) }
        if !::proto_value::is_default(&self.enable_rvf_tracking) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(10) }, &self.enable_rvf_tracking) }
        if !::proto_value::is_default(&self.global_debounce_duration_millis) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(11) }, &self.global_debounce_duration_millis) }
        if !::proto_value::is_default(&self.client_debounce_duration_millis) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(12) }, &self.client_debounce_duration_millis) }
        if !::proto_value::is_default(&self.cpp_url) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(13) }, &self.cpp_url) }
        if !::proto_value::is_default(&self.use_whitespace_diff_history) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(14) }, &self.use_whitespace_diff_history) }
        if let ::core::option::Option::Some(ref value) = self.import_prediction_config { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(15) }, value) }
        if !::proto_value::is_default(&self.enable_filesync_debounce_skipping) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(16) }, &self.enable_filesync_debounce_skipping) }
        if !::proto_value::is_default(&self.check_filesync_hash_percent) { len += ::prost::encoding::float::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(17) }, &self.check_filesync_hash_percent) }
        if !::proto_value::is_default(&self.geo_cpp_backend_url) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(18) }, &self.geo_cpp_backend_url) }
        if let ::core::option::Option::Some(ref value) = self.recently_rejected_edit_thresholds { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(19) }, value) }
        if !::proto_value::is_default(&self.is_fused_cursor_prediction_model) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(20) }, &self.is_fused_cursor_prediction_model) }
        if !::proto_value::is_default(&self.include_unchanged_lines) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(21) }, &self.include_unchanged_lines) }
        if !::proto_value::is_default(&self.should_fetch_rvf_text) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(22) }, &self.should_fetch_rvf_text) }
        if let ::core::option::Option::Some(ref value) = self.max_number_of_cleared_suggestions_since_last_accept { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(23) }, value) }
        if let ::core::option::Option::Some(ref value) = self.suggestion_hint_config { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(24) }, value) }
        if !::proto_value::is_default(&self.allows_tab_chunks) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(25) }, &self.allows_tab_chunks) }
        if let ::core::option::Option::Some(ref value) = self.tab_context_refresh_debounce_ms { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(26) }, value) }
        if let ::core::option::Option::Some(ref value) = self.tab_context_refresh_editor_change_debounce_ms { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(27) }, value) }
        len
    }
    fn clear(&mut self) {
        self.above_radius = ::core::option::Option::None;
        self.below_radius = ::core::option::Option::None;
        self.merge_behavior = ::core::option::Option::None;
        self.is_on = ::core::option::Option::None;
        self.is_ghost_text = ::core::option::Option::None;
        self.should_let_user_enable_cpp_even_if_not_pro = ::core::option::Option::None;
        self.heuristics.clear();
        self.exclude_recently_viewed_files_patterns.clear();
        self.enable_rvf_tracking = false;
        self.global_debounce_duration_millis = 0i32;
        self.client_debounce_duration_millis = 0i32;
        self.cpp_url.clear();
        self.use_whitespace_diff_history = false;
        self.import_prediction_config = ::core::option::Option::None;
        self.enable_filesync_debounce_skipping = false;
        self.check_filesync_hash_percent = 0.0f32;
        self.geo_cpp_backend_url.clear();
        self.recently_rejected_edit_thresholds = ::core::option::Option::None;
        self.is_fused_cursor_prediction_model = false;
        self.include_unchanged_lines = false;
        self.should_fetch_rvf_text = false;
        self.max_number_of_cleared_suggestions_since_last_accept = ::core::option::Option::None;
        self.suggestion_hint_config = ::core::option::Option::None;
        self.allows_tab_chunks = false;
        self.tab_context_refresh_debounce_ms = ::core::option::Option::None;
        self.tab_context_refresh_editor_change_debounce_ms = ::core::option::Option::None;
    }
}
/// .aiserver.v1.AdditionalFile
#[derive(Debug, Default, Clone, PartialEq, ::serde::Deserialize)]
pub struct AdditionalFile {
    #[serde(default)]
    pub relative_workspace_path: ::alloc::string::String,
    #[serde(default)]
    pub is_open: bool,
    #[serde(default)]
    pub visible_range_content: ::alloc::vec::Vec<::alloc::string::String>,
    #[serde(default)]
    pub last_viewed_at: ::core::option::Option<f64>,
    #[serde(default)]
    pub start_line_number_one_indexed: ::alloc::vec::Vec<i32>,
    #[serde(default)]
    pub visible_ranges: ::alloc::vec::Vec<LineRange>,
}
impl ::prost::Message for AdditionalFile {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.relative_workspace_path) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.relative_workspace_path, buf) }
        if !::proto_value::is_default(&self.is_open) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.is_open, buf) }
        if !::alloc::vec::Vec::is_empty(&self.visible_range_content) { ::prost::encoding::string::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.visible_range_content, buf) }
        if let ::core::option::Option::Some(ref value) = self.last_viewed_at { ::prost::encoding::double::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, value, buf) }
        if !::alloc::vec::Vec::is_empty(&self.start_line_number_one_indexed) { ::prost::encoding::int32::encode_packed(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, &self.start_line_number_one_indexed, buf) }
        if !::alloc::vec::Vec::is_empty(&self.visible_ranges) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(6) }, &self.visible_ranges, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.relative_workspace_path, buf, ctx).map_err(|mut error| { error.push("AdditionalFile", "relative_workspace_path"); error }),
            2 => ::prost::encoding::bool::merge(wire_type, &mut self.is_open, buf, ctx).map_err(|mut error| { error.push("AdditionalFile", "is_open"); error }),
            3 => ::prost::encoding::string::merge_repeated(wire_type, &mut self.visible_range_content, buf, ctx).map_err(|mut error| { error.push("AdditionalFile", "visible_range_content"); error }),
            4 => if let ::core::option::Option::Some(ref mut value) = self.last_viewed_at { ::prost::encoding::double::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::double::merge(wire_type, &mut value, buf, ctx).map(|_| self.last_viewed_at = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AdditionalFile", "last_viewed_at"); error }),
            5 => ::prost::encoding::int32::merge_repeated(wire_type, &mut self.start_line_number_one_indexed, buf, ctx).map_err(|mut error| { error.push("AdditionalFile", "start_line_number_one_indexed"); error }),
            6 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.visible_ranges, buf, ctx).map_err(|mut error| { error.push("AdditionalFile", "visible_ranges"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.relative_workspace_path) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.relative_workspace_path) }
        if !::proto_value::is_default(&self.is_open) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.is_open) }
        if !::alloc::vec::Vec::is_empty(&self.visible_range_content) { len += ::prost::encoding::string::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.visible_range_content) }
        if let ::core::option::Option::Some(ref value) = self.last_viewed_at { len += ::prost::encoding::double::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, value) }
        if !::alloc::vec::Vec::is_empty(&self.start_line_number_one_indexed) { len += ::prost::encoding::int32::encoded_len_packed(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, &self.start_line_number_one_indexed) }
        if !::alloc::vec::Vec::is_empty(&self.visible_ranges) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(6) }, &self.visible_ranges) }
        len
    }
    fn clear(&mut self) {
        self.relative_workspace_path.clear();
        self.is_open = false;
        self.visible_range_content.clear();
        self.last_viewed_at = ::core::option::Option::None;
        self.start_line_number_one_indexed.clear();
        self.visible_ranges.clear();
    }
}
/// .aiserver.v1.AvailableCppModelsResponse
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Serialize)]
pub struct AvailableCppModelsResponse {
    #[serde(skip_serializing_if = "::alloc::vec::Vec::is_empty")]
    pub models: ::alloc::vec::Vec<::alloc::string::String>,
    #[serde(skip_serializing_if = "::core::option::Option::is_none")]
    pub default_model: ::core::option::Option<::alloc::string::String>,
}
impl ::prost::Message for AvailableCppModelsResponse {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::alloc::vec::Vec::is_empty(&self.models) { ::prost::encoding::string::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.models, buf) }
        if let ::core::option::Option::Some(ref value) = self.default_model { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge_repeated(wire_type, &mut self.models, buf, ctx).map_err(|mut error| { error.push("AvailableCppModelsResponse", "models"); error }),
            2 => if let ::core::option::Option::Some(ref mut value) = self.default_model { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.default_model = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableCppModelsResponse", "default_model"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::alloc::vec::Vec::is_empty(&self.models) { len += ::prost::encoding::string::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.models) }
        if let ::core::option::Option::Some(ref value) = self.default_model { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value) }
        len
    }
    fn clear(&mut self) {
        self.models.clear();
        self.default_model = ::core::option::Option::None;
    }
}
/// .aiserver.v1.CppFileDiffHistory
#[derive(Debug, Default, Clone, PartialEq, ::serde::Deserialize)]
pub struct CppFileDiffHistory {
    #[serde(default)]
    pub file_name: ::alloc::string::String,
    #[serde(default)]
    pub diff_history: ::alloc::vec::Vec<::alloc::string::String>,
    #[serde(default)]
    pub diff_history_timestamps: ::alloc::vec::Vec<f64>,
}
impl ::prost::Message for CppFileDiffHistory {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.file_name) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.file_name, buf) }
        if !::alloc::vec::Vec::is_empty(&self.diff_history) { ::prost::encoding::string::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.diff_history, buf) }
        if !::alloc::vec::Vec::is_empty(&self.diff_history_timestamps) { ::prost::encoding::double::encode_packed(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.diff_history_timestamps, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.file_name, buf, ctx).map_err(|mut error| { error.push("CppFileDiffHistory", "file_name"); error }),
            2 => ::prost::encoding::string::merge_repeated(wire_type, &mut self.diff_history, buf, ctx).map_err(|mut error| { error.push("CppFileDiffHistory", "diff_history"); error }),
            3 => ::prost::encoding::double::merge_repeated(wire_type, &mut self.diff_history_timestamps, buf, ctx).map_err(|mut error| { error.push("CppFileDiffHistory", "diff_history_timestamps"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.file_name) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.file_name) }
        if !::alloc::vec::Vec::is_empty(&self.diff_history) { len += ::prost::encoding::string::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.diff_history) }
        if !::alloc::vec::Vec::is_empty(&self.diff_history_timestamps) { len += ::prost::encoding::double::encoded_len_packed(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.diff_history_timestamps) }
        len
    }
    fn clear(&mut self) {
        self.file_name.clear();
        self.diff_history.clear();
        self.diff_history_timestamps.clear();
    }
}
/// .aiserver.v1.CppContextItem
#[derive(Debug, Default, Clone, PartialEq, ::serde::Deserialize)]
pub struct CppContextItem {
    #[serde(default)]
    pub contents: ::alloc::string::String,
    #[serde(default)]
    pub symbol: ::core::option::Option<::alloc::string::String>,
    #[serde(default)]
    pub relative_workspace_path: ::alloc::string::String,
    #[serde(default)]
    pub score: f32,
}
impl ::prost::Message for CppContextItem {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.contents) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.contents, buf) }
        if let ::core::option::Option::Some(ref value) = self.symbol { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value, buf) }
        if !::proto_value::is_default(&self.relative_workspace_path) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.relative_workspace_path, buf) }
        if !::proto_value::is_default(&self.score) { ::prost::encoding::float::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.score, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.contents, buf, ctx).map_err(|mut error| { error.push("CppContextItem", "contents"); error }),
            2 => if let ::core::option::Option::Some(ref mut value) = self.symbol { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.symbol = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CppContextItem", "symbol"); error }),
            3 => ::prost::encoding::string::merge(wire_type, &mut self.relative_workspace_path, buf, ctx).map_err(|mut error| { error.push("CppContextItem", "relative_workspace_path"); error }),
            4 => ::prost::encoding::float::merge(wire_type, &mut self.score, buf, ctx).map_err(|mut error| { error.push("CppContextItem", "score"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.contents) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.contents) }
        if let ::core::option::Option::Some(ref value) = self.symbol { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value) }
        if !::proto_value::is_default(&self.relative_workspace_path) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.relative_workspace_path) }
        if !::proto_value::is_default(&self.score) { len += ::prost::encoding::float::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.score) }
        len
    }
    fn clear(&mut self) {
        self.contents.clear();
        self.symbol = ::core::option::Option::None;
        self.relative_workspace_path.clear();
        self.score = 0.0f32;
    }
}
/// .aiserver.v1.CppParameterHint
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct CppParameterHint {
    #[serde(default)]
    pub label: ::alloc::string::String,
    #[serde(default)]
    pub documentation: ::core::option::Option<::alloc::string::String>,
}
impl ::prost::Message for CppParameterHint {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.label) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.label, buf) }
        if let ::core::option::Option::Some(ref value) = self.documentation { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.label, buf, ctx).map_err(|mut error| { error.push("CppParameterHint", "label"); error }),
            2 => if let ::core::option::Option::Some(ref mut value) = self.documentation { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.documentation = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("CppParameterHint", "documentation"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.label) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.label) }
        if let ::core::option::Option::Some(ref value) = self.documentation { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value) }
        len
    }
    fn clear(&mut self) {
        self.label.clear();
        self.documentation = ::core::option::Option::None;
    }
}
/// .aiserver.v1.IRange
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct IRange {
    #[serde(default)]
    pub start_line_number: i32,
    #[serde(default)]
    pub start_column: i32,
    #[serde(default)]
    pub end_line_number: i32,
    #[serde(default)]
    pub end_column: i32,
}
impl ::prost::Message for IRange {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.start_line_number) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.start_line_number, buf) }
        if !::proto_value::is_default(&self.start_column) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.start_column, buf) }
        if !::proto_value::is_default(&self.end_line_number) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.end_line_number, buf) }
        if !::proto_value::is_default(&self.end_column) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.end_column, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::int32::merge(wire_type, &mut self.start_line_number, buf, ctx).map_err(|mut error| { error.push("IRange", "start_line_number"); error }),
            2 => ::prost::encoding::int32::merge(wire_type, &mut self.start_column, buf, ctx).map_err(|mut error| { error.push("IRange", "start_column"); error }),
            3 => ::prost::encoding::int32::merge(wire_type, &mut self.end_line_number, buf, ctx).map_err(|mut error| { error.push("IRange", "end_line_number"); error }),
            4 => ::prost::encoding::int32::merge(wire_type, &mut self.end_column, buf, ctx).map_err(|mut error| { error.push("IRange", "end_column"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.start_line_number) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.start_line_number) }
        if !::proto_value::is_default(&self.start_column) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.start_column) }
        if !::proto_value::is_default(&self.end_line_number) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.end_line_number) }
        if !::proto_value::is_default(&self.end_column) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.end_column) }
        len
    }
    fn clear(&mut self) {
        self.start_line_number = 0i32;
        self.start_column = 0i32;
        self.end_line_number = 0i32;
        self.end_column = 0i32;
    }
}
/// Nested message and enum types in [`BlockDiffPatch`].
pub mod block_diff_patch {
    /// .aiserver.v1.BlockDiffPatch.Change
    #[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Deserialize)]
    pub struct Change {
        #[serde(default)]
        pub text: ::alloc::string::String,
        #[serde(default)]
        pub range: ::core::option::Option<super::IRange>,
    }
    impl ::prost::Message for Change {
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if !::proto_value::is_default(&self.text) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.text, buf) }
            if let ::core::option::Option::Some(ref value) = self.range { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value, buf) }
        }
        fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
            match number.get() {
                1 => ::prost::encoding::string::merge(wire_type, &mut self.text, buf, ctx).map_err(|mut error| { error.push("Change", "text"); error }),
                2 => if let ::core::option::Option::Some(ref mut value) = self.range { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.range = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("Change", "range"); error }),
                _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
            }
        }
        fn encoded_len(&self) -> usize {
            let mut len = 0;
            if !::proto_value::is_default(&self.text) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.text) }
            if let ::core::option::Option::Some(ref value) = self.range { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value) }
            len
        }
        fn clear(&mut self) {
            self.text.clear();
            self.range = ::core::option::Option::None;
        }
    }
    /// .aiserver.v1.BlockDiffPatch.ModelWindow
    #[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Deserialize)]
    pub struct ModelWindow {
        #[serde(default)]
        pub lines: ::alloc::vec::Vec<::alloc::string::String>,
        #[serde(default)]
        pub start_line_number: i32,
        #[serde(default)]
        pub end_line_number: i32,
    }
    impl ::prost::Message for ModelWindow {
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if !::alloc::vec::Vec::is_empty(&self.lines) { ::prost::encoding::string::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.lines, buf) }
            if !::proto_value::is_default(&self.start_line_number) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.start_line_number, buf) }
            if !::proto_value::is_default(&self.end_line_number) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.end_line_number, buf) }
        }
        fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
            match number.get() {
                1 => ::prost::encoding::string::merge_repeated(wire_type, &mut self.lines, buf, ctx).map_err(|mut error| { error.push("ModelWindow", "lines"); error }),
                2 => ::prost::encoding::int32::merge(wire_type, &mut self.start_line_number, buf, ctx).map_err(|mut error| { error.push("ModelWindow", "start_line_number"); error }),
                3 => ::prost::encoding::int32::merge(wire_type, &mut self.end_line_number, buf, ctx).map_err(|mut error| { error.push("ModelWindow", "end_line_number"); error }),
                _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
            }
        }
        fn encoded_len(&self) -> usize {
            let mut len = 0;
            if !::alloc::vec::Vec::is_empty(&self.lines) { len += ::prost::encoding::string::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.lines) }
            if !::proto_value::is_default(&self.start_line_number) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.start_line_number) }
            if !::proto_value::is_default(&self.end_line_number) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.end_line_number) }
            len
        }
        fn clear(&mut self) {
            self.lines.clear();
            self.start_line_number = 0i32;
            self.end_line_number = 0i32;
        }
    }
}
/// .aiserver.v1.BlockDiffPatch
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct BlockDiffPatch {
    #[serde(default)]
    pub start_model_window: ::core::option::Option<block_diff_patch::ModelWindow>,
    #[serde(default)]
    pub changes: ::alloc::vec::Vec<block_diff_patch::Change>,
    #[serde(default)]
    pub relative_path: ::alloc::string::String,
    #[serde(default)]
    pub model_uuid: ::alloc::string::String,
    #[serde(default)]
    pub start_from_change_index: i32,
}
impl ::prost::Message for BlockDiffPatch {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if let ::core::option::Option::Some(ref value) = self.start_model_window { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, value, buf) }
        if !::alloc::vec::Vec::is_empty(&self.changes) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.changes, buf) }
        if !::proto_value::is_default(&self.relative_path) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.relative_path, buf) }
        if !::proto_value::is_default(&self.start_from_change_index) { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, &self.start_from_change_index, buf) }
        if !::proto_value::is_default(&self.model_uuid) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(7) }, &self.model_uuid, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => if let ::core::option::Option::Some(ref mut value) = self.start_model_window { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.start_model_window = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("BlockDiffPatch", "start_model_window"); error }),
            3 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.changes, buf, ctx).map_err(|mut error| { error.push("BlockDiffPatch", "changes"); error }),
            4 => ::prost::encoding::string::merge(wire_type, &mut self.relative_path, buf, ctx).map_err(|mut error| { error.push("BlockDiffPatch", "relative_path"); error }),
            5 => ::prost::encoding::int32::merge(wire_type, &mut self.start_from_change_index, buf, ctx).map_err(|mut error| { error.push("BlockDiffPatch", "start_from_change_index"); error }),
            7 => ::prost::encoding::string::merge(wire_type, &mut self.model_uuid, buf, ctx).map_err(|mut error| { error.push("BlockDiffPatch", "model_uuid"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if let ::core::option::Option::Some(ref value) = self.start_model_window { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, value) }
        if !::alloc::vec::Vec::is_empty(&self.changes) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.changes) }
        if !::proto_value::is_default(&self.relative_path) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.relative_path) }
        if !::proto_value::is_default(&self.start_from_change_index) { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, &self.start_from_change_index) }
        if !::proto_value::is_default(&self.model_uuid) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(7) }, &self.model_uuid) }
        len
    }
    fn clear(&mut self) {
        self.start_model_window = ::core::option::Option::None;
        self.changes.clear();
        self.relative_path.clear();
        self.model_uuid.clear();
        self.start_from_change_index = 0i32;
    }
}
/// .aiserver.v1.ClientSideToolV2
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum ClientSideToolV2 {
    #[default]
    Unspecified = 0,
    ReadSemsearchFiles = 1,
    RipgrepSearch = 3,
    ReadFile = 5,
    ListDir = 6,
    EditFile = 7,
    FileSearch = 8,
    SemanticSearchFull = 9,
    DeleteFile = 11,
    Reapply = 12,
    RunTerminalCommandV2 = 15,
    FetchRules = 16,
    WebSearch = 18,
    Mcp = 19,
    SearchSymbols = 23,
    BackgroundComposerFollowup = 24,
    KnowledgeBase = 25,
    FetchPullRequest = 26,
    DeepSearch = 27,
    CreateDiagram = 28,
    FixLints = 29,
    ReadLints = 30,
    GoToDefinition = 31,
    Task = 32,
    AwaitTask = 33,
    TodoRead = 34,
    TodoWrite = 35,
    EditFileV2 = 38,
    ListDirV2 = 39,
    ReadFileV2 = 40,
    RipgrepRawSearch = 41,
    GlobFileSearch = 42,
    CreatePlan = 43,
    ListMcpResources = 44,
    ReadMcpResource = 45,
    ReadProject = 46,
    UpdateProject = 47,
    TaskV2 = 48,
    CallMcpTool = 49,
    ApplyAgentDiff = 50,
    AskQuestion = 51,
    SwitchMode = 52,
    GenerateImage = 53,
    ComputerUse = 54,
    WriteShellStdin = 55,
}
impl ::core::convert::From::<ClientSideToolV2> for i32 {
    #[inline]
    fn from(value: ClientSideToolV2) -> i32 { value as i32 }
}
impl ::core::convert::TryFrom::<i32> for ClientSideToolV2 {
    type Error = ();
    #[inline]
    fn try_from(value: i32) -> ::core::result::Result<Self, ()> {
        match value {
            0 => ::core::result::Result::Ok(Self::Unspecified),
            1 => ::core::result::Result::Ok(Self::ReadSemsearchFiles),
            3 => ::core::result::Result::Ok(Self::RipgrepSearch),
            5 => ::core::result::Result::Ok(Self::ReadFile),
            6 => ::core::result::Result::Ok(Self::ListDir),
            7 => ::core::result::Result::Ok(Self::EditFile),
            8 => ::core::result::Result::Ok(Self::FileSearch),
            9 => ::core::result::Result::Ok(Self::SemanticSearchFull),
            11 => ::core::result::Result::Ok(Self::DeleteFile),
            12 => ::core::result::Result::Ok(Self::Reapply),
            15 => ::core::result::Result::Ok(Self::RunTerminalCommandV2),
            16 => ::core::result::Result::Ok(Self::FetchRules),
            18 => ::core::result::Result::Ok(Self::WebSearch),
            19 => ::core::result::Result::Ok(Self::Mcp),
            23 => ::core::result::Result::Ok(Self::SearchSymbols),
            24 => ::core::result::Result::Ok(Self::BackgroundComposerFollowup),
            25 => ::core::result::Result::Ok(Self::KnowledgeBase),
            26 => ::core::result::Result::Ok(Self::FetchPullRequest),
            27 => ::core::result::Result::Ok(Self::DeepSearch),
            28 => ::core::result::Result::Ok(Self::CreateDiagram),
            29 => ::core::result::Result::Ok(Self::FixLints),
            30 => ::core::result::Result::Ok(Self::ReadLints),
            31 => ::core::result::Result::Ok(Self::GoToDefinition),
            32 => ::core::result::Result::Ok(Self::Task),
            33 => ::core::result::Result::Ok(Self::AwaitTask),
            34 => ::core::result::Result::Ok(Self::TodoRead),
            35 => ::core::result::Result::Ok(Self::TodoWrite),
            38 => ::core::result::Result::Ok(Self::EditFileV2),
            39 => ::core::result::Result::Ok(Self::ListDirV2),
            40 => ::core::result::Result::Ok(Self::ReadFileV2),
            41 => ::core::result::Result::Ok(Self::RipgrepRawSearch),
            42 => ::core::result::Result::Ok(Self::GlobFileSearch),
            43 => ::core::result::Result::Ok(Self::CreatePlan),
            44 => ::core::result::Result::Ok(Self::ListMcpResources),
            45 => ::core::result::Result::Ok(Self::ReadMcpResource),
            46 => ::core::result::Result::Ok(Self::ReadProject),
            47 => ::core::result::Result::Ok(Self::UpdateProject),
            48 => ::core::result::Result::Ok(Self::TaskV2),
            49 => ::core::result::Result::Ok(Self::CallMcpTool),
            50 => ::core::result::Result::Ok(Self::ApplyAgentDiff),
            51 => ::core::result::Result::Ok(Self::AskQuestion),
            52 => ::core::result::Result::Ok(Self::SwitchMode),
            53 => ::core::result::Result::Ok(Self::GenerateImage),
            54 => ::core::result::Result::Ok(Self::ComputerUse),
            55 => ::core::result::Result::Ok(Self::WriteShellStdin),
            _ => ::core::result::Result::Err(()),
        }
    }
}
/// Nested message and enum types in [`ClientSideToolV2Call`].
pub mod client_side_tool_v2_call {
    #[derive(Debug, Clone, PartialEq, Eq, Hash)]
    pub enum Params {
        McpParams(super::McpParams),
    }
}
/// .aiserver.v1.ClientSideToolV2Call
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash)]
pub struct ClientSideToolV2Call {
    pub tool: ::proto_value::Enum<ClientSideToolV2>,
    pub params: ::core::option::Option<client_side_tool_v2_call::Params>,
    pub tool_call_id: ::byte_str::ByteStr,
    pub name: ::byte_str::ByteStr,
    pub is_streaming: bool,
    pub is_last_message: bool,
    pub raw_args: ::alloc::string::String,
    pub tool_index: ::core::option::Option<u32>,
    pub model_call_id: ::core::option::Option<::byte_str::ByteStr>,
}
impl ::prost::Message for ClientSideToolV2Call {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.tool) { ::prost::encoding::r#enum::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.tool, buf) }
        if !::proto_value::is_default(&self.tool_call_id) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.tool_call_id, buf) }
        if !::proto_value::is_default(&self.name) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(9) }, &self.name, buf) }
        if !::proto_value::is_default(&self.raw_args) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(10) }, &self.raw_args, buf) }
        if !::proto_value::is_default(&self.is_streaming) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(14) }, &self.is_streaming, buf) }
        if !::proto_value::is_default(&self.is_last_message) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(15) }, &self.is_last_message, buf) }
        if let ::core::option::Option::Some(client_side_tool_v2_call::Params::McpParams(ref value)) = self.params { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(27) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.tool_index { ::prost::encoding::uint32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(48) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.model_call_id { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(49) }, value, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        use client_side_tool_v2_call::*;
        match number.get() {
            1 => ::prost::encoding::r#enum::merge(wire_type, &mut self.tool, buf, ctx).map_err(|mut error| { error.push("ClientSideToolV2Call", "tool"); error }),
            3 => ::prost::encoding::string::merge(wire_type, &mut self.tool_call_id, buf, ctx).map_err(|mut error| { error.push("ClientSideToolV2Call", "tool_call_id"); error }),
            9 => ::prost::encoding::string::merge(wire_type, &mut self.name, buf, ctx).map_err(|mut error| { error.push("ClientSideToolV2Call", "name"); error }),
            10 => ::prost::encoding::string::merge(wire_type, &mut self.raw_args, buf, ctx).map_err(|mut error| { error.push("ClientSideToolV2Call", "raw_args"); error }),
            14 => ::prost::encoding::bool::merge(wire_type, &mut self.is_streaming, buf, ctx).map_err(|mut error| { error.push("ClientSideToolV2Call", "is_streaming"); error }),
            15 => ::prost::encoding::bool::merge(wire_type, &mut self.is_last_message, buf, ctx).map_err(|mut error| { error.push("ClientSideToolV2Call", "is_last_message"); error }),
            27 => if let ::core::option::Option::Some(Params::McpParams(ref mut value)) = self.params { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.params = ::core::option::Option::Some(client_side_tool_v2_call::Params::McpParams(value))) }.map_err(|mut error| { error.push("ClientSideToolV2Call", "mcp_params"); error }),
            48 => if let ::core::option::Option::Some(ref mut value) = self.tool_index { ::prost::encoding::uint32::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::uint32::merge(wire_type, &mut value, buf, ctx).map(|_| self.tool_index = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("ClientSideToolV2Call", "tool_index"); error }),
            49 => if let ::core::option::Option::Some(ref mut value) = self.model_call_id { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.model_call_id = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("ClientSideToolV2Call", "model_call_id"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        use client_side_tool_v2_call::*;
        let mut len = 0;
        if !::proto_value::is_default(&self.tool) { len += ::prost::encoding::r#enum::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.tool) }
        if !::proto_value::is_default(&self.tool_call_id) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.tool_call_id) }
        if !::proto_value::is_default(&self.name) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(9) }, &self.name) }
        if !::proto_value::is_default(&self.raw_args) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(10) }, &self.raw_args) }
        if !::proto_value::is_default(&self.is_streaming) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(14) }, &self.is_streaming) }
        if !::proto_value::is_default(&self.is_last_message) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(15) }, &self.is_last_message) }
        if let ::core::option::Option::Some(Params::McpParams(ref value)) = self.params { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(27) }, value) }
        if let ::core::option::Option::Some(ref value) = self.tool_index { len += ::prost::encoding::uint32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(48) }, value) }
        if let ::core::option::Option::Some(ref value) = self.model_call_id { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(49) }, value) }
        len
    }
    fn clear(&mut self) {
        self.tool = ::proto_value::Enum::default();
        self.params = ::core::option::Option::None;
        self.tool_call_id.clear();
        self.name.clear();
        self.is_streaming = false;
        self.is_last_message = false;
        self.raw_args.clear();
        self.tool_index = ::core::option::Option::None;
        self.model_call_id = ::core::option::Option::None;
    }
}
/// Nested message and enum types in [`ClientSideToolV2Result`].
pub mod client_side_tool_v2_result {
    #[derive(Debug, Clone, PartialEq, Eq, Hash)]
    pub enum Result {
        McpResult(super::McpResult),
    }
}
/// .aiserver.v1.ClientSideToolV2Result
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash)]
pub struct ClientSideToolV2Result {
    pub tool: ::proto_value::Enum<ClientSideToolV2>,
    pub result: ::core::option::Option<client_side_tool_v2_result::Result>,
    pub tool_call_id: ::byte_str::ByteStr,
    pub model_call_id: ::core::option::Option<::byte_str::ByteStr>,
    pub tool_index: ::core::option::Option<u32>,
}
impl ::prost::Message for ClientSideToolV2Result {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.tool) { ::prost::encoding::r#enum::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.tool, buf) }
        if let ::core::option::Option::Some(client_side_tool_v2_result::Result::McpResult(ref value)) = self.result { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(28) }, value, buf) }
        if !::proto_value::is_default(&self.tool_call_id) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(35) }, &self.tool_call_id, buf) }
        if let ::core::option::Option::Some(ref value) = self.model_call_id { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(48) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.tool_index { ::prost::encoding::uint32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(49) }, value, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        use client_side_tool_v2_result::*;
        match number.get() {
            1 => ::prost::encoding::r#enum::merge(wire_type, &mut self.tool, buf, ctx).map_err(|mut error| { error.push("ClientSideToolV2Result", "tool"); error }),
            28 => if let ::core::option::Option::Some(Result::McpResult(ref mut value)) = self.result { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.result = ::core::option::Option::Some(client_side_tool_v2_result::Result::McpResult(value))) }.map_err(|mut error| { error.push("ClientSideToolV2Result", "mcp_result"); error }),
            35 => ::prost::encoding::string::merge(wire_type, &mut self.tool_call_id, buf, ctx).map_err(|mut error| { error.push("ClientSideToolV2Result", "tool_call_id"); error }),
            48 => if let ::core::option::Option::Some(ref mut value) = self.model_call_id { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.model_call_id = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("ClientSideToolV2Result", "model_call_id"); error }),
            49 => if let ::core::option::Option::Some(ref mut value) = self.tool_index { ::prost::encoding::uint32::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::uint32::merge(wire_type, &mut value, buf, ctx).map(|_| self.tool_index = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("ClientSideToolV2Result", "tool_index"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        use client_side_tool_v2_result::*;
        let mut len = 0;
        if !::proto_value::is_default(&self.tool) { len += ::prost::encoding::r#enum::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.tool) }
        if let ::core::option::Option::Some(Result::McpResult(ref value)) = self.result { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(28) }, value) }
        if !::proto_value::is_default(&self.tool_call_id) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(35) }, &self.tool_call_id) }
        if let ::core::option::Option::Some(ref value) = self.model_call_id { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(48) }, value) }
        if let ::core::option::Option::Some(ref value) = self.tool_index { len += ::prost::encoding::uint32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(49) }, value) }
        len
    }
    fn clear(&mut self) {
        self.tool = ::proto_value::Enum::default();
        self.result = ::core::option::Option::None;
        self.tool_call_id.clear();
        self.model_call_id = ::core::option::Option::None;
        self.tool_index = ::core::option::Option::None;
    }
}
/// Nested message and enum types in [`McpParams`].
pub mod mcp_params {
    /// .aiserver.v1.MCPParams.Tool
    #[derive(Debug, Default, Clone, PartialEq, Eq, Hash)]
    pub struct Tool {
        pub name: ::byte_str::ByteStr,
        pub description: ::alloc::string::String,
        pub parameters: ::byte_str::ByteStr,
        pub server_name: ::byte_str::ByteStr,
    }
    impl ::prost::Message for Tool {
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if !::proto_value::is_default(&self.name) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.name, buf) }
            if !::proto_value::is_default(&self.description) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.description, buf) }
            if !::proto_value::is_default(&self.parameters) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.parameters, buf) }
            if !::proto_value::is_default(&self.server_name) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.server_name, buf) }
        }
        fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
            match number.get() {
                1 => ::prost::encoding::string::merge(wire_type, &mut self.name, buf, ctx).map_err(|mut error| { error.push("Tool", "name"); error }),
                2 => ::prost::encoding::string::merge(wire_type, &mut self.description, buf, ctx).map_err(|mut error| { error.push("Tool", "description"); error }),
                3 => ::prost::encoding::string::merge(wire_type, &mut self.parameters, buf, ctx).map_err(|mut error| { error.push("Tool", "parameters"); error }),
                4 => ::prost::encoding::string::merge(wire_type, &mut self.server_name, buf, ctx).map_err(|mut error| { error.push("Tool", "server_name"); error }),
                _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
            }
        }
        fn encoded_len(&self) -> usize {
            let mut len = 0;
            if !::proto_value::is_default(&self.name) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.name) }
            if !::proto_value::is_default(&self.description) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.description) }
            if !::proto_value::is_default(&self.parameters) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.parameters) }
            if !::proto_value::is_default(&self.server_name) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.server_name) }
            len
        }
        fn clear(&mut self) {
            self.name.clear();
            self.description.clear();
            self.parameters.clear();
            self.server_name.clear();
        }
    }
}
/// .aiserver.v1.MCPParams
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash)]
pub struct McpParams {
    pub tools: ::alloc::vec::Vec<mcp_params::Tool>,
}
impl ::prost::Message for McpParams {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) { if !::alloc::vec::Vec::is_empty(&self.tools) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.tools, buf) }     }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.tools, buf, ctx).map_err(|mut error| { error.push("MCPParams", "tools"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize { if !::alloc::vec::Vec::is_empty(&self.tools) { ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.tools) } else { 0 } }
    fn clear(&mut self) { self.tools.clear() }
}
/// .aiserver.v1.MCPResult
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash)]
pub struct McpResult {
    pub selected_tool: ::byte_str::ByteStr,
    pub result: ::byte_str::ByteStr,
}
impl ::prost::Message for McpResult {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.selected_tool) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.selected_tool, buf) }
        if !::proto_value::is_default(&self.result) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.result, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.selected_tool, buf, ctx).map_err(|mut error| { error.push("MCPResult", "selected_tool"); error }),
            2 => ::prost::encoding::string::merge(wire_type, &mut self.result, buf, ctx).map_err(|mut error| { error.push("MCPResult", "result"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.selected_tool) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.selected_tool) }
        if !::proto_value::is_default(&self.result) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.result) }
        len
    }
    fn clear(&mut self) {
        self.selected_tool.clear();
        self.result.clear();
    }
}
/// Nested message and enum types in [`StreamUnifiedChatRequestWithTools`].
pub mod stream_unified_chat_request_with_tools {
    #[derive(Debug, Clone, PartialEq, Eq, Hash)]
    pub enum Request {
        StreamUnifiedChatRequest(::alloc::boxed::Box<super::StreamUnifiedChatRequest>),
        ClientSideToolV2Result(::alloc::boxed::Box<super::ClientSideToolV2Result>),
    }
}
/// .aiserver.v1.StreamUnifiedChatRequestWithTools
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash)]
pub struct StreamUnifiedChatRequestWithTools {
    pub request: ::core::option::Option<stream_unified_chat_request_with_tools::Request>,
}
impl ::prost::Message for StreamUnifiedChatRequestWithTools {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if let ::core::option::Option::Some(stream_unified_chat_request_with_tools::Request::StreamUnifiedChatRequest(ref value)) = self.request { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, value, buf) }
        if let ::core::option::Option::Some(stream_unified_chat_request_with_tools::Request::ClientSideToolV2Result(ref value)) = self.request { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        use stream_unified_chat_request_with_tools::*;
        match number.get() {
            1 => if let ::core::option::Option::Some(Request::StreamUnifiedChatRequest(ref mut value)) = self.request { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.request = ::core::option::Option::Some(stream_unified_chat_request_with_tools::Request::StreamUnifiedChatRequest(value))) }.map_err(|mut error| { error.push("StreamUnifiedChatRequestWithTools", "stream_unified_chat_request"); error }),
            2 => if let ::core::option::Option::Some(Request::ClientSideToolV2Result(ref mut value)) = self.request { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.request = ::core::option::Option::Some(stream_unified_chat_request_with_tools::Request::ClientSideToolV2Result(value))) }.map_err(|mut error| { error.push("StreamUnifiedChatRequestWithTools", "client_side_tool_v2_result"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        use stream_unified_chat_request_with_tools::*;
        let mut len = 0;
        if let ::core::option::Option::Some(Request::StreamUnifiedChatRequest(ref value)) = self.request { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, value) }
        if let ::core::option::Option::Some(Request::ClientSideToolV2Result(ref value)) = self.request { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value) }
        len
    }
    fn clear(&mut self) { self.request = ::core::option::Option::None }
}
/// Nested message and enum types in [`StreamUnifiedChatResponseWithTools`].
pub mod stream_unified_chat_response_with_tools {
    #[derive(Debug, Clone, PartialEq, Eq, Hash)]
    pub enum Response {
        ClientSideToolV2Call(::alloc::boxed::Box<super::ClientSideToolV2Call>),
        StreamUnifiedChatResponse(::alloc::boxed::Box<super::StreamUnifiedChatResponse>),
    }
}
/// .aiserver.v1.StreamUnifiedChatResponseWithTools
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash)]
pub struct StreamUnifiedChatResponseWithTools {
    pub response: ::core::option::Option<stream_unified_chat_response_with_tools::Response>,
}
impl ::prost::Message for StreamUnifiedChatResponseWithTools {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if let ::core::option::Option::Some(stream_unified_chat_response_with_tools::Response::ClientSideToolV2Call(ref value)) = self.response { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, value, buf) }
        if let ::core::option::Option::Some(stream_unified_chat_response_with_tools::Response::StreamUnifiedChatResponse(ref value)) = self.response { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        use stream_unified_chat_response_with_tools::*;
        match number.get() {
            1 => if let ::core::option::Option::Some(Response::ClientSideToolV2Call(ref mut value)) = self.response { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.response = ::core::option::Option::Some(stream_unified_chat_response_with_tools::Response::ClientSideToolV2Call(value))) }.map_err(|mut error| { error.push("StreamUnifiedChatResponseWithTools", "client_side_tool_v2_call"); error }),
            2 => if let ::core::option::Option::Some(Response::StreamUnifiedChatResponse(ref mut value)) = self.response { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.response = ::core::option::Option::Some(stream_unified_chat_response_with_tools::Response::StreamUnifiedChatResponse(value))) }.map_err(|mut error| { error.push("StreamUnifiedChatResponseWithTools", "stream_unified_chat_response"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        use stream_unified_chat_response_with_tools::*;
        let mut len = 0;
        if let ::core::option::Option::Some(Response::ClientSideToolV2Call(ref value)) = self.response { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, value) }
        if let ::core::option::Option::Some(Response::StreamUnifiedChatResponse(ref value)) = self.response { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value) }
        len
    }
    fn clear(&mut self) { self.response = ::core::option::Option::None }
}
/// .aiserver.v1.WebCitation
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash)]
pub struct WebCitation {
    pub references: ::alloc::vec::Vec<WebReference>,
}
impl ::prost::Message for WebCitation {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) { if !::alloc::vec::Vec::is_empty(&self.references) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.references, buf) }     }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.references, buf, ctx).map_err(|mut error| { error.push("WebCitation", "references"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize { if !::alloc::vec::Vec::is_empty(&self.references) { ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.references) } else { 0 } }
    fn clear(&mut self) { self.references.clear() }
}
/// .aiserver.v1.WebReference
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash)]
pub struct WebReference {
    pub title: ::alloc::string::String,
    pub url: ::alloc::string::String,
    pub chunk: ::alloc::string::String,
}
impl ::prost::Message for WebReference {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.url) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.url, buf) }
        if !::proto_value::is_default(&self.title) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.title, buf) }
        if !::proto_value::is_default(&self.chunk) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.chunk, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.url, buf, ctx).map_err(|mut error| { error.push("WebReference", "url"); error }),
            2 => ::prost::encoding::string::merge(wire_type, &mut self.title, buf, ctx).map_err(|mut error| { error.push("WebReference", "title"); error }),
            3 => ::prost::encoding::string::merge(wire_type, &mut self.chunk, buf, ctx).map_err(|mut error| { error.push("WebReference", "chunk"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.url) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.url) }
        if !::proto_value::is_default(&self.title) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.title) }
        if !::proto_value::is_default(&self.chunk) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.chunk) }
        len
    }
    fn clear(&mut self) {
        self.title.clear();
        self.url.clear();
        self.chunk.clear();
    }
}
/// Nested message and enum types in [`StreamUnifiedChatRequest`].
pub mod stream_unified_chat_request {
    /// .aiserver.v1.StreamUnifiedChatRequest.UnifiedMode
    #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum UnifiedMode {
        #[default]
        Unspecified = 0,
        Chat = 1,
        Agent = 2,
        Edit = 3,
        Custom = 4,
        Plan = 5,
        Debug = 6,
    }
    impl ::core::convert::From::<UnifiedMode> for i32 {
        #[inline]
        fn from(value: UnifiedMode) -> i32 { value as i32 }
    }
    impl ::core::convert::TryFrom::<i32> for UnifiedMode {
        type Error = ();
        #[inline]
        fn try_from(value: i32) -> ::core::result::Result<Self, ()> {
            match value {
                0 => ::core::result::Result::Ok(Self::Unspecified),
                1 => ::core::result::Result::Ok(Self::Chat),
                2 => ::core::result::Result::Ok(Self::Agent),
                3 => ::core::result::Result::Ok(Self::Edit),
                4 => ::core::result::Result::Ok(Self::Custom),
                5 => ::core::result::Result::Ok(Self::Plan),
                6 => ::core::result::Result::Ok(Self::Debug),
                _ => ::core::result::Result::Err(()),
            }
        }
    }
    /// .aiserver.v1.StreamUnifiedChatRequest.ThinkingLevel
    #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ThinkingLevel {
        #[default]
        Unspecified = 0,
        Medium = 1,
        High = 2,
    }
    impl ::core::convert::From::<ThinkingLevel> for i32 {
        #[inline]
        fn from(value: ThinkingLevel) -> i32 { value as i32 }
    }
    impl ::core::convert::TryFrom::<i32> for ThinkingLevel {
        type Error = ();
        #[inline]
        fn try_from(value: i32) -> ::core::result::Result<Self, ()> {
            match value {
                0 => ::core::result::Result::Ok(Self::Unspecified),
                1 => ::core::result::Result::Ok(Self::Medium),
                2 => ::core::result::Result::Ok(Self::High),
                _ => ::core::result::Result::Err(()),
            }
        }
    }
}
/// .aiserver.v1.StreamUnifiedChatRequest
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash)]
pub struct StreamUnifiedChatRequest {
    pub conversation: ::alloc::vec::Vec<ConversationMessage>,
    pub full_conversation_headers_only: ::alloc::vec::Vec<ConversationMessageHeader>,
    pub explicit_context: ::core::option::Option<ExplicitContext>,
    pub model_details: ::core::option::Option<ModelDetails>,
    pub use_web: ::core::option::Option<::byte_str::ByteStr>,
    pub external_links: ::alloc::vec::Vec<ComposerExternalLink>,
    pub should_cache: ::core::option::Option<bool>,
    pub current_file: ::core::option::Option<CurrentFileInfo>,
    pub use_new_compression_scheme: ::core::option::Option<bool>,
    pub is_chat: bool,
    pub conversation_id: ::alloc::string::String,
    pub environment_info: ::core::option::Option<EnvironmentInfo>,
    pub is_agentic: bool,
    pub supported_tools: ::alloc::vec::Vec<::proto_value::Enum<ClientSideToolV2>>,
    pub mcp_tools: ::alloc::vec::Vec<mcp_params::Tool>,
    pub use_full_inputs_context: ::core::option::Option<bool>,
    pub allow_model_fallbacks: ::core::option::Option<bool>,
    pub unified_mode: ::core::option::Option<::proto_value::Enum<stream_unified_chat_request::UnifiedMode>>,
    pub should_disable_tools: ::core::option::Option<bool>,
    pub thinking_level: ::core::option::Option<::proto_value::Enum<stream_unified_chat_request::ThinkingLevel>>,
    pub uses_rules: ::core::option::Option<bool>,
    pub unified_mode_name: ::core::option::Option<::byte_str::ByteStr>,
}
impl ::prost::Message for StreamUnifiedChatRequest {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::alloc::vec::Vec::is_empty(&self.conversation) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.conversation, buf) }
        if let ::core::option::Option::Some(ref value) = self.explicit_context { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.model_details { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.use_web { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(8) }, value, buf) }
        if !::alloc::vec::Vec::is_empty(&self.external_links) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(9) }, &self.external_links, buf) }
        if let ::core::option::Option::Some(ref value) = self.should_cache { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(13) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.current_file { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(15) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.use_new_compression_scheme { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(19) }, value, buf) }
        if !::proto_value::is_default(&self.is_chat) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(22) }, &self.is_chat, buf) }
        if !::proto_value::is_default(&self.conversation_id) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(23) }, &self.conversation_id, buf) }
        if let ::core::option::Option::Some(ref value) = self.environment_info { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(26) }, value, buf) }
        if !::proto_value::is_default(&self.is_agentic) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(27) }, &self.is_agentic, buf) }
        if !::alloc::vec::Vec::is_empty(&self.supported_tools) { ::prost::encoding::r#enum::encode_packed(unsafe { ::core::num::NonZeroU32::new_unchecked(29) }, &self.supported_tools, buf) }
        if !::alloc::vec::Vec::is_empty(&self.full_conversation_headers_only) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(30) }, &self.full_conversation_headers_only, buf) }
        if !::alloc::vec::Vec::is_empty(&self.mcp_tools) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(34) }, &self.mcp_tools, buf) }
        if let ::core::option::Option::Some(ref value) = self.use_full_inputs_context { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(35) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.allow_model_fallbacks { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(37) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.unified_mode { ::prost::encoding::r#enum::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(46) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.should_disable_tools { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(48) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.thinking_level { ::prost::encoding::r#enum::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(49) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.uses_rules { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(51) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.unified_mode_name { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(54) }, value, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.conversation, buf, ctx).map_err(|mut error| { error.push("StreamUnifiedChatRequest", "conversation"); error }),
            3 => if let ::core::option::Option::Some(ref mut value) = self.explicit_context { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.explicit_context = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamUnifiedChatRequest", "explicit_context"); error }),
            5 => if let ::core::option::Option::Some(ref mut value) = self.model_details { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.model_details = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamUnifiedChatRequest", "model_details"); error }),
            8 => if let ::core::option::Option::Some(ref mut value) = self.use_web { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.use_web = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamUnifiedChatRequest", "use_web"); error }),
            9 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.external_links, buf, ctx).map_err(|mut error| { error.push("StreamUnifiedChatRequest", "external_links"); error }),
            13 => if let ::core::option::Option::Some(ref mut value) = self.should_cache { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.should_cache = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamUnifiedChatRequest", "should_cache"); error }),
            15 => if let ::core::option::Option::Some(ref mut value) = self.current_file { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.current_file = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamUnifiedChatRequest", "current_file"); error }),
            19 => if let ::core::option::Option::Some(ref mut value) = self.use_new_compression_scheme { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.use_new_compression_scheme = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamUnifiedChatRequest", "use_new_compression_scheme"); error }),
            22 => ::prost::encoding::bool::merge(wire_type, &mut self.is_chat, buf, ctx).map_err(|mut error| { error.push("StreamUnifiedChatRequest", "is_chat"); error }),
            23 => ::prost::encoding::string::merge(wire_type, &mut self.conversation_id, buf, ctx).map_err(|mut error| { error.push("StreamUnifiedChatRequest", "conversation_id"); error }),
            26 => if let ::core::option::Option::Some(ref mut value) = self.environment_info { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.environment_info = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamUnifiedChatRequest", "environment_info"); error }),
            27 => ::prost::encoding::bool::merge(wire_type, &mut self.is_agentic, buf, ctx).map_err(|mut error| { error.push("StreamUnifiedChatRequest", "is_agentic"); error }),
            29 => ::prost::encoding::r#enum::merge_repeated(wire_type, &mut self.supported_tools, buf, ctx).map_err(|mut error| { error.push("StreamUnifiedChatRequest", "supported_tools"); error }),
            30 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.full_conversation_headers_only, buf, ctx).map_err(|mut error| { error.push("StreamUnifiedChatRequest", "full_conversation_headers_only"); error }),
            34 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.mcp_tools, buf, ctx).map_err(|mut error| { error.push("StreamUnifiedChatRequest", "mcp_tools"); error }),
            35 => if let ::core::option::Option::Some(ref mut value) = self.use_full_inputs_context { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.use_full_inputs_context = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamUnifiedChatRequest", "use_full_inputs_context"); error }),
            37 => if let ::core::option::Option::Some(ref mut value) = self.allow_model_fallbacks { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.allow_model_fallbacks = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamUnifiedChatRequest", "allow_model_fallbacks"); error }),
            46 => if let ::core::option::Option::Some(ref mut value) = self.unified_mode { ::prost::encoding::r#enum::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::r#enum::merge(wire_type, &mut value, buf, ctx).map(|_| self.unified_mode = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamUnifiedChatRequest", "unified_mode"); error }),
            48 => if let ::core::option::Option::Some(ref mut value) = self.should_disable_tools { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.should_disable_tools = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamUnifiedChatRequest", "should_disable_tools"); error }),
            49 => if let ::core::option::Option::Some(ref mut value) = self.thinking_level { ::prost::encoding::r#enum::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::r#enum::merge(wire_type, &mut value, buf, ctx).map(|_| self.thinking_level = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamUnifiedChatRequest", "thinking_level"); error }),
            51 => if let ::core::option::Option::Some(ref mut value) = self.uses_rules { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.uses_rules = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamUnifiedChatRequest", "uses_rules"); error }),
            54 => if let ::core::option::Option::Some(ref mut value) = self.unified_mode_name { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.unified_mode_name = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamUnifiedChatRequest", "unified_mode_name"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::alloc::vec::Vec::is_empty(&self.conversation) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.conversation) }
        if let ::core::option::Option::Some(ref value) = self.explicit_context { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, value) }
        if let ::core::option::Option::Some(ref value) = self.model_details { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, value) }
        if let ::core::option::Option::Some(ref value) = self.use_web { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(8) }, value) }
        if !::alloc::vec::Vec::is_empty(&self.external_links) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(9) }, &self.external_links) }
        if let ::core::option::Option::Some(ref value) = self.should_cache { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(13) }, value) }
        if let ::core::option::Option::Some(ref value) = self.current_file { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(15) }, value) }
        if let ::core::option::Option::Some(ref value) = self.use_new_compression_scheme { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(19) }, value) }
        if !::proto_value::is_default(&self.is_chat) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(22) }, &self.is_chat) }
        if !::proto_value::is_default(&self.conversation_id) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(23) }, &self.conversation_id) }
        if let ::core::option::Option::Some(ref value) = self.environment_info { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(26) }, value) }
        if !::proto_value::is_default(&self.is_agentic) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(27) }, &self.is_agentic) }
        if !::alloc::vec::Vec::is_empty(&self.supported_tools) { len += ::prost::encoding::r#enum::encoded_len_packed(unsafe { ::core::num::NonZeroU32::new_unchecked(29) }, &self.supported_tools) }
        if !::alloc::vec::Vec::is_empty(&self.full_conversation_headers_only) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(30) }, &self.full_conversation_headers_only) }
        if !::alloc::vec::Vec::is_empty(&self.mcp_tools) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(34) }, &self.mcp_tools) }
        if let ::core::option::Option::Some(ref value) = self.use_full_inputs_context { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(35) }, value) }
        if let ::core::option::Option::Some(ref value) = self.allow_model_fallbacks { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(37) }, value) }
        if let ::core::option::Option::Some(ref value) = self.unified_mode { len += ::prost::encoding::r#enum::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(46) }, value) }
        if let ::core::option::Option::Some(ref value) = self.should_disable_tools { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(48) }, value) }
        if let ::core::option::Option::Some(ref value) = self.thinking_level { len += ::prost::encoding::r#enum::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(49) }, value) }
        if let ::core::option::Option::Some(ref value) = self.uses_rules { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(51) }, value) }
        if let ::core::option::Option::Some(ref value) = self.unified_mode_name { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(54) }, value) }
        len
    }
    fn clear(&mut self) {
        self.conversation.clear();
        self.full_conversation_headers_only.clear();
        self.explicit_context = ::core::option::Option::None;
        self.model_details = ::core::option::Option::None;
        self.use_web = ::core::option::Option::None;
        self.external_links.clear();
        self.should_cache = ::core::option::Option::None;
        self.current_file = ::core::option::Option::None;
        self.use_new_compression_scheme = ::core::option::Option::None;
        self.is_chat = false;
        self.conversation_id.clear();
        self.environment_info = ::core::option::Option::None;
        self.is_agentic = false;
        self.supported_tools.clear();
        self.mcp_tools.clear();
        self.use_full_inputs_context = ::core::option::Option::None;
        self.allow_model_fallbacks = ::core::option::Option::None;
        self.unified_mode = ::core::option::Option::None;
        self.should_disable_tools = ::core::option::Option::None;
        self.thinking_level = ::core::option::Option::None;
        self.uses_rules = ::core::option::Option::None;
        self.unified_mode_name = ::core::option::Option::None;
    }
}
/// .aiserver.v1.StreamUnifiedChatResponse
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash)]
pub struct StreamUnifiedChatResponse {
    pub text: ::alloc::string::String,
    pub web_citation: ::core::option::Option<WebCitation>,
    pub thinking: ::core::option::Option<conversation_message::Thinking>,
}
impl ::prost::Message for StreamUnifiedChatResponse {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.text) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.text, buf) }
        if let ::core::option::Option::Some(ref value) = self.web_citation { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(11) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.thinking { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(25) }, value, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.text, buf, ctx).map_err(|mut error| { error.push("StreamUnifiedChatResponse", "text"); error }),
            11 => if let ::core::option::Option::Some(ref mut value) = self.web_citation { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.web_citation = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamUnifiedChatResponse", "web_citation"); error }),
            25 => if let ::core::option::Option::Some(ref mut value) = self.thinking { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.thinking = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("StreamUnifiedChatResponse", "thinking"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.text) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.text) }
        if let ::core::option::Option::Some(ref value) = self.web_citation { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(11) }, value) }
        if let ::core::option::Option::Some(ref value) = self.thinking { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(25) }, value) }
        len
    }
    fn clear(&mut self) {
        self.text.clear();
        self.web_citation = ::core::option::Option::None;
        self.thinking = ::core::option::Option::None;
    }
}
/// .aiserver.v1.ConversationMessageHeader
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash)]
pub struct ConversationMessageHeader {
    pub bubble_id: ::byte_str::ByteStr,
    pub server_bubble_id: ::core::option::Option<::byte_str::ByteStr>,
    pub r#type: ::proto_value::Enum<conversation_message::MessageType>,
}
impl ::prost::Message for ConversationMessageHeader {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.bubble_id) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.bubble_id, buf) }
        if let ::core::option::Option::Some(ref value) = self.server_bubble_id { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value, buf) }
        if !::proto_value::is_default(&self.r#type) { ::prost::encoding::r#enum::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.r#type, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.bubble_id, buf, ctx).map_err(|mut error| { error.push("ConversationMessageHeader", "bubble_id"); error }),
            2 => if let ::core::option::Option::Some(ref mut value) = self.server_bubble_id { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.server_bubble_id = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("ConversationMessageHeader", "server_bubble_id"); error }),
            3 => ::prost::encoding::r#enum::merge(wire_type, &mut self.r#type, buf, ctx).map_err(|mut error| { error.push("ConversationMessageHeader", "type"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.bubble_id) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.bubble_id) }
        if let ::core::option::Option::Some(ref value) = self.server_bubble_id { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value) }
        if !::proto_value::is_default(&self.r#type) { len += ::prost::encoding::r#enum::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.r#type) }
        len
    }
    fn clear(&mut self) {
        self.bubble_id.clear();
        self.server_bubble_id = ::core::option::Option::None;
        self.r#type = ::proto_value::Enum::default();
    }
}
/// Nested message and enum types in [`ConversationMessage`].
pub mod conversation_message {
    /// .aiserver.v1.ConversationMessage.MessageType
    #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum MessageType {
        #[default]
        Unspecified = 0,
        Human = 1,
        Ai = 2,
    }
    impl ::core::convert::From::<MessageType> for i32 {
        #[inline]
        fn from(value: MessageType) -> i32 { value as i32 }
    }
    impl ::core::convert::TryFrom::<i32> for MessageType {
        type Error = ();
        #[inline]
        fn try_from(value: i32) -> ::core::result::Result<Self, ()> {
            match value {
                0 => ::core::result::Result::Ok(Self::Unspecified),
                1 => ::core::result::Result::Ok(Self::Human),
                2 => ::core::result::Result::Ok(Self::Ai),
                _ => ::core::result::Result::Err(()),
            }
        }
    }
    /// .aiserver.v1.ConversationMessage.ToolResult
    #[derive(Debug, Default, Clone, PartialEq, Eq, Hash)]
    pub struct ToolResult {
        pub tool_call_id: ::byte_str::ByteStr,
        pub tool_name: ::byte_str::ByteStr,
        pub tool_index: u32,
        pub model_call_id: ::core::option::Option<::byte_str::ByteStr>,
        pub raw_args: ::byte_str::ByteStr,
        pub result: ::core::option::Option<super::ClientSideToolV2Result>,
        pub tool_call: ::core::option::Option<super::ClientSideToolV2Call>,
    }
    impl ::prost::Message for ToolResult {
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if !::proto_value::is_default(&self.tool_call_id) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.tool_call_id, buf) }
            if !::proto_value::is_default(&self.tool_name) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.tool_name, buf) }
            if !::proto_value::is_default(&self.tool_index) { ::prost::encoding::uint32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.tool_index, buf) }
            if !::proto_value::is_default(&self.raw_args) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, &self.raw_args, buf) }
            if let ::core::option::Option::Some(ref value) = self.result { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(8) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.tool_call { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(11) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.model_call_id { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(12) }, value, buf) }
        }
        fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
            match number.get() {
                1 => ::prost::encoding::string::merge(wire_type, &mut self.tool_call_id, buf, ctx).map_err(|mut error| { error.push("ToolResult", "tool_call_id"); error }),
                2 => ::prost::encoding::string::merge(wire_type, &mut self.tool_name, buf, ctx).map_err(|mut error| { error.push("ToolResult", "tool_name"); error }),
                3 => ::prost::encoding::uint32::merge(wire_type, &mut self.tool_index, buf, ctx).map_err(|mut error| { error.push("ToolResult", "tool_index"); error }),
                5 => ::prost::encoding::string::merge(wire_type, &mut self.raw_args, buf, ctx).map_err(|mut error| { error.push("ToolResult", "raw_args"); error }),
                8 => if let ::core::option::Option::Some(ref mut value) = self.result { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.result = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("ToolResult", "result"); error }),
                11 => if let ::core::option::Option::Some(ref mut value) = self.tool_call { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.tool_call = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("ToolResult", "tool_call"); error }),
                12 => if let ::core::option::Option::Some(ref mut value) = self.model_call_id { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.model_call_id = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("ToolResult", "model_call_id"); error }),
                _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
            }
        }
        fn encoded_len(&self) -> usize {
            let mut len = 0;
            if !::proto_value::is_default(&self.tool_call_id) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.tool_call_id) }
            if !::proto_value::is_default(&self.tool_name) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.tool_name) }
            if !::proto_value::is_default(&self.tool_index) { len += ::prost::encoding::uint32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.tool_index) }
            if !::proto_value::is_default(&self.raw_args) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, &self.raw_args) }
            if let ::core::option::Option::Some(ref value) = self.result { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(8) }, value) }
            if let ::core::option::Option::Some(ref value) = self.tool_call { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(11) }, value) }
            if let ::core::option::Option::Some(ref value) = self.model_call_id { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(12) }, value) }
            len
        }
        fn clear(&mut self) {
            self.tool_call_id.clear();
            self.tool_name.clear();
            self.tool_index = 0u32;
            self.model_call_id = ::core::option::Option::None;
            self.raw_args.clear();
            self.result = ::core::option::Option::None;
            self.tool_call = ::core::option::Option::None;
        }
    }
    /// .aiserver.v1.ConversationMessage.Thinking
    #[derive(Debug, Default, Clone, PartialEq, Eq, Hash)]
    pub struct Thinking {
        pub text: ::alloc::string::String,
        pub signature: ::alloc::string::String,
        pub redacted_thinking: ::alloc::string::String,
    }
    impl ::prost::Message for Thinking {
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if !::proto_value::is_default(&self.text) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.text, buf) }
            if !::proto_value::is_default(&self.signature) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.signature, buf) }
            if !::proto_value::is_default(&self.redacted_thinking) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.redacted_thinking, buf) }
        }
        fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
            match number.get() {
                1 => ::prost::encoding::string::merge(wire_type, &mut self.text, buf, ctx).map_err(|mut error| { error.push("Thinking", "text"); error }),
                2 => ::prost::encoding::string::merge(wire_type, &mut self.signature, buf, ctx).map_err(|mut error| { error.push("Thinking", "signature"); error }),
                3 => ::prost::encoding::string::merge(wire_type, &mut self.redacted_thinking, buf, ctx).map_err(|mut error| { error.push("Thinking", "redacted_thinking"); error }),
                _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
            }
        }
        fn encoded_len(&self) -> usize {
            let mut len = 0;
            if !::proto_value::is_default(&self.text) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.text) }
            if !::proto_value::is_default(&self.signature) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.signature) }
            if !::proto_value::is_default(&self.redacted_thinking) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.redacted_thinking) }
            len
        }
        fn clear(&mut self) {
            self.text.clear();
            self.signature.clear();
            self.redacted_thinking.clear();
        }
    }
}
/// .aiserver.v1.ConversationMessage
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash)]
pub struct ConversationMessage {
    pub text: ::alloc::string::String,
    pub r#type: ::proto_value::Enum<conversation_message::MessageType>,
    pub images: ::alloc::vec::Vec<ImageProto>,
    pub bubble_id: ::byte_str::ByteStr,
    pub server_bubble_id: ::core::option::Option<::byte_str::ByteStr>,
    pub tool_results: ::alloc::vec::Vec<conversation_message::ToolResult>,
    pub is_agentic: bool,
    pub web_references: ::alloc::vec::Vec<WebReference>,
    pub thinking: ::core::option::Option<conversation_message::Thinking>,
    pub unified_mode: ::core::option::Option<::proto_value::Enum<stream_unified_chat_request::UnifiedMode>>,
    pub supported_tools: ::alloc::vec::Vec<::proto_value::Enum<ClientSideToolV2>>,
    pub external_links: ::alloc::vec::Vec<ComposerExternalLink>,
    pub use_web: ::core::option::Option<bool>,
}
impl ::prost::Message for ConversationMessage {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.text) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.text, buf) }
        if !::proto_value::is_default(&self.r#type) { ::prost::encoding::r#enum::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.r#type, buf) }
        if !::alloc::vec::Vec::is_empty(&self.images) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(10) }, &self.images, buf) }
        if !::proto_value::is_default(&self.bubble_id) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(13) }, &self.bubble_id, buf) }
        if !::alloc::vec::Vec::is_empty(&self.tool_results) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(18) }, &self.tool_results, buf) }
        if !::proto_value::is_default(&self.is_agentic) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(29) }, &self.is_agentic, buf) }
        if let ::core::option::Option::Some(ref value) = self.server_bubble_id { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(32) }, value, buf) }
        if !::alloc::vec::Vec::is_empty(&self.web_references) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(36) }, &self.web_references, buf) }
        if let ::core::option::Option::Some(ref value) = self.thinking { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(45) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.unified_mode { ::prost::encoding::r#enum::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(47) }, value, buf) }
        if !::alloc::vec::Vec::is_empty(&self.supported_tools) { ::prost::encoding::r#enum::encode_packed(unsafe { ::core::num::NonZeroU32::new_unchecked(51) }, &self.supported_tools, buf) }
        if !::alloc::vec::Vec::is_empty(&self.external_links) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(62) }, &self.external_links, buf) }
        if let ::core::option::Option::Some(ref value) = self.use_web { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(63) }, value, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::string::merge(wire_type, &mut self.text, buf, ctx).map_err(|mut error| { error.push("ConversationMessage", "text"); error }),
            2 => ::prost::encoding::r#enum::merge(wire_type, &mut self.r#type, buf, ctx).map_err(|mut error| { error.push("ConversationMessage", "type"); error }),
            10 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.images, buf, ctx).map_err(|mut error| { error.push("ConversationMessage", "images"); error }),
            13 => ::prost::encoding::string::merge(wire_type, &mut self.bubble_id, buf, ctx).map_err(|mut error| { error.push("ConversationMessage", "bubble_id"); error }),
            18 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.tool_results, buf, ctx).map_err(|mut error| { error.push("ConversationMessage", "tool_results"); error }),
            29 => ::prost::encoding::bool::merge(wire_type, &mut self.is_agentic, buf, ctx).map_err(|mut error| { error.push("ConversationMessage", "is_agentic"); error }),
            32 => if let ::core::option::Option::Some(ref mut value) = self.server_bubble_id { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.server_bubble_id = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("ConversationMessage", "server_bubble_id"); error }),
            36 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.web_references, buf, ctx).map_err(|mut error| { error.push("ConversationMessage", "web_references"); error }),
            45 => if let ::core::option::Option::Some(ref mut value) = self.thinking { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.thinking = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("ConversationMessage", "thinking"); error }),
            47 => if let ::core::option::Option::Some(ref mut value) = self.unified_mode { ::prost::encoding::r#enum::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::r#enum::merge(wire_type, &mut value, buf, ctx).map(|_| self.unified_mode = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("ConversationMessage", "unified_mode"); error }),
            51 => ::prost::encoding::r#enum::merge_repeated(wire_type, &mut self.supported_tools, buf, ctx).map_err(|mut error| { error.push("ConversationMessage", "supported_tools"); error }),
            62 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.external_links, buf, ctx).map_err(|mut error| { error.push("ConversationMessage", "external_links"); error }),
            63 => if let ::core::option::Option::Some(ref mut value) = self.use_web { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.use_web = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("ConversationMessage", "use_web"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.text) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.text) }
        if !::proto_value::is_default(&self.r#type) { len += ::prost::encoding::r#enum::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.r#type) }
        if !::alloc::vec::Vec::is_empty(&self.images) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(10) }, &self.images) }
        if !::proto_value::is_default(&self.bubble_id) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(13) }, &self.bubble_id) }
        if !::alloc::vec::Vec::is_empty(&self.tool_results) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(18) }, &self.tool_results) }
        if !::proto_value::is_default(&self.is_agentic) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(29) }, &self.is_agentic) }
        if let ::core::option::Option::Some(ref value) = self.server_bubble_id { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(32) }, value) }
        if !::alloc::vec::Vec::is_empty(&self.web_references) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(36) }, &self.web_references) }
        if let ::core::option::Option::Some(ref value) = self.thinking { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(45) }, value) }
        if let ::core::option::Option::Some(ref value) = self.unified_mode { len += ::prost::encoding::r#enum::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(47) }, value) }
        if !::alloc::vec::Vec::is_empty(&self.supported_tools) { len += ::prost::encoding::r#enum::encoded_len_packed(unsafe { ::core::num::NonZeroU32::new_unchecked(51) }, &self.supported_tools) }
        if !::alloc::vec::Vec::is_empty(&self.external_links) { len += ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(62) }, &self.external_links) }
        if let ::core::option::Option::Some(ref value) = self.use_web { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(63) }, value) }
        len
    }
    fn clear(&mut self) {
        self.text.clear();
        self.r#type = ::proto_value::Enum::default();
        self.images.clear();
        self.bubble_id.clear();
        self.server_bubble_id = ::core::option::Option::None;
        self.tool_results.clear();
        self.is_agentic = false;
        self.web_references.clear();
        self.thinking = ::core::option::Option::None;
        self.unified_mode = ::core::option::Option::None;
        self.supported_tools.clear();
        self.external_links.clear();
        self.use_web = ::core::option::Option::None;
    }
}
/// Nested message and enum types in [`GetPromptDryRunResponse`].
pub mod get_prompt_dry_run_response {
    /// .aiserver.v1.GetPromptDryRunResponse.TokenCount
    #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
    pub struct TokenCount {
        pub num_tokens: ::core::option::Option<i32>,
    }
    impl ::prost::Message for TokenCount {
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) { if let ::core::option::Option::Some(ref value) = self.num_tokens { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value, buf) }         }
        fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
            match number.get() {
                2 => if let ::core::option::Option::Some(ref mut value) = self.num_tokens { ::prost::encoding::int32::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::int32::merge(wire_type, &mut value, buf, ctx).map(|_| self.num_tokens = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("TokenCount", "num_tokens"); error }),
                _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
            }
        }
        fn encoded_len(&self) -> usize { if let ::core::option::Option::Some(ref value) = self.num_tokens { ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, value) } else { 0 } }
        fn clear(&mut self) { self.num_tokens = ::core::option::Option::None }
    }
}
/// .aiserver.v1.GetPromptDryRunResponse
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, Hash)]
pub struct GetPromptDryRunResponse {
    pub user_message_token_count: ::core::option::Option<get_prompt_dry_run_response::TokenCount>,
    pub full_conversation_token_count: ::core::option::Option<get_prompt_dry_run_response::TokenCount>,
}
impl ::prost::Message for GetPromptDryRunResponse {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if let ::core::option::Option::Some(ref value) = self.user_message_token_count { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, value, buf) }
        if let ::core::option::Option::Some(ref value) = self.full_conversation_token_count { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, value, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            4 => if let ::core::option::Option::Some(ref mut value) = self.user_message_token_count { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.user_message_token_count = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("GetPromptDryRunResponse", "user_message_token_count"); error }),
            5 => if let ::core::option::Option::Some(ref mut value) = self.full_conversation_token_count { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.full_conversation_token_count = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("GetPromptDryRunResponse", "full_conversation_token_count"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if let ::core::option::Option::Some(ref value) = self.user_message_token_count { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, value) }
        if let ::core::option::Option::Some(ref value) = self.full_conversation_token_count { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, value) }
        len
    }
    fn clear(&mut self) {
        self.user_message_token_count = ::core::option::Option::None;
        self.full_conversation_token_count = ::core::option::Option::None;
    }
}
/// .aiserver.v1.AvailableModelsRequest
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Deserialize)]
pub struct AvailableModelsRequest {
    #[serde(rename = "isNightly", alias = "is_nightly", default)]
    pub is_nightly: bool,
    #[serde(rename = "includeLongContextModels", alias = "include_long_context_models", default)]
    pub include_long_context_models: bool,
    #[serde(rename = "excludeMaxNamedModels", alias = "exclude_max_named_models", default)]
    pub exclude_max_named_models: bool,
    #[serde(rename = "additionalModelNames", alias = "additional_model_names", default)]
    pub additional_model_names: ::alloc::vec::Vec<::alloc::string::String>,
}
impl ::prost::Message for AvailableModelsRequest {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
        if !::proto_value::is_default(&self.is_nightly) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.is_nightly, buf) }
        if !::proto_value::is_default(&self.include_long_context_models) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.include_long_context_models, buf) }
        if !::proto_value::is_default(&self.exclude_max_named_models) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.exclude_max_named_models, buf) }
        if !::alloc::vec::Vec::is_empty(&self.additional_model_names) { ::prost::encoding::string::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.additional_model_names, buf) }
    }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            1 => ::prost::encoding::bool::merge(wire_type, &mut self.is_nightly, buf, ctx).map_err(|mut error| { error.push("AvailableModelsRequest", "is_nightly"); error }),
            2 => ::prost::encoding::bool::merge(wire_type, &mut self.include_long_context_models, buf, ctx).map_err(|mut error| { error.push("AvailableModelsRequest", "include_long_context_models"); error }),
            3 => ::prost::encoding::bool::merge(wire_type, &mut self.exclude_max_named_models, buf, ctx).map_err(|mut error| { error.push("AvailableModelsRequest", "exclude_max_named_models"); error }),
            4 => ::prost::encoding::string::merge_repeated(wire_type, &mut self.additional_model_names, buf, ctx).map_err(|mut error| { error.push("AvailableModelsRequest", "additional_model_names"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize {
        let mut len = 0;
        if !::proto_value::is_default(&self.is_nightly) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.is_nightly) }
        if !::proto_value::is_default(&self.include_long_context_models) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.include_long_context_models) }
        if !::proto_value::is_default(&self.exclude_max_named_models) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.exclude_max_named_models) }
        if !::alloc::vec::Vec::is_empty(&self.additional_model_names) { len += ::prost::encoding::string::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.additional_model_names) }
        len
    }
    fn clear(&mut self) {
        self.is_nightly = false;
        self.include_long_context_models = false;
        self.exclude_max_named_models = false;
        self.additional_model_names.clear();
    }
}
/// Nested message and enum types in [`AvailableModelsResponse`].
pub mod available_models_response {
    /// .aiserver.v1.AvailableModelsResponse.DegradationStatus
    #[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde::Serialize)]
    pub enum DegradationStatus {
        #[default]
        #[serde(rename = "DEGRADATION_STATUS_UNSPECIFIED")]
        Unspecified = 0,
        #[serde(rename = "DEGRADATION_STATUS_DEGRADED")]
        Degraded = 1,
        #[serde(rename = "DEGRADATION_STATUS_DISABLED")]
        Disabled = 2,
    }
    impl ::core::convert::From::<DegradationStatus> for i32 {
        #[inline]
        fn from(value: DegradationStatus) -> i32 { value as i32 }
    }
    impl ::core::convert::TryFrom::<i32> for DegradationStatus {
        type Error = ();
        #[inline]
        fn try_from(value: i32) -> ::core::result::Result<Self, ()> {
            match value {
                0 => ::core::result::Result::Ok(Self::Unspecified),
                1 => ::core::result::Result::Ok(Self::Degraded),
                2 => ::core::result::Result::Ok(Self::Disabled),
                _ => ::core::result::Result::Err(()),
            }
        }
    }
    /// .aiserver.v1.AvailableModelsResponse.TooltipData
    #[derive(Debug, Default, Clone, PartialEq, Eq, Hash, ::serde::Serialize)]
    pub struct TooltipData {
        #[serde(rename = "primaryText", skip_serializing_if = "::proto_value::is_default")]
        pub primary_text: ::alloc::string::String,
        #[serde(rename = "secondaryText", skip_serializing_if = "::proto_value::is_default")]
        pub secondary_text: ::alloc::string::String,
        #[serde(rename = "secondaryWarningText", skip_serializing_if = "::proto_value::is_default")]
        pub secondary_warning_text: bool,
        #[serde(skip_serializing_if = "::proto_value::is_default")]
        pub icon: ::alloc::string::String,
        #[serde(rename = "tertiaryText", skip_serializing_if = "::proto_value::is_default")]
        pub tertiary_text: ::alloc::string::String,
        #[serde(rename = "tertiaryTextUrl", skip_serializing_if = "::proto_value::is_default")]
        pub tertiary_text_url: ::alloc::string::String,
        #[serde(rename = "markdownContent", skip_serializing_if = "::core::option::Option::is_none")]
        pub markdown_content: ::core::option::Option<::alloc::string::String>,
    }
    impl ::prost::Message for TooltipData {
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if !::proto_value::is_default(&self.primary_text) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.primary_text, buf) }
            if !::proto_value::is_default(&self.secondary_text) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.secondary_text, buf) }
            if !::proto_value::is_default(&self.secondary_warning_text) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.secondary_warning_text, buf) }
            if !::proto_value::is_default(&self.icon) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.icon, buf) }
            if !::proto_value::is_default(&self.tertiary_text) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, &self.tertiary_text, buf) }
            if !::proto_value::is_default(&self.tertiary_text_url) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(6) }, &self.tertiary_text_url, buf) }
            if let ::core::option::Option::Some(ref value) = self.markdown_content { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(7) }, value, buf) }
        }
        fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
            match number.get() {
                1 => ::prost::encoding::string::merge(wire_type, &mut self.primary_text, buf, ctx).map_err(|mut error| { error.push("TooltipData", "primary_text"); error }),
                2 => ::prost::encoding::string::merge(wire_type, &mut self.secondary_text, buf, ctx).map_err(|mut error| { error.push("TooltipData", "secondary_text"); error }),
                3 => ::prost::encoding::bool::merge(wire_type, &mut self.secondary_warning_text, buf, ctx).map_err(|mut error| { error.push("TooltipData", "secondary_warning_text"); error }),
                4 => ::prost::encoding::string::merge(wire_type, &mut self.icon, buf, ctx).map_err(|mut error| { error.push("TooltipData", "icon"); error }),
                5 => ::prost::encoding::string::merge(wire_type, &mut self.tertiary_text, buf, ctx).map_err(|mut error| { error.push("TooltipData", "tertiary_text"); error }),
                6 => ::prost::encoding::string::merge(wire_type, &mut self.tertiary_text_url, buf, ctx).map_err(|mut error| { error.push("TooltipData", "tertiary_text_url"); error }),
                7 => if let ::core::option::Option::Some(ref mut value) = self.markdown_content { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.markdown_content = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("TooltipData", "markdown_content"); error }),
                _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
            }
        }
        fn encoded_len(&self) -> usize {
            let mut len = 0;
            if !::proto_value::is_default(&self.primary_text) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.primary_text) }
            if !::proto_value::is_default(&self.secondary_text) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.secondary_text) }
            if !::proto_value::is_default(&self.secondary_warning_text) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, &self.secondary_warning_text) }
            if !::proto_value::is_default(&self.icon) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, &self.icon) }
            if !::proto_value::is_default(&self.tertiary_text) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, &self.tertiary_text) }
            if !::proto_value::is_default(&self.tertiary_text_url) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(6) }, &self.tertiary_text_url) }
            if let ::core::option::Option::Some(ref value) = self.markdown_content { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(7) }, value) }
            len
        }
        fn clear(&mut self) {
            self.primary_text.clear();
            self.secondary_text.clear();
            self.secondary_warning_text = false;
            self.icon.clear();
            self.tertiary_text.clear();
            self.tertiary_text_url.clear();
            self.markdown_content = ::core::option::Option::None;
        }
    }
    /// .aiserver.v1.AvailableModelsResponse.AvailableModel
    #[derive(Debug, Default, Clone, PartialEq, ::serde::Serialize)]
    pub struct AvailableModel {
        #[serde(skip_serializing_if = "::proto_value::is_default")]
        pub name: ::alloc::string::String,
        #[serde(rename = "defaultOn", skip_serializing_if = "::proto_value::is_default")]
        pub default_on: bool,
        #[serde(rename = "isLongContextOnly", skip_serializing_if = "::core::option::Option::is_none")]
        pub is_long_context_only: ::core::option::Option<bool>,
        #[serde(rename = "isChatOnly", skip_serializing_if = "::core::option::Option::is_none")]
        pub is_chat_only: ::core::option::Option<bool>,
        #[serde(rename = "supportsAgent", skip_serializing_if = "::core::option::Option::is_none")]
        pub supports_agent: ::core::option::Option<bool>,
        #[serde(rename = "degradationStatus", skip_serializing_if = "::core::option::Option::is_none")]
        pub degradation_status: ::core::option::Option<::proto_value::Enum<DegradationStatus>>,
        #[serde(skip_serializing_if = "::core::option::Option::is_none")]
        pub price: ::core::option::Option<f64>,
        #[serde(rename = "tooltipData", skip_serializing_if = "::core::option::Option::is_none")]
        pub tooltip_data: ::core::option::Option<TooltipData>,
        #[serde(rename = "tooltipDataForMaxMode", skip_serializing_if = "::core::option::Option::is_none")]
        pub tooltip_data_for_max_mode: ::core::option::Option<TooltipData>,
        #[serde(rename = "supportsThinking", skip_serializing_if = "::core::option::Option::is_none")]
        pub supports_thinking: ::core::option::Option<bool>,
        #[serde(rename = "supportsImages", skip_serializing_if = "::core::option::Option::is_none")]
        pub supports_images: ::core::option::Option<bool>,
        #[serde(rename = "supportsAutoContext", skip_serializing_if = "::core::option::Option::is_none")]
        pub supports_auto_context: ::core::option::Option<bool>,
        #[serde(rename = "autoContextMaxTokens", skip_serializing_if = "::core::option::Option::is_none")]
        pub auto_context_max_tokens: ::core::option::Option<i32>,
        #[serde(rename = "autoContextExtendedMaxTokens", skip_serializing_if = "::core::option::Option::is_none")]
        pub auto_context_extended_max_tokens: ::core::option::Option<i32>,
        #[serde(rename = "supportsMaxMode", skip_serializing_if = "::core::option::Option::is_none")]
        pub supports_max_mode: ::core::option::Option<bool>,
        #[serde(rename = "supportsNonMaxMode", skip_serializing_if = "::core::option::Option::is_none")]
        pub supports_non_max_mode: ::core::option::Option<bool>,
        #[serde(rename = "contextTokenLimit", skip_serializing_if = "::core::option::Option::is_none")]
        pub context_token_limit: ::core::option::Option<i32>,
        #[serde(rename = "contextTokenLimitForMaxMode", skip_serializing_if = "::core::option::Option::is_none")]
        pub context_token_limit_for_max_mode: ::core::option::Option<i32>,
        #[serde(rename = "clientDisplayName", skip_serializing_if = "::core::option::Option::is_none")]
        pub client_display_name: ::core::option::Option<::alloc::string::String>,
        #[serde(rename = "serverModelName", skip_serializing_if = "::core::option::Option::is_none")]
        pub server_model_name: ::core::option::Option<::alloc::string::String>,
        #[serde(rename = "isRecommendedForBackgroundComposer", skip_serializing_if = "::core::option::Option::is_none")]
        pub is_recommended_for_background_composer: ::core::option::Option<bool>,
        #[serde(rename = "supportsPlanMode", skip_serializing_if = "::core::option::Option::is_none")]
        pub supports_plan_mode: ::core::option::Option<bool>,
        #[serde(rename = "supportsSandboxing", skip_serializing_if = "::core::option::Option::is_none")]
        pub supports_sandboxing: ::core::option::Option<bool>,
        #[serde(rename = "isUserAdded", skip_serializing_if = "::core::option::Option::is_none")]
        pub is_user_added: ::core::option::Option<bool>,
        #[serde(rename = "inputboxShortModelName", skip_serializing_if = "::core::option::Option::is_none")]
        pub inputbox_short_model_name: ::core::option::Option<::alloc::string::String>,
        #[serde(rename = "supportsCmdK", skip_serializing_if = "::core::option::Option::is_none")]
        pub supports_cmd_k: ::core::option::Option<bool>,
        #[serde(rename = "onlySupportsCmdK", skip_serializing_if = "::core::option::Option::is_none")]
        pub only_supports_cmd_k: ::core::option::Option<bool>,
        #[serde(rename = "backgroundComposerSortOrder", skip_serializing_if = "::core::option::Option::is_none")]
        pub background_composer_sort_order: ::core::option::Option<i32>,
    }
    impl ::prost::Message for AvailableModel {
        fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) {
            if !::proto_value::is_default(&self.name) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.name, buf) }
            if !::proto_value::is_default(&self.default_on) { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.default_on, buf) }
            if let ::core::option::Option::Some(ref value) = self.is_long_context_only { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.is_chat_only { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.supports_agent { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.degradation_status { ::prost::encoding::r#enum::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(6) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.price { ::prost::encoding::double::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(7) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.tooltip_data { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(8) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.supports_thinking { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(9) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.supports_images { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(10) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.supports_auto_context { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(11) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.auto_context_max_tokens { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(12) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.auto_context_extended_max_tokens { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(13) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.supports_max_mode { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(14) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.context_token_limit { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(15) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.context_token_limit_for_max_mode { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(16) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.client_display_name { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(17) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.server_model_name { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(18) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.supports_non_max_mode { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(19) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.tooltip_data_for_max_mode { ::prost::encoding::message::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(20) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.is_recommended_for_background_composer { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(21) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.supports_plan_mode { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(22) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.is_user_added { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(23) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.inputbox_short_model_name { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(24) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.supports_sandboxing { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(25) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.supports_cmd_k { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(26) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.only_supports_cmd_k { ::prost::encoding::bool::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(27) }, value, buf) }
            if let ::core::option::Option::Some(ref value) = self.background_composer_sort_order { ::prost::encoding::int32::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(28) }, value, buf) }
        }
        fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
            match number.get() {
                1 => ::prost::encoding::string::merge(wire_type, &mut self.name, buf, ctx).map_err(|mut error| { error.push("AvailableModel", "name"); error }),
                2 => ::prost::encoding::bool::merge(wire_type, &mut self.default_on, buf, ctx).map_err(|mut error| { error.push("AvailableModel", "default_on"); error }),
                3 => if let ::core::option::Option::Some(ref mut value) = self.is_long_context_only { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.is_long_context_only = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "is_long_context_only"); error }),
                4 => if let ::core::option::Option::Some(ref mut value) = self.is_chat_only { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.is_chat_only = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "is_chat_only"); error }),
                5 => if let ::core::option::Option::Some(ref mut value) = self.supports_agent { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.supports_agent = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "supports_agent"); error }),
                6 => if let ::core::option::Option::Some(ref mut value) = self.degradation_status { ::prost::encoding::r#enum::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::r#enum::merge(wire_type, &mut value, buf, ctx).map(|_| self.degradation_status = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "degradation_status"); error }),
                7 => if let ::core::option::Option::Some(ref mut value) = self.price { ::prost::encoding::double::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::double::merge(wire_type, &mut value, buf, ctx).map(|_| self.price = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "price"); error }),
                8 => if let ::core::option::Option::Some(ref mut value) = self.tooltip_data { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.tooltip_data = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "tooltip_data"); error }),
                9 => if let ::core::option::Option::Some(ref mut value) = self.supports_thinking { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.supports_thinking = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "supports_thinking"); error }),
                10 => if let ::core::option::Option::Some(ref mut value) = self.supports_images { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.supports_images = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "supports_images"); error }),
                11 => if let ::core::option::Option::Some(ref mut value) = self.supports_auto_context { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.supports_auto_context = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "supports_auto_context"); error }),
                12 => if let ::core::option::Option::Some(ref mut value) = self.auto_context_max_tokens { ::prost::encoding::int32::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::int32::merge(wire_type, &mut value, buf, ctx).map(|_| self.auto_context_max_tokens = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "auto_context_max_tokens"); error }),
                13 => if let ::core::option::Option::Some(ref mut value) = self.auto_context_extended_max_tokens { ::prost::encoding::int32::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::int32::merge(wire_type, &mut value, buf, ctx).map(|_| self.auto_context_extended_max_tokens = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "auto_context_extended_max_tokens"); error }),
                14 => if let ::core::option::Option::Some(ref mut value) = self.supports_max_mode { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.supports_max_mode = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "supports_max_mode"); error }),
                15 => if let ::core::option::Option::Some(ref mut value) = self.context_token_limit { ::prost::encoding::int32::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::int32::merge(wire_type, &mut value, buf, ctx).map(|_| self.context_token_limit = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "context_token_limit"); error }),
                16 => if let ::core::option::Option::Some(ref mut value) = self.context_token_limit_for_max_mode { ::prost::encoding::int32::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::int32::merge(wire_type, &mut value, buf, ctx).map(|_| self.context_token_limit_for_max_mode = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "context_token_limit_for_max_mode"); error }),
                17 => if let ::core::option::Option::Some(ref mut value) = self.client_display_name { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.client_display_name = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "client_display_name"); error }),
                18 => if let ::core::option::Option::Some(ref mut value) = self.server_model_name { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.server_model_name = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "server_model_name"); error }),
                19 => if let ::core::option::Option::Some(ref mut value) = self.supports_non_max_mode { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.supports_non_max_mode = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "supports_non_max_mode"); error }),
                20 => if let ::core::option::Option::Some(ref mut value) = self.tooltip_data_for_max_mode { ::prost::encoding::message::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::message::merge(wire_type, &mut value, buf, ctx).map(|_| self.tooltip_data_for_max_mode = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "tooltip_data_for_max_mode"); error }),
                21 => if let ::core::option::Option::Some(ref mut value) = self.is_recommended_for_background_composer { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.is_recommended_for_background_composer = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "is_recommended_for_background_composer"); error }),
                22 => if let ::core::option::Option::Some(ref mut value) = self.supports_plan_mode { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.supports_plan_mode = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "supports_plan_mode"); error }),
                23 => if let ::core::option::Option::Some(ref mut value) = self.is_user_added { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.is_user_added = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "is_user_added"); error }),
                24 => if let ::core::option::Option::Some(ref mut value) = self.inputbox_short_model_name { ::prost::encoding::string::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::string::merge(wire_type, &mut value, buf, ctx).map(|_| self.inputbox_short_model_name = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "inputbox_short_model_name"); error }),
                25 => if let ::core::option::Option::Some(ref mut value) = self.supports_sandboxing { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.supports_sandboxing = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "supports_sandboxing"); error }),
                26 => if let ::core::option::Option::Some(ref mut value) = self.supports_cmd_k { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.supports_cmd_k = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "supports_cmd_k"); error }),
                27 => if let ::core::option::Option::Some(ref mut value) = self.only_supports_cmd_k { ::prost::encoding::bool::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::bool::merge(wire_type, &mut value, buf, ctx).map(|_| self.only_supports_cmd_k = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "only_supports_cmd_k"); error }),
                28 => if let ::core::option::Option::Some(ref mut value) = self.background_composer_sort_order { ::prost::encoding::int32::merge(wire_type, value, buf, ctx) } else { let mut value = ::core::default::Default::default(); ::prost::encoding::int32::merge(wire_type, &mut value, buf, ctx).map(|_| self.background_composer_sort_order = ::core::option::Option::Some(value)) }.map_err(|mut error| { error.push("AvailableModel", "background_composer_sort_order"); error }),
                _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
            }
        }
        fn encoded_len(&self) -> usize {
            let mut len = 0;
            if !::proto_value::is_default(&self.name) { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(1) }, &self.name) }
            if !::proto_value::is_default(&self.default_on) { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.default_on) }
            if let ::core::option::Option::Some(ref value) = self.is_long_context_only { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(3) }, value) }
            if let ::core::option::Option::Some(ref value) = self.is_chat_only { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(4) }, value) }
            if let ::core::option::Option::Some(ref value) = self.supports_agent { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(5) }, value) }
            if let ::core::option::Option::Some(ref value) = self.degradation_status { len += ::prost::encoding::r#enum::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(6) }, value) }
            if let ::core::option::Option::Some(ref value) = self.price { len += ::prost::encoding::double::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(7) }, value) }
            if let ::core::option::Option::Some(ref value) = self.tooltip_data { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(8) }, value) }
            if let ::core::option::Option::Some(ref value) = self.supports_thinking { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(9) }, value) }
            if let ::core::option::Option::Some(ref value) = self.supports_images { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(10) }, value) }
            if let ::core::option::Option::Some(ref value) = self.supports_auto_context { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(11) }, value) }
            if let ::core::option::Option::Some(ref value) = self.auto_context_max_tokens { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(12) }, value) }
            if let ::core::option::Option::Some(ref value) = self.auto_context_extended_max_tokens { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(13) }, value) }
            if let ::core::option::Option::Some(ref value) = self.supports_max_mode { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(14) }, value) }
            if let ::core::option::Option::Some(ref value) = self.context_token_limit { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(15) }, value) }
            if let ::core::option::Option::Some(ref value) = self.context_token_limit_for_max_mode { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(16) }, value) }
            if let ::core::option::Option::Some(ref value) = self.client_display_name { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(17) }, value) }
            if let ::core::option::Option::Some(ref value) = self.server_model_name { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(18) }, value) }
            if let ::core::option::Option::Some(ref value) = self.supports_non_max_mode { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(19) }, value) }
            if let ::core::option::Option::Some(ref value) = self.tooltip_data_for_max_mode { len += ::prost::encoding::message::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(20) }, value) }
            if let ::core::option::Option::Some(ref value) = self.is_recommended_for_background_composer { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(21) }, value) }
            if let ::core::option::Option::Some(ref value) = self.supports_plan_mode { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(22) }, value) }
            if let ::core::option::Option::Some(ref value) = self.is_user_added { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(23) }, value) }
            if let ::core::option::Option::Some(ref value) = self.inputbox_short_model_name { len += ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(24) }, value) }
            if let ::core::option::Option::Some(ref value) = self.supports_sandboxing { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(25) }, value) }
            if let ::core::option::Option::Some(ref value) = self.supports_cmd_k { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(26) }, value) }
            if let ::core::option::Option::Some(ref value) = self.only_supports_cmd_k { len += ::prost::encoding::bool::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(27) }, value) }
            if let ::core::option::Option::Some(ref value) = self.background_composer_sort_order { len += ::prost::encoding::int32::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(28) }, value) }
            len
        }
        fn clear(&mut self) {
            self.name.clear();
            self.default_on = false;
            self.is_long_context_only = ::core::option::Option::None;
            self.is_chat_only = ::core::option::Option::None;
            self.supports_agent = ::core::option::Option::None;
            self.degradation_status = ::core::option::Option::None;
            self.price = ::core::option::Option::None;
            self.tooltip_data = ::core::option::Option::None;
            self.tooltip_data_for_max_mode = ::core::option::Option::None;
            self.supports_thinking = ::core::option::Option::None;
            self.supports_images = ::core::option::Option::None;
            self.supports_auto_context = ::core::option::Option::None;
            self.auto_context_max_tokens = ::core::option::Option::None;
            self.auto_context_extended_max_tokens = ::core::option::Option::None;
            self.supports_max_mode = ::core::option::Option::None;
            self.supports_non_max_mode = ::core::option::Option::None;
            self.context_token_limit = ::core::option::Option::None;
            self.context_token_limit_for_max_mode = ::core::option::Option::None;
            self.client_display_name = ::core::option::Option::None;
            self.server_model_name = ::core::option::Option::None;
            self.is_recommended_for_background_composer = ::core::option::Option::None;
            self.supports_plan_mode = ::core::option::Option::None;
            self.supports_sandboxing = ::core::option::Option::None;
            self.is_user_added = ::core::option::Option::None;
            self.inputbox_short_model_name = ::core::option::Option::None;
            self.supports_cmd_k = ::core::option::Option::None;
            self.only_supports_cmd_k = ::core::option::Option::None;
            self.background_composer_sort_order = ::core::option::Option::None;
        }
    }
}
/// .aiserver.v1.AvailableModelsResponse
#[derive(Debug, Default, Clone, PartialEq, ::serde::Serialize)]
pub struct AvailableModelsResponse {
    #[serde(skip_serializing_if = "::alloc::vec::Vec::is_empty")]
    pub models: ::alloc::vec::Vec<available_models_response::AvailableModel>,
}
impl ::prost::Message for AvailableModelsResponse {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) { if !::alloc::vec::Vec::is_empty(&self.models) { ::prost::encoding::message::encode_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.models, buf) }     }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            2 => ::prost::encoding::message::merge_repeated(wire_type, &mut self.models, buf, ctx).map_err(|mut error| { error.push("AvailableModelsResponse", "models"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize { if !::alloc::vec::Vec::is_empty(&self.models) { ::prost::encoding::message::encoded_len_repeated(unsafe { ::core::num::NonZeroU32::new_unchecked(2) }, &self.models) } else { 0 } }
    fn clear(&mut self) { self.models.clear() }
}
/// .aiserver.v1.GetServerConfigResponse
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash)]
pub struct GetServerConfigResponse {
    pub config_version: ::alloc::string::String,
}
impl ::prost::Message for GetServerConfigResponse {
    fn encode_raw(&self, buf: &mut impl ::prost::bytes::BufMut) { if !::proto_value::is_default(&self.config_version) { ::prost::encoding::string::encode(unsafe { ::core::num::NonZeroU32::new_unchecked(6) }, &self.config_version, buf) }     }
    fn merge_field(&mut self, number: ::core::num::NonZeroU32, wire_type: ::prost::encoding::wire_type::WireType, buf: &mut impl ::prost::bytes::Buf, ctx: ::prost::encoding::DecodeContext) -> ::core::result::Result<(), ::prost::DecodeError> {
        match number.get() {
            6 => ::prost::encoding::string::merge(wire_type, &mut self.config_version, buf, ctx).map_err(|mut error| { error.push("GetServerConfigResponse", "config_version"); error }),
            _ => ::prost::encoding::skip_field(wire_type, number, buf, ctx),
        }
    }
    fn encoded_len(&self) -> usize { if !::proto_value::is_default(&self.config_version) { ::prost::encoding::string::encoded_len(unsafe { ::core::num::NonZeroU32::new_unchecked(6) }, &self.config_version) } else { 0 } }
    fn clear(&mut self) { self.config_version.clear() }
}
